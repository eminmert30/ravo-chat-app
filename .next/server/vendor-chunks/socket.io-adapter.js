/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socket.io-adapter";
exports.ids = ["vendor-chunks/socket.io-adapter"];
exports.modules = {

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/cluster-adapter.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __rest = this && this.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = void 0;\nconst in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/index.js\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst debug = (0, debug_1.debug)(\"socket.io-adapter\");\nconst EMITTER_UID = \"emitter\";\nconst DEFAULT_TIMEOUT = 5000;\nfunction randomId() {\n    return (0, crypto_1.randomBytes)(8).toString(\"hex\");\n}\nvar MessageType;\n(function(MessageType) {\n    MessageType[MessageType[\"INITIAL_HEARTBEAT\"] = 1] = \"INITIAL_HEARTBEAT\";\n    MessageType[MessageType[\"HEARTBEAT\"] = 2] = \"HEARTBEAT\";\n    MessageType[MessageType[\"BROADCAST\"] = 3] = \"BROADCAST\";\n    MessageType[MessageType[\"SOCKETS_JOIN\"] = 4] = \"SOCKETS_JOIN\";\n    MessageType[MessageType[\"SOCKETS_LEAVE\"] = 5] = \"SOCKETS_LEAVE\";\n    MessageType[MessageType[\"DISCONNECT_SOCKETS\"] = 6] = \"DISCONNECT_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS\"] = 7] = \"FETCH_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS_RESPONSE\"] = 8] = \"FETCH_SOCKETS_RESPONSE\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT\"] = 9] = \"SERVER_SIDE_EMIT\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT_RESPONSE\"] = 10] = \"SERVER_SIDE_EMIT_RESPONSE\";\n    MessageType[MessageType[\"BROADCAST_CLIENT_COUNT\"] = 11] = \"BROADCAST_CLIENT_COUNT\";\n    MessageType[MessageType[\"BROADCAST_ACK\"] = 12] = \"BROADCAST_ACK\";\n    MessageType[MessageType[\"ADAPTER_CLOSE\"] = 13] = \"ADAPTER_CLOSE\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\nfunction encodeOptions(opts) {\n    return {\n        rooms: [\n            ...opts.rooms\n        ],\n        except: [\n            ...opts.except\n        ],\n        flags: opts.flags\n    };\n}\nfunction decodeOptions(opts) {\n    return {\n        rooms: new Set(opts.rooms),\n        except: new Set(opts.except),\n        flags: opts.flags\n    };\n}\n/**\n * A cluster-ready adapter. Any extending class must:\n *\n * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}\n * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}\n */ class ClusterAdapter extends in_memory_adapter_1.Adapter {\n    constructor(nsp){\n        super(nsp);\n        this.requests = new Map();\n        this.ackRequests = new Map();\n        this.uid = randomId();\n    }\n    /**\n     * Called when receiving a message from another member of the cluster.\n     *\n     * @param message\n     * @param offset\n     * @protected\n     */ onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch(message.type){\n            case MessageType.BROADCAST:\n                {\n                    const withAck = message.data.requestId !== undefined;\n                    if (withAck) {\n                        super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount)=>{\n                            debug(\"[%s] waiting for %d client acknowledgements\", this.uid, clientCount);\n                            this.publishResponse(message.uid, {\n                                type: MessageType.BROADCAST_CLIENT_COUNT,\n                                data: {\n                                    requestId: message.data.requestId,\n                                    clientCount\n                                }\n                            });\n                        }, (arg)=>{\n                            debug(\"[%s] received acknowledgement with value %j\", this.uid, arg);\n                            this.publishResponse(message.uid, {\n                                type: MessageType.BROADCAST_ACK,\n                                data: {\n                                    requestId: message.data.requestId,\n                                    packet: arg\n                                }\n                            });\n                        });\n                    } else {\n                        const packet = message.data.packet;\n                        const opts = decodeOptions(message.data.opts);\n                        this.addOffsetIfNecessary(packet, opts, offset);\n                        super.broadcast(packet, opts);\n                    }\n                    break;\n                }\n            case MessageType.SOCKETS_JOIN:\n                super.addSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.SOCKETS_LEAVE:\n                super.delSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.DISCONNECT_SOCKETS:\n                super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);\n                break;\n            case MessageType.FETCH_SOCKETS:\n                {\n                    debug(\"[%s] calling fetchSockets with opts %j\", this.uid, message.data.opts);\n                    super.fetchSockets(decodeOptions(message.data.opts)).then((localSockets)=>{\n                        this.publishResponse(message.uid, {\n                            type: MessageType.FETCH_SOCKETS_RESPONSE,\n                            data: {\n                                requestId: message.data.requestId,\n                                sockets: localSockets.map((socket)=>{\n                                    // remove sessionStore from handshake, as it may contain circular references\n                                    const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, [\n                                        \"sessionStore\"\n                                    ]);\n                                    return {\n                                        id: socket.id,\n                                        handshake,\n                                        rooms: [\n                                            ...socket.rooms\n                                        ],\n                                        data: socket.data\n                                    };\n                                })\n                            }\n                        });\n                    });\n                    break;\n                }\n            case MessageType.SERVER_SIDE_EMIT:\n                {\n                    const packet = message.data.packet;\n                    const withAck = message.data.requestId !== undefined;\n                    if (!withAck) {\n                        this.nsp._onServerSideEmit(packet);\n                        return;\n                    }\n                    let called = false;\n                    const callback = (arg)=>{\n                        // only one argument is expected\n                        if (called) {\n                            return;\n                        }\n                        called = true;\n                        debug(\"[%s] calling acknowledgement with %j\", this.uid, arg);\n                        this.publishResponse(message.uid, {\n                            type: MessageType.SERVER_SIDE_EMIT_RESPONSE,\n                            data: {\n                                requestId: message.data.requestId,\n                                packet: arg\n                            }\n                        });\n                    };\n                    this.nsp._onServerSideEmit([\n                        ...packet,\n                        callback\n                    ]);\n                    break;\n                }\n            // @ts-ignore\n            case MessageType.BROADCAST_CLIENT_COUNT:\n            // @ts-ignore\n            case MessageType.BROADCAST_ACK:\n            // @ts-ignore\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n            // @ts-ignore\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may\n                // always call the onMessage() method\n                this.onResponse(message);\n                break;\n            default:\n                debug(\"[%s] unknown message type: %s\", this.uid, message.type);\n        }\n    }\n    /**\n     * Called when receiving a response from another member of the cluster.\n     *\n     * @param response\n     * @protected\n     */ onResponse(response) {\n        var _a, _b;\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch(response.type){\n            case MessageType.BROADCAST_CLIENT_COUNT:\n                {\n                    (_a = this.ackRequests.get(requestId)) === null || _a === void 0 ? void 0 : _a.clientCountCallback(response.data.clientCount);\n                    break;\n                }\n            case MessageType.BROADCAST_ACK:\n                {\n                    (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);\n                    break;\n                }\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n                {\n                    const request = this.requests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    request.current++;\n                    response.data.sockets.forEach((socket)=>request.responses.push(socket));\n                    if (request.current === request.expected) {\n                        clearTimeout(request.timeout);\n                        request.resolve(request.responses);\n                        this.requests.delete(requestId);\n                    }\n                    break;\n                }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                {\n                    const request = this.requests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    request.current++;\n                    request.responses.push(response.data.packet);\n                    if (request.current === request.expected) {\n                        clearTimeout(request.timeout);\n                        request.resolve(null, request.responses);\n                        this.requests.delete(requestId);\n                    }\n                    break;\n                }\n            default:\n                // @ts-ignore\n                debug(\"[%s] unknown response type: %s\", this.uid, response.type);\n        }\n    }\n    async broadcast(packet, opts) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                const offset = await this.publishAndReturnOffset({\n                    type: MessageType.BROADCAST,\n                    data: {\n                        packet,\n                        opts: encodeOptions(opts)\n                    }\n                });\n                this.addOffsetIfNecessary(packet, opts, offset);\n            } catch (e) {\n                return debug(\"[%s] error while broadcasting message: %s\", this.uid, e.message);\n            }\n        }\n        super.broadcast(packet, opts);\n    }\n    /**\n     * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it\n     * reconnects after a temporary disconnection.\n     *\n     * @param packet\n     * @param opts\n     * @param offset\n     * @private\n     */ addOffsetIfNecessary(packet, opts, offset) {\n        var _a;\n        if (!this.nsp.server.opts.connectionStateRecovery) {\n            return;\n        }\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            packet.data.push(offset);\n        }\n    }\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        var _a;\n        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            const requestId = randomId();\n            this.ackRequests.set(requestId, {\n                clientCountCallback,\n                ack\n            });\n            this.publish({\n                type: MessageType.BROADCAST,\n                data: {\n                    packet,\n                    requestId,\n                    opts: encodeOptions(opts)\n                }\n            });\n            // we have no way to know at this level whether the server has received an acknowledgement from each client, so we\n            // will simply clean up the ackRequests map after the given delay\n            setTimeout(()=>{\n                this.ackRequests.delete(requestId);\n            }, opts.flags.timeout);\n        }\n        super.broadcastWithAck(packet, opts, clientCountCallback, ack);\n    }\n    async addSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_JOIN,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms\n                    }\n                });\n            } catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.addSockets(opts, rooms);\n    }\n    async delSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_LEAVE,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms\n                    }\n                });\n            } catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.delSockets(opts, rooms);\n    }\n    async disconnectSockets(opts, close) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.DISCONNECT_SOCKETS,\n                    data: {\n                        opts: encodeOptions(opts),\n                        close\n                    }\n                });\n            } catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.disconnectSockets(opts, close);\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets(opts),\n            this.serverCount()\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                const storedRequest = this.requests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));\n                    this.requests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                current: 0,\n                expected: expectedResponseCount,\n                responses: localSockets\n            };\n            this.requests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId\n                }\n            });\n        });\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet\n                }\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = await this.serverCount() - 1;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(()=>{\n            const storedRequest = this.requests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);\n                this.requests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            current: 0,\n            expected: expectedResponseCount,\n            responses: []\n        };\n        this.requests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet\n            }\n        });\n    }\n    publish(message) {\n        this.publishAndReturnOffset(message).catch((err)=>{\n            debug(\"[%s] error while publishing message: %s\", this.uid, err);\n        });\n    }\n    publishAndReturnOffset(message) {\n        message.uid = this.uid;\n        message.nsp = this.nsp.name;\n        return this.doPublish(message);\n    }\n    publishResponse(requesterUid, response) {\n        response.uid = this.uid;\n        response.nsp = this.nsp.name;\n        this.doPublishResponse(requesterUid, response).catch((err)=>{\n            debug(\"[%s] error while publishing response: %s\", this.uid, err);\n        });\n    }\n}\nexports.ClusterAdapter = ClusterAdapter;\nclass ClusterAdapterWithHeartbeat extends ClusterAdapter {\n    constructor(nsp, opts){\n        super(nsp);\n        this.nodesMap = new Map(); // uid => timestamp of last message\n        this.customRequests = new Map();\n        this._opts = Object.assign({\n            heartbeatInterval: 5000,\n            heartbeatTimeout: 10000\n        }, opts);\n        this.cleanupTimer = setInterval(()=>{\n            const now = Date.now();\n            this.nodesMap.forEach((lastSeen, uid)=>{\n                const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;\n                if (nodeSeemsDown) {\n                    debug(\"[%s] node %s seems down\", this.uid, uid);\n                    this.removeNode(uid);\n                }\n            });\n        }, 1000);\n    }\n    init() {\n        this.publish({\n            type: MessageType.INITIAL_HEARTBEAT\n        });\n    }\n    scheduleHeartbeat() {\n        if (this.heartbeatTimer) {\n            this.heartbeatTimer.refresh();\n        } else {\n            this.heartbeatTimer = setTimeout(()=>{\n                this.publish({\n                    type: MessageType.HEARTBEAT\n                });\n            }, this._opts.heartbeatInterval);\n        }\n    }\n    close() {\n        this.publish({\n            type: MessageType.ADAPTER_CLOSE\n        });\n        clearTimeout(this.heartbeatTimer);\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n        }\n    }\n    onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        if (message.uid && message.uid !== EMITTER_UID) {\n            // we track the UID of each sender, in order to know how many servers there are in the cluster\n            this.nodesMap.set(message.uid, Date.now());\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch(message.type){\n            case MessageType.INITIAL_HEARTBEAT:\n                this.publish({\n                    type: MessageType.HEARTBEAT\n                });\n                break;\n            case MessageType.HEARTBEAT:\n                break;\n            case MessageType.ADAPTER_CLOSE:\n                this.removeNode(message.uid);\n                break;\n            default:\n                super.onMessage(message, offset);\n        }\n    }\n    serverCount() {\n        return Promise.resolve(1 + this.nodesMap.size);\n    }\n    publish(message) {\n        this.scheduleHeartbeat();\n        return super.publish(message);\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet\n                }\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = this.nodesMap.size;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(()=>{\n            const storedRequest = this.customRequests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);\n                this.customRequests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            missingUids: new Set([\n                ...this.nodesMap.keys()\n            ]),\n            responses: []\n        };\n        this.customRequests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet\n            }\n        });\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets({\n                rooms: opts.rooms,\n                except: opts.except,\n                flags: {\n                    local: true\n                }\n            }),\n            this.serverCount()\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                const storedRequest = this.customRequests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));\n                    this.customRequests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                missingUids: new Set([\n                    ...this.nodesMap.keys()\n                ]),\n                responses: localSockets\n            };\n            this.customRequests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId\n                }\n            });\n        });\n    }\n    onResponse(response) {\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch(response.type){\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n                {\n                    const request = this.customRequests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    response.data.sockets.forEach((socket)=>request.responses.push(socket));\n                    request.missingUids.delete(response.uid);\n                    if (request.missingUids.size === 0) {\n                        clearTimeout(request.timeout);\n                        request.resolve(request.responses);\n                        this.customRequests.delete(requestId);\n                    }\n                    break;\n                }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                {\n                    const request = this.customRequests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    request.responses.push(response.data.packet);\n                    request.missingUids.delete(response.uid);\n                    if (request.missingUids.size === 0) {\n                        clearTimeout(request.timeout);\n                        request.resolve(null, request.responses);\n                        this.customRequests.delete(requestId);\n                    }\n                    break;\n                }\n            default:\n                super.onResponse(response);\n        }\n    }\n    removeNode(uid) {\n        this.customRequests.forEach((request, requestId)=>{\n            request.missingUids.delete(uid);\n            if (request.missingUids.size === 0) {\n                clearTimeout(request.timeout);\n                if (request.type === MessageType.FETCH_SOCKETS) {\n                    request.resolve(request.responses);\n                } else if (request.type === MessageType.SERVER_SIDE_EMIT) {\n                    request.resolve(null, request.responses);\n                }\n                this.customRequests.delete(requestId);\n            }\n        });\n        this.nodesMap.delete(uid);\n    }\n}\nexports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jbHVzdGVyLWFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxTQUFTLElBQUssSUFBSSxJQUFJLENBQUNBLE1BQU0sSUFBSyxTQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDaEQsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHLElBQUlJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNQLEdBQUdHLE1BQU1GLEVBQUVPLE9BQU8sQ0FBQ0wsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNmLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRCxJQUFLLElBQUlDLElBQUksR0FBR1AsSUFBSUMsT0FBT0sscUJBQXFCLENBQUNULElBQUlVLElBQUlQLEVBQUVRLE1BQU0sRUFBRUQsSUFBSztRQUNwRSxJQUFJVCxFQUFFTyxPQUFPLENBQUNMLENBQUMsQ0FBQ08sRUFBRSxJQUFJLEtBQUtOLE9BQU9DLFNBQVMsQ0FBQ08sb0JBQW9CLENBQUNMLElBQUksQ0FBQ1AsR0FBR0csQ0FBQyxDQUFDTyxFQUFFLEdBQ3pFUixDQUFDLENBQUNDLENBQUMsQ0FBQ08sRUFBRSxDQUFDLEdBQUdWLENBQUMsQ0FBQ0csQ0FBQyxDQUFDTyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPUjtBQUNYO0FBQ0FFLDhDQUE2QztJQUFFVyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQ0FBbUMsR0FBR0Esc0JBQXNCLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDMUYsTUFBTUssc0JBQXNCQyxtQkFBT0EsQ0FBQyw2RkFBcUI7QUFDekQsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMscUZBQU87QUFDL0IsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMs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Q0FBQ1QsU0FBU3JDLElBQUksQ0FBQ0ksTUFBTTtvQkFDM0NzQyxRQUFRMkQsV0FBVyxDQUFDbEQsTUFBTSxDQUFDZCxTQUFTNUMsR0FBRztvQkFDdkMsSUFBSWlELFFBQVEyRCxXQUFXLENBQUNELElBQUksS0FBSyxHQUFHO3dCQUNoQ3BELGFBQWFOLFFBQVFPLE9BQU87d0JBQzVCUCxRQUFRUSxPQUFPLENBQUMsTUFBTVIsUUFBUUcsU0FBUzt3QkFDdkMsSUFBSSxDQUFDbUMsY0FBYyxDQUFDN0IsTUFBTSxDQUFDbEQ7b0JBQy9CO29CQUNBO2dCQUNKO1lBQ0E7Z0JBQ0ksS0FBSyxDQUFDbUMsV0FBV0M7UUFDekI7SUFDSjtJQUNBc0QsV0FBV2xHLEdBQUcsRUFBRTtRQUNaLElBQUksQ0FBQ3VGLGNBQWMsQ0FBQ3BDLE9BQU8sQ0FBQyxDQUFDRixTQUFTekM7WUFDbEN5QyxRQUFRMkQsV0FBVyxDQUFDbEQsTUFBTSxDQUFDMUQ7WUFDM0IsSUFBSWlELFFBQVEyRCxXQUFXLENBQUNELElBQUksS0FBSyxHQUFHO2dCQUNoQ3BELGFBQWFOLFFBQVFPLE9BQU87Z0JBQzVCLElBQUlQLFFBQVE3QyxJQUFJLEtBQUs1QixZQUFZa0QsYUFBYSxFQUFFO29CQUM1Q3VCLFFBQVFRLE9BQU8sQ0FBQ1IsUUFBUUcsU0FBUztnQkFDckMsT0FDSyxJQUFJSCxRQUFRN0MsSUFBSSxLQUFLNUIsWUFBWThELGdCQUFnQixFQUFFO29CQUNwRFcsUUFBUVEsT0FBTyxDQUFDLE1BQU1SLFFBQVFHLFNBQVM7Z0JBQzNDO2dCQUNBLElBQUksQ0FBQ21DLGNBQWMsQ0FBQzdCLE1BQU0sQ0FBQ2xEO1lBQy9CO1FBQ0o7UUFDQSxJQUFJLENBQUM4RSxRQUFRLENBQUM1QixNQUFNLENBQUMxRDtJQUN6QjtBQUNKO0FBQ0E1QixtQ0FBbUMsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jbHVzdGVyLWFkYXB0ZXIuanM/YWEyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0ID0gZXhwb3J0cy5DbHVzdGVyQWRhcHRlciA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgPSB2b2lkIDA7XG5jb25zdCBpbl9tZW1vcnlfYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vaW4tbWVtb3J5LWFkYXB0ZXJcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWJ1ZykoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IEVNSVRURVJfVUlEID0gXCJlbWl0dGVyXCI7XG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSA1MDAwO1xuZnVuY3Rpb24gcmFuZG9tSWQoKSB7XG4gICAgcmV0dXJuICgwLCBjcnlwdG9fMS5yYW5kb21CeXRlcykoOCkudG9TdHJpbmcoXCJoZXhcIik7XG59XG52YXIgTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJJTklUSUFMX0hFQVJUQkVBVFwiXSA9IDFdID0gXCJJTklUSUFMX0hFQVJUQkVBVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiSEVBUlRCRUFUXCJdID0gMl0gPSBcIkhFQVJUQkVBVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQlJPQURDQVNUXCJdID0gM10gPSBcIkJST0FEQ0FTVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU09DS0VUU19KT0lOXCJdID0gNF0gPSBcIlNPQ0tFVFNfSk9JTlwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU09DS0VUU19MRUFWRVwiXSA9IDVdID0gXCJTT0NLRVRTX0xFQVZFXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJESVNDT05ORUNUX1NPQ0tFVFNcIl0gPSA2XSA9IFwiRElTQ09OTkVDVF9TT0NLRVRTXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJGRVRDSF9TT0NLRVRTXCJdID0gN10gPSBcIkZFVENIX1NPQ0tFVFNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkZFVENIX1NPQ0tFVFNfUkVTUE9OU0VcIl0gPSA4XSA9IFwiRkVUQ0hfU09DS0VUU19SRVNQT05TRVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU0VSVkVSX1NJREVfRU1JVFwiXSA9IDldID0gXCJTRVJWRVJfU0lERV9FTUlUXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFXCJdID0gMTBdID0gXCJTRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJCUk9BRENBU1RfQ0xJRU5UX0NPVU5UXCJdID0gMTFdID0gXCJCUk9BRENBU1RfQ0xJRU5UX0NPVU5UXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJCUk9BRENBU1RfQUNLXCJdID0gMTJdID0gXCJCUk9BRENBU1RfQUNLXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJBREFQVEVSX0NMT1NFXCJdID0gMTNdID0gXCJBREFQVEVSX0NMT1NFXCI7XG59KShNZXNzYWdlVHlwZSA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuTWVzc2FnZVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZW5jb2RlT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9vbXM6IFsuLi5vcHRzLnJvb21zXSxcbiAgICAgICAgZXhjZXB0OiBbLi4ub3B0cy5leGNlcHRdLFxuICAgICAgICBmbGFnczogb3B0cy5mbGFncyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVjb2RlT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9vbXM6IG5ldyBTZXQob3B0cy5yb29tcyksXG4gICAgICAgIGV4Y2VwdDogbmV3IFNldChvcHRzLmV4Y2VwdCksXG4gICAgICAgIGZsYWdzOiBvcHRzLmZsYWdzLFxuICAgIH07XG59XG4vKipcbiAqIEEgY2x1c3Rlci1yZWFkeSBhZGFwdGVyLiBBbnkgZXh0ZW5kaW5nIGNsYXNzIG11c3Q6XG4gKlxuICogLSBpbXBsZW1lbnQge0BsaW5rIENsdXN0ZXJBZGFwdGVyI2RvUHVibGlzaH0gYW5kIHtAbGluayBDbHVzdGVyQWRhcHRlciNkb1B1Ymxpc2hSZXNwb25zZX1cbiAqIC0gY2FsbCB7QGxpbmsgQ2x1c3RlckFkYXB0ZXIjb25NZXNzYWdlfSBhbmQge0BsaW5rIENsdXN0ZXJBZGFwdGVyI29uUmVzcG9uc2V9XG4gKi9cbmNsYXNzIENsdXN0ZXJBZGFwdGVyIGV4dGVuZHMgaW5fbWVtb3J5X2FkYXB0ZXJfMS5BZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihuc3ApIHtcbiAgICAgICAgc3VwZXIobnNwKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hY2tSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy51aWQgPSByYW5kb21JZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiByZWNlaXZpbmcgYSBtZXNzYWdlIGZyb20gYW5vdGhlciBtZW1iZXIgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25NZXNzYWdlKG1lc3NhZ2UsIG9mZnNldCkge1xuICAgICAgICBpZiAobWVzc2FnZS51aWQgPT09IHRoaXMudWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVidWcoXCJbJXNdIGlnbm9yZSBtZXNzYWdlIGZyb20gc2VsZlwiLCB0aGlzLnVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJbJXNdIG5ldyBldmVudCBvZiB0eXBlICVkIGZyb20gJXNcIiwgdGhpcy51aWQsIG1lc3NhZ2UudHlwZSwgbWVzc2FnZS51aWQpO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1Q6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoQWNrID0gbWVzc2FnZS5kYXRhLnJlcXVlc3RJZCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh3aXRoQWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmJyb2FkY2FzdFdpdGhBY2sobWVzc2FnZS5kYXRhLnBhY2tldCwgZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cyksIChjbGllbnRDb3VudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIHdhaXRpbmcgZm9yICVkIGNsaWVudCBhY2tub3dsZWRnZW1lbnRzXCIsIHRoaXMudWlkLCBjbGllbnRDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXNwb25zZShtZXNzYWdlLnVpZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkJST0FEQ0FTVF9DTElFTlRfQ09VTlQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIHJlY2VpdmVkIGFja25vd2xlZGdlbWVudCB3aXRoIHZhbHVlICVqXCIsIHRoaXMudWlkLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzcG9uc2UobWVzc2FnZS51aWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQUNLLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLmRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXQ6IGFyZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gbWVzc2FnZS5kYXRhLnBhY2tldDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0cyA9IGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE9mZnNldElmTmVjZXNzYXJ5KHBhY2tldCwgb3B0cywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuYnJvYWRjYXN0KHBhY2tldCwgb3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TT0NLRVRTX0pPSU46XG4gICAgICAgICAgICAgICAgc3VwZXIuYWRkU29ja2V0cyhkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKSwgbWVzc2FnZS5kYXRhLnJvb21zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU09DS0VUU19MRUFWRTpcbiAgICAgICAgICAgICAgICBzdXBlci5kZWxTb2NrZXRzKGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpLCBtZXNzYWdlLmRhdGEucm9vbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5ESVNDT05ORUNUX1NPQ0tFVFM6XG4gICAgICAgICAgICAgICAgc3VwZXIuZGlzY29ubmVjdFNvY2tldHMoZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cyksIG1lc3NhZ2UuZGF0YS5jbG9zZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFM6IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gY2FsbGluZyBmZXRjaFNvY2tldHMgd2l0aCBvcHRzICVqXCIsIHRoaXMudWlkLCBtZXNzYWdlLmRhdGEub3B0cyk7XG4gICAgICAgICAgICAgICAgc3VwZXJcbiAgICAgICAgICAgICAgICAgICAgLmZldGNoU29ja2V0cyhkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGxvY2FsU29ja2V0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXNwb25zZShtZXNzYWdlLnVpZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUU19SRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0czogbG9jYWxTb2NrZXRzLm1hcCgoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzZXNzaW9uU3RvcmUgZnJvbSBoYW5kc2hha2UsIGFzIGl0IG1heSBjb250YWluIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2EgPSBzb2NrZXQuaGFuZHNoYWtlLCB7IHNlc3Npb25TdG9yZSB9ID0gX2EsIGhhbmRzaGFrZSA9IF9fcmVzdChfYSwgW1wic2Vzc2lvblN0b3JlXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzb2NrZXQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb29tczogWy4uLnNvY2tldC5yb29tc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb2NrZXQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gbWVzc2FnZS5kYXRhLnBhY2tldDtcbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoQWNrID0gbWVzc2FnZS5kYXRhLnJlcXVlc3RJZCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICghd2l0aEFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5zcC5fb25TZXJ2ZXJTaWRlRW1pdChwYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBvbmUgYXJndW1lbnQgaXMgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBjYWxsaW5nIGFja25vd2xlZGdlbWVudCB3aXRoICVqXCIsIHRoaXMudWlkLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXNwb25zZShtZXNzYWdlLnVpZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0OiBhcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubnNwLl9vblNlcnZlclNpZGVFbWl0KFsuLi5wYWNrZXQsIGNhbGxiYWNrXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkJST0FEQ0FTVF9DTElFTlRfQ09VTlQ6XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkJST0FEQ0FTVF9BQ0s6XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFNfUkVTUE9OU0U6XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0U6XG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5kaW5nIGNsYXNzZXMgbWF5IG5vdCBtYWtlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiBhIENsdXN0ZXJNZXNzYWdlIGFuZCBhIENsdXN0ZXJSZXNwb25zZSBwYXlsb2FkIGFuZCBtYXlcbiAgICAgICAgICAgICAgICAvLyBhbHdheXMgY2FsbCB0aGUgb25NZXNzYWdlKCkgbWV0aG9kXG4gICAgICAgICAgICAgICAgdGhpcy5vblJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gdW5rbm93biBtZXNzYWdlIHR5cGU6ICVzXCIsIHRoaXMudWlkLCBtZXNzYWdlLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHJlY2VpdmluZyBhIHJlc3BvbnNlIGZyb20gYW5vdGhlciBtZW1iZXIgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXNwb25zZS5kYXRhLnJlcXVlc3RJZDtcbiAgICAgICAgZGVidWcoXCJbJXNdIHJlY2VpdmVkIHJlc3BvbnNlICVzIHRvIHJlcXVlc3QgJXNcIiwgdGhpcy51aWQsIHJlc3BvbnNlLnR5cGUsIHJlcXVlc3RJZCk7XG4gICAgICAgIHN3aXRjaCAocmVzcG9uc2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQ0xJRU5UX0NPVU5UOiB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5hY2tSZXF1ZXN0c1xuICAgICAgICAgICAgICAgICAgICAuZ2V0KHJlcXVlc3RJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGllbnRDb3VudENhbGxiYWNrKHJlc3BvbnNlLmRhdGEuY2xpZW50Q291bnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQUNLOiB7XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5hY2tSZXF1ZXN0cy5nZXQocmVxdWVzdElkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjayhyZXNwb25zZS5kYXRhLnBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFNfUkVTUE9OU0U6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0LmN1cnJlbnQrKztcbiAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhLnNvY2tldHMuZm9yRWFjaCgoc29ja2V0KSA9PiByZXF1ZXN0LnJlc3BvbnNlcy5wdXNoKHNvY2tldCkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmN1cnJlbnQgPT09IHJlcXVlc3QuZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZXMucHVzaChyZXNwb25zZS5kYXRhLnBhY2tldCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY3VycmVudCA9PT0gcmVxdWVzdC5leHBlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKG51bGwsIHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gdW5rbm93biByZXNwb25zZSB0eXBlOiAlc1wiLCB0aGlzLnVpZCwgcmVzcG9uc2UudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYnJvYWRjYXN0KHBhY2tldCwgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9ubHlMb2NhbCA9IChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gYXdhaXQgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQlJPQURDQVNULFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT2Zmc2V0SWZOZWNlc3NhcnkocGFja2V0LCBvcHRzLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVidWcoXCJbJXNdIGVycm9yIHdoaWxlIGJyb2FkY2FzdGluZyBtZXNzYWdlOiAlc1wiLCB0aGlzLnVpZCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5icm9hZGNhc3QocGFja2V0LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBvZmZzZXQgYXQgdGhlIGVuZCBvZiB0aGUgZGF0YSBhcnJheSBpbiBvcmRlciB0byBhbGxvdyB0aGUgY2xpZW50IHRvIHJlY2VpdmUgYW55IG1pc3NlZCBwYWNrZXRzIHdoZW4gaXRcbiAgICAgKiByZWNvbm5lY3RzIGFmdGVyIGEgdGVtcG9yYXJ5IGRpc2Nvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHBhcmFtIG9wdHNcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGRPZmZzZXRJZk5lY2Vzc2FyeShwYWNrZXQsIG9wdHMsIG9mZnNldCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5uc3Auc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0V2ZW50UGFja2V0ID0gcGFja2V0LnR5cGUgPT09IDI7XG4gICAgICAgIC8vIHBhY2tldHMgd2l0aCBhY2tub3dsZWRnZW1lbnQgYXJlIG5vdCBzdG9yZWQgYmVjYXVzZSB0aGUgYWNrbm93bGVkZ2VtZW50IGZ1bmN0aW9uIGNhbm5vdCBiZSBzZXJpYWxpemVkIGFuZFxuICAgICAgICAvLyByZXN0b3JlZCBvbiBhbm90aGVyIHNlcnZlciB1cG9uIHJlY29ubmVjdGlvblxuICAgICAgICBjb25zdCB3aXRob3V0QWNrbm93bGVkZ2VtZW50ID0gcGFja2V0LmlkID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG5vdFZvbGF0aWxlID0gKChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52b2xhdGlsZSkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlzRXZlbnRQYWNrZXQgJiYgd2l0aG91dEFja25vd2xlZGdlbWVudCAmJiBub3RWb2xhdGlsZSkge1xuICAgICAgICAgICAgcGFja2V0LmRhdGEucHVzaChvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJyb2FkY2FzdFdpdGhBY2socGFja2V0LCBvcHRzLCBjbGllbnRDb3VudENhbGxiYWNrLCBhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvbmx5TG9jYWwgPSAoX2EgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJhbmRvbUlkKCk7XG4gICAgICAgICAgICB0aGlzLmFja1JlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHtcbiAgICAgICAgICAgICAgICBjbGllbnRDb3VudENhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5CUk9BRENBU1QsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIG5vIHdheSB0byBrbm93IGF0IHRoaXMgbGV2ZWwgd2hldGhlciB0aGUgc2VydmVyIGhhcyByZWNlaXZlZCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSBlYWNoIGNsaWVudCwgc28gd2VcbiAgICAgICAgICAgIC8vIHdpbGwgc2ltcGx5IGNsZWFuIHVwIHRoZSBhY2tSZXF1ZXN0cyBtYXAgYWZ0ZXIgdGhlIGdpdmVuIGRlbGF5XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFja1JlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgfSwgb3B0cy5mbGFncy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5icm9hZGNhc3RXaXRoQWNrKHBhY2tldCwgb3B0cywgY2xpZW50Q291bnRDYWxsYmFjaywgYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkU29ja2V0cyhvcHRzLCByb29tcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9ubHlMb2NhbCA9IChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU09DS0VUU19KT0lOLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vbXMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIG1lc3NhZ2U6ICVzXCIsIHRoaXMudWlkLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmFkZFNvY2tldHMob3B0cywgcm9vbXMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxTb2NrZXRzKG9wdHMsIHJvb21zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb25seUxvY2FsID0gKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsO1xuICAgICAgICBpZiAoIW9ubHlMb2NhbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBbmRSZXR1cm5PZmZzZXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TT0NLRVRTX0xFQVZFLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vbXMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIG1lc3NhZ2U6ICVzXCIsIHRoaXMudWlkLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRlbFNvY2tldHMob3B0cywgcm9vbXMpO1xuICAgIH1cbiAgICBhc3luYyBkaXNjb25uZWN0U29ja2V0cyhvcHRzLCBjbG9zZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9ubHlMb2NhbCA9IChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRElTQ09OTkVDVF9TT0NLRVRTLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIG1lc3NhZ2U6ICVzXCIsIHRoaXMudWlkLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRpc2Nvbm5lY3RTb2NrZXRzKG9wdHMsIGNsb3NlKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hTb2NrZXRzKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBbbG9jYWxTb2NrZXRzLCBzZXJ2ZXJDb3VudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzdXBlci5mZXRjaFNvY2tldHMob3B0cyksXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvdW50KCksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPSBzZXJ2ZXJDb3VudCAtIDE7XG4gICAgICAgIGlmICgoKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsKSB8fCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU29ja2V0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYHRpbWVvdXQgcmVhY2hlZDogb25seSAke3N0b3JlZFJlcXVlc3QuY3VycmVudH0gcmVzcG9uc2VzIHJlY2VpdmVkIG91dCBvZiAke3N0b3JlZFJlcXVlc3QuZXhwZWN0ZWR9YCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG9wdHMuZmxhZ3MudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVQpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTLFxuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiAwLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFJlc3BvbnNlQ291bnQsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VzOiBsb2NhbFNvY2tldHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdG9yZWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZXJ2ZXJTaWRlRW1pdChwYWNrZXQpIHtcbiAgICAgICAgY29uc3Qgd2l0aEFjayA9IHR5cGVvZiBwYWNrZXRbcGFja2V0Lmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGlmICghd2l0aEFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNrID0gcGFja2V0LnBvcCgpO1xuICAgICAgICBjb25zdCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPSAoYXdhaXQgdGhpcy5zZXJ2ZXJDb3VudCgpKSAtIDE7XG4gICAgICAgIGRlYnVnKCdbJXNdIHdhaXRpbmcgZm9yICVkIHJlc3BvbnNlcyB0byBcInNlcnZlclNpZGVFbWl0XCIgcmVxdWVzdCcsIHRoaXMudWlkLCBleHBlY3RlZFJlc3BvbnNlQ291bnQpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRSZXNwb25zZUNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJhbmRvbUlkKCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgaWYgKHN0b3JlZFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBhY2sobmV3IEVycm9yKGB0aW1lb3V0IHJlYWNoZWQ6IG9ubHkgJHtzdG9yZWRSZXF1ZXN0LmN1cnJlbnR9IHJlc3BvbnNlcyByZWNlaXZlZCBvdXQgb2YgJHtzdG9yZWRSZXF1ZXN0LmV4cGVjdGVkfWApLCBzdG9yZWRSZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgREVGQVVMVF9USU1FT1VUKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICByZXNvbHZlOiBhY2ssXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgY3VycmVudDogMCxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFJlc3BvbnNlQ291bnQsXG4gICAgICAgICAgICByZXNwb25zZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHN0b3JlZFJlcXVlc3QpO1xuICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1Ymxpc2gobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnB1Ymxpc2hBbmRSZXR1cm5PZmZzZXQobWVzc2FnZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJbJXNdIGVycm9yIHdoaWxlIHB1Ymxpc2hpbmcgbWVzc2FnZTogJXNcIiwgdGhpcy51aWQsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZS51aWQgPSB0aGlzLnVpZDtcbiAgICAgICAgbWVzc2FnZS5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5kb1B1Ymxpc2gobWVzc2FnZSk7XG4gICAgfVxuICAgIHB1Ymxpc2hSZXNwb25zZShyZXF1ZXN0ZXJVaWQsIHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc3BvbnNlLnVpZCA9IHRoaXMudWlkO1xuICAgICAgICByZXNwb25zZS5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICB0aGlzLmRvUHVibGlzaFJlc3BvbnNlKHJlcXVlc3RlclVpZCwgcmVzcG9uc2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIHJlc3BvbnNlOiAlc1wiLCB0aGlzLnVpZCwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5DbHVzdGVyQWRhcHRlciA9IENsdXN0ZXJBZGFwdGVyO1xuY2xhc3MgQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0IGV4dGVuZHMgQ2x1c3RlckFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG5zcCwgb3B0cykge1xuICAgICAgICBzdXBlcihuc3ApO1xuICAgICAgICB0aGlzLm5vZGVzTWFwID0gbmV3IE1hcCgpOyAvLyB1aWQgPT4gdGltZXN0YW1wIG9mIGxhc3QgbWVzc2FnZVxuICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9vcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBoZWFydGJlYXRJbnRlcnZhbDogNTAwMCxcbiAgICAgICAgICAgIGhlYXJ0YmVhdFRpbWVvdXQ6IDEwMDAwLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc01hcC5mb3JFYWNoKChsYXN0U2VlbiwgdWlkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVNlZW1zRG93biA9IG5vdyAtIGxhc3RTZWVuID4gdGhpcy5fb3B0cy5oZWFydGJlYXRUaW1lb3V0O1xuICAgICAgICAgICAgICAgIGlmIChub2RlU2VlbXNEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBub2RlICVzIHNlZW1zIGRvd25cIiwgdGhpcy51aWQsIHVpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZSh1aWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLklOSVRJQUxfSEVBUlRCRUFULFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NoZWR1bGVIZWFydGJlYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5IRUFSVEJFQVQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLl9vcHRzLmhlYXJ0YmVhdEludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkFEQVBURVJfQ0xPU0UsXG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcik7XG4gICAgICAgIGlmICh0aGlzLmNsZWFudXBUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25NZXNzYWdlKG1lc3NhZ2UsIG9mZnNldCkge1xuICAgICAgICBpZiAobWVzc2FnZS51aWQgPT09IHRoaXMudWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVidWcoXCJbJXNdIGlnbm9yZSBtZXNzYWdlIGZyb20gc2VsZlwiLCB0aGlzLnVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudWlkICYmIG1lc3NhZ2UudWlkICE9PSBFTUlUVEVSX1VJRCkge1xuICAgICAgICAgICAgLy8gd2UgdHJhY2sgdGhlIFVJRCBvZiBlYWNoIHNlbmRlciwgaW4gb3JkZXIgdG8ga25vdyBob3cgbWFueSBzZXJ2ZXJzIHRoZXJlIGFyZSBpbiB0aGUgY2x1c3RlclxuICAgICAgICAgICAgdGhpcy5ub2Rlc01hcC5zZXQobWVzc2FnZS51aWQsIERhdGUubm93KCkpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwiWyVzXSBuZXcgZXZlbnQgb2YgdHlwZSAlZCBmcm9tICVzXCIsIHRoaXMudWlkLCBtZXNzYWdlLnR5cGUsIG1lc3NhZ2UudWlkKTtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuSU5JVElBTF9IRUFSVEJFQVQ6XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuSEVBUlRCRUFULFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5IRUFSVEJFQVQ6XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5BREFQVEVSX0NMT1NFOlxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShtZXNzYWdlLnVpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHN1cGVyLm9uTWVzc2FnZShtZXNzYWdlLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlcnZlckNvdW50KCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDEgKyB0aGlzLm5vZGVzTWFwLnNpemUpO1xuICAgIH1cbiAgICBwdWJsaXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZUhlYXJ0YmVhdCgpO1xuICAgICAgICByZXR1cm4gc3VwZXIucHVibGlzaChtZXNzYWdlKTtcbiAgICB9XG4gICAgYXN5bmMgc2VydmVyU2lkZUVtaXQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IHdpdGhBY2sgPSB0eXBlb2YgcGFja2V0W3BhY2tldC5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBpZiAoIXdpdGhBY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjayA9IHBhY2tldC5wb3AoKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRSZXNwb25zZUNvdW50ID0gdGhpcy5ub2Rlc01hcC5zaXplO1xuICAgICAgICBkZWJ1ZygnWyVzXSB3YWl0aW5nIGZvciAlZCByZXNwb25zZXMgdG8gXCJzZXJ2ZXJTaWRlRW1pdFwiIHJlcXVlc3QnLCB0aGlzLnVpZCwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkUmVzcG9uc2VDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNrKG51bGwsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0gdGhpcy5jdXN0b21SZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgIGlmIChzdG9yZWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgYWNrKG5ldyBFcnJvcihgdGltZW91dCByZWFjaGVkOiBtaXNzaW5nICR7c3RvcmVkUmVxdWVzdC5taXNzaW5nVWlkcy5zaXplfSByZXNwb25zZXNgKSwgc3RvcmVkUmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIERFRkFVTFRfVElNRU9VVCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgcmVzb2x2ZTogYWNrLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIG1pc3NpbmdVaWRzOiBuZXcgU2V0KFsuLi50aGlzLm5vZGVzTWFwLmtleXMoKV0pLFxuICAgICAgICAgICAgcmVzcG9uc2VzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdG9yZWRSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFNvY2tldHMob3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IFtsb2NhbFNvY2tldHMsIHNlcnZlckNvdW50XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHN1cGVyLmZldGNoU29ja2V0cyh7XG4gICAgICAgICAgICAgICAgcm9vbXM6IG9wdHMucm9vbXMsXG4gICAgICAgICAgICAgICAgZXhjZXB0OiBvcHRzLmV4Y2VwdCxcbiAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvdW50KCksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPSBzZXJ2ZXJDb3VudCAtIDE7XG4gICAgICAgIGlmICgoKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsKSB8fCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU29ja2V0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB0aGlzLmN1c3RvbVJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYHRpbWVvdXQgcmVhY2hlZDogbWlzc2luZyAke3N0b3JlZFJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZX0gcmVzcG9uc2VzYCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG9wdHMuZmxhZ3MudGltZW91dCB8fCBERUZBVUxUX1RJTUVPVVQpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTLFxuICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgICAgICBtaXNzaW5nVWlkczogbmV3IFNldChbLi4udGhpcy5ub2Rlc01hcC5rZXlzKCldKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZXM6IGxvY2FsU29ja2V0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHN0b3JlZFJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmVzcG9uc2UuZGF0YS5yZXF1ZXN0SWQ7XG4gICAgICAgIGRlYnVnKFwiWyVzXSByZWNlaXZlZCByZXNwb25zZSAlcyB0byByZXF1ZXN0ICVzXCIsIHRoaXMudWlkLCByZXNwb25zZS50eXBlLCByZXF1ZXN0SWQpO1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUU19SRVNQT05TRToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmN1c3RvbVJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuc29ja2V0cy5mb3JFYWNoKChzb2NrZXQpID0+IHJlcXVlc3QucmVzcG9uc2VzLnB1c2goc29ja2V0KSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5taXNzaW5nVWlkcy5kZWxldGUocmVzcG9uc2UudWlkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5taXNzaW5nVWlkcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUocmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmN1c3RvbVJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VzLnB1c2gocmVzcG9uc2UuZGF0YS5wYWNrZXQpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QubWlzc2luZ1VpZHMuZGVsZXRlKHJlc3BvbnNlLnVpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKG51bGwsIHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHN1cGVyLm9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZU5vZGUodWlkKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZm9yRWFjaCgocmVxdWVzdCwgcmVxdWVzdElkKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0Lm1pc3NpbmdVaWRzLmRlbGV0ZSh1aWQpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnR5cGUgPT09IE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC50eXBlID09PSBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShudWxsLCByZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vZGVzTWFwLmRlbGV0ZSh1aWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0ID0gQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0O1xuIl0sIm5hbWVzIjpbIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXQiLCJDbHVzdGVyQWRhcHRlciIsIk1lc3NhZ2VUeXBlIiwiaW5fbWVtb3J5X2FkYXB0ZXJfMSIsInJlcXVpcmUiLCJkZWJ1Z18xIiwiY3J5cHRvXzEiLCJkZWJ1ZyIsIkVNSVRURVJfVUlEIiwiREVGQVVMVF9USU1FT1VUIiwicmFuZG9tSWQiLCJyYW5kb21CeXRlcyIsInRvU3RyaW5nIiwiZW5jb2RlT3B0aW9ucyIsIm9wdHMiLCJyb29tcyIsImV4Y2VwdCIsImZsYWdzIiwiZGVjb2RlT3B0aW9ucyIsIlNldCIsIkFkYXB0ZXIiLCJjb25zdHJ1Y3RvciIsIm5zcCIsInJlcXVlc3RzIiwiTWFwIiwiYWNrUmVxdWVzdHMiLCJ1aWQiLCJvbk1lc3NhZ2UiLCJtZXNzYWdlIiwib2Zmc2V0IiwidHlwZSIsIkJST0FEQ0FTVCIsIndpdGhBY2siLCJkYXRhIiwicmVxdWVzdElkIiwidW5kZWZpbmVkIiwiYnJvYWRjYXN0V2l0aEFjayIsInBhY2tldCIsImNsaWVudENvdW50IiwicHVibGlzaFJlc3BvbnNlIiwiQlJPQURDQVNUX0NMSUVOVF9DT1VOVCIsImFyZyIsIkJST0FEQ0FTVF9BQ0siLCJhZGRPZmZzZXRJZk5lY2Vzc2FyeSIsImJyb2FkY2FzdCIsIlNPQ0tFVFNfSk9JTiIsImFkZFNvY2tldHMiLCJTT0NLRVRTX0xFQVZFIiwiZGVsU29ja2V0cyIsIkRJU0NPTk5FQ1RfU09DS0VUUyIsImRpc2Nvbm5lY3RTb2NrZXRzIiwiY2xvc2UiLCJGRVRDSF9TT0NLRVRTIiwiZmV0Y2hTb2NrZXRzIiwidGhlbiIsImxvY2FsU29ja2V0cyIsIkZFVENIX1NPQ0tFVFNfUkVTUE9OU0UiLCJzb2NrZXRzIiwibWFwIiwic29ja2V0IiwiX2EiLCJoYW5kc2hha2UiLCJzZXNzaW9uU3RvcmUiLCJpZCIsIlNFUlZFUl9TSURFX0VNSVQiLCJfb25TZXJ2ZXJTaWRlRW1pdCIsImNhbGxlZCIsImNhbGxiYWNrIiwiU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRSIsIm9uUmVzcG9uc2UiLCJyZXNwb25zZSIsIl9iIiwiZ2V0IiwiY2xpZW50Q291bnRDYWxsYmFjayIsImFjayIsInJlcXVlc3QiLCJjdXJyZW50IiwiZm9yRWFjaCIsInJlc3BvbnNlcyIsInB1c2giLCJleHBlY3RlZCIsImNsZWFyVGltZW91dCIsInRpbWVvdXQiLCJyZXNvbHZlIiwiZGVsZXRlIiwib25seUxvY2FsIiwibG9jYWwiLCJwdWJsaXNoQW5kUmV0dXJuT2Zmc2V0Iiwic2VydmVyIiwiY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkiLCJpc0V2ZW50UGFja2V0Iiwid2l0aG91dEFja25vd2xlZGdlbWVudCIsIm5vdFZvbGF0aWxlIiwidm9sYXRpbGUiLCJzZXQiLCJwdWJsaXNoIiwic2V0VGltZW91dCIsInNlcnZlckNvdW50IiwiUHJvbWlzZSIsImFsbCIsImV4cGVjdGVkUmVzcG9uc2VDb3VudCIsInJlamVjdCIsInN0b3JlZFJlcXVlc3QiLCJFcnJvciIsInNlcnZlclNpZGVFbWl0IiwicG9wIiwiY2F0Y2giLCJlcnIiLCJuYW1lIiwiZG9QdWJsaXNoIiwicmVxdWVzdGVyVWlkIiwiZG9QdWJsaXNoUmVzcG9uc2UiLCJub2Rlc01hcCIsImN1c3RvbVJlcXVlc3RzIiwiX29wdHMiLCJhc3NpZ24iLCJoZWFydGJlYXRJbnRlcnZhbCIsImhlYXJ0YmVhdFRpbWVvdXQiLCJjbGVhbnVwVGltZXIiLCJzZXRJbnRlcnZhbCIsIm5vdyIsIkRhdGUiLCJsYXN0U2VlbiIsIm5vZGVTZWVtc0Rvd24iLCJyZW1vdmVOb2RlIiwiaW5pdCIsIklOSVRJQUxfSEVBUlRCRUFUIiwic2NoZWR1bGVIZWFydGJlYXQiLCJoZWFydGJlYXRUaW1lciIsInJlZnJlc2giLCJIRUFSVEJFQVQiLCJBREFQVEVSX0NMT1NFIiwiY2xlYXJJbnRlcnZhbCIsInNpemUiLCJtaXNzaW5nVWlkcyIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js":
/*!**************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/contrib/yeast.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// imported from https://github.com/unshiftio/yeast\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.yeast = exports.decode = exports.encode = void 0;\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */ function encode(num) {\n    let encoded = \"\";\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    }while (num > 0);\n    return encoded;\n}\nexports.encode = encode;\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */ function decode(str) {\n    let decoded = 0;\n    for(i = 0; i < str.length; i++){\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\nexports.decode = decode;\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */ function yeast() {\n    const now = encode(+new Date());\n    if (now !== prev) return seed = 0, prev = now;\n    return now + \".\" + encode(seed++);\n}\nexports.yeast = yeast;\n//\n// Map each character to its index.\n//\nfor(; i < length; i++)map[alphabet[i]] = i;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jb250cmliL3llYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1EQUFtRDtBQUN0QztBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3ZELE1BQU1LLFdBQVcsbUVBQW1FQyxLQUFLLENBQUMsS0FBS0MsU0FBUyxJQUFJQyxNQUFNLENBQUM7QUFDbkgsSUFBSUMsT0FBTyxHQUFHQyxJQUFJLEdBQUdDO0FBQ3JCOzs7Ozs7Q0FNQyxHQUNELFNBQVNQLE9BQU9RLEdBQUc7SUFDZixJQUFJQyxVQUFVO0lBQ2QsR0FBRztRQUNDQSxVQUFVUixRQUFRLENBQUNPLE1BQU1MLE9BQU8sR0FBR007UUFDbkNELE1BQU1FLEtBQUtDLEtBQUssQ0FBQ0gsTUFBTUw7SUFDM0IsUUFBU0ssTUFBTSxHQUFHO0lBQ2xCLE9BQU9DO0FBQ1g7QUFDQWIsY0FBYyxHQUFHSTtBQUNqQjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxPQUFPYSxHQUFHO0lBQ2YsSUFBSUMsVUFBVTtJQUNkLElBQUtQLElBQUksR0FBR0EsSUFBSU0sSUFBSVQsTUFBTSxFQUFFRyxJQUFLO1FBQzdCTyxVQUFVQSxVQUFVVixTQUFTQyxHQUFHLENBQUNRLElBQUlFLE1BQU0sQ0FBQ1IsR0FBRztJQUNuRDtJQUNBLE9BQU9PO0FBQ1g7QUFDQWpCLGNBQWMsR0FBR0c7QUFDakI7Ozs7O0NBS0MsR0FDRCxTQUFTRDtJQUNMLE1BQU1pQixNQUFNZixPQUFPLENBQUMsSUFBSWdCO0lBQ3hCLElBQUlELFFBQVFSLE1BQ1IsT0FBTyxPQUFRLEdBQUtBLE9BQU9RO0lBQy9CLE9BQU9BLE1BQU0sTUFBTWYsT0FBT0s7QUFDOUI7QUFDQVQsYUFBYSxHQUFHRTtBQUNoQixFQUFFO0FBQ0YsbUNBQW1DO0FBQ25DLEVBQUU7QUFDRixNQUFPUSxJQUFJSCxRQUFRRyxJQUNmRixHQUFHLENBQUNILFFBQVEsQ0FBQ0ssRUFBRSxDQUFDLEdBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmF2b2NoYXQtYXBwLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvY29udHJpYi95ZWFzdC5qcz84ZDJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Vuc2hpZnRpby95ZWFzdFxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnllYXN0ID0gZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fXCIuc3BsaXQoXCJcIiksIGxlbmd0aCA9IDY0LCBtYXAgPSB7fTtcbmxldCBzZWVkID0gMCwgaSA9IDAsIHByZXY7XG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gICAgbGV0IGVuY29kZWQgPSBcIlwiO1xuICAgIGRvIHtcbiAgICAgICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG4gICAgfSB3aGlsZSAobnVtID4gMCk7XG4gICAgcmV0dXJuIGVuY29kZWQ7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgICBsZXQgZGVjb2RlZCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQ7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICAgIGNvbnN0IG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG4gICAgaWYgKG5vdyAhPT0gcHJldilcbiAgICAgICAgcmV0dXJuIChzZWVkID0gMCksIChwcmV2ID0gbm93KTtcbiAgICByZXR1cm4gbm93ICsgXCIuXCIgKyBlbmNvZGUoc2VlZCsrKTtcbn1cbmV4cG9ydHMueWVhc3QgPSB5ZWFzdDtcbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ5ZWFzdCIsImRlY29kZSIsImVuY29kZSIsImFscGhhYmV0Iiwic3BsaXQiLCJsZW5ndGgiLCJtYXAiLCJzZWVkIiwiaSIsInByZXYiLCJudW0iLCJlbmNvZGVkIiwiTWF0aCIsImZsb29yIiwic3RyIiwiZGVjb2RlZCIsImNoYXJBdCIsIm5vdyIsIkRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/in-memory-adapter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SessionAwareAdapter = exports.Adapter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst yeast_1 = __webpack_require__(/*! ./contrib/yeast */ \"(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js\");\nconst WebSocket = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/index.js\");\nconst canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === \"function\";\nclass Adapter extends events_1.EventEmitter {\n    /**\n     * In-memory adapter constructor.\n     *\n     * @param {Namespace} nsp\n     */ constructor(nsp){\n        super();\n        this.nsp = nsp;\n        this.rooms = new Map();\n        this.sids = new Map();\n        this.encoder = nsp.server.encoder;\n    }\n    /**\n     * To be overridden\n     */ init() {}\n    /**\n     * To be overridden\n     */ close() {}\n    /**\n     * Returns the number of Socket.IO servers in the cluster\n     *\n     * @public\n     */ serverCount() {\n        return Promise.resolve(1);\n    }\n    /**\n     * Adds a socket to a list of room.\n     *\n     * @param {SocketId}  id      the socket id\n     * @param {Set<Room>} rooms   a set of rooms\n     * @public\n     */ addAll(id, rooms) {\n        if (!this.sids.has(id)) {\n            this.sids.set(id, new Set());\n        }\n        for (const room of rooms){\n            this.sids.get(id).add(room);\n            if (!this.rooms.has(room)) {\n                this.rooms.set(room, new Set());\n                this.emit(\"create-room\", room);\n            }\n            if (!this.rooms.get(room).has(id)) {\n                this.rooms.get(room).add(id);\n                this.emit(\"join-room\", room, id);\n            }\n        }\n    }\n    /**\n     * Removes a socket from a room.\n     *\n     * @param {SocketId} id     the socket id\n     * @param {Room}     room   the room name\n     */ del(id, room) {\n        if (this.sids.has(id)) {\n            this.sids.get(id).delete(room);\n        }\n        this._del(room, id);\n    }\n    _del(room, id) {\n        const _room = this.rooms.get(room);\n        if (_room != null) {\n            const deleted = _room.delete(id);\n            if (deleted) {\n                this.emit(\"leave-room\", room, id);\n            }\n            if (_room.size === 0 && this.rooms.delete(room)) {\n                this.emit(\"delete-room\", room);\n            }\n        }\n    }\n    /**\n     * Removes a socket from all rooms it's joined.\n     *\n     * @param {SocketId} id   the socket id\n     */ delAll(id) {\n        if (!this.sids.has(id)) {\n            return;\n        }\n        for (const room of this.sids.get(id)){\n            this._del(room, id);\n        }\n        this.sids.delete(id);\n    }\n    /**\n     * Broadcasts a packet.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @public\n     */ broadcast(packet, opts) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this._encode(packet, packetOpts);\n        this.apply(opts, (socket)=>{\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n    }\n    /**\n     * Broadcasts a packet and expects multiple acknowledgements.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @param clientCountCallback - the number of clients that received the packet\n     * @param ack                 - the callback that will be called for each client response\n     *\n     * @public\n     */ broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n        packet.id = this.nsp._ids++;\n        const encodedPackets = this._encode(packet, packetOpts);\n        let clientCount = 0;\n        this.apply(opts, (socket)=>{\n            // track the total number of acknowledgements that are expected\n            clientCount++;\n            // call the ack callback for each client response\n            socket.acks.set(packet.id, ack);\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n        clientCountCallback(clientCount);\n    }\n    _encode(packet, packetOpts) {\n        const encodedPackets = this.encoder.encode(packet);\n        if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === \"string\") {\n            // \"4\" being the \"message\" packet type in the Engine.IO protocol\n            const data = Buffer.from(\"4\" + encodedPackets[0]);\n            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n            packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {\n                readOnly: false,\n                mask: false,\n                rsv1: false,\n                opcode: 1,\n                fin: true\n            });\n        }\n        return encodedPackets;\n    }\n    /**\n     * Gets a list of sockets by sid.\n     *\n     * @param {Set<Room>} rooms   the explicit set of rooms to check.\n     */ sockets(rooms) {\n        const sids = new Set();\n        this.apply({\n            rooms\n        }, (socket)=>{\n            sids.add(socket.id);\n        });\n        return Promise.resolve(sids);\n    }\n    /**\n     * Gets the list of rooms a given socket has joined.\n     *\n     * @param {SocketId} id   the socket id\n     */ socketRooms(id) {\n        return this.sids.get(id);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @param opts - the filters to apply\n     */ fetchSockets(opts) {\n        const sockets = [];\n        this.apply(opts, (socket)=>{\n            sockets.push(socket);\n        });\n        return Promise.resolve(sockets);\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to join\n     */ addSockets(opts, rooms) {\n        this.apply(opts, (socket)=>{\n            socket.join(rooms);\n        });\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to leave\n     */ delSockets(opts, rooms) {\n        this.apply(opts, (socket)=>{\n            rooms.forEach((room)=>socket.leave(room));\n        });\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param opts - the filters to apply\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(opts, close) {\n        this.apply(opts, (socket)=>{\n            socket.disconnect(close);\n        });\n    }\n    apply(opts, callback) {\n        const rooms = opts.rooms;\n        const except = this.computeExceptSids(opts.except);\n        if (rooms.size) {\n            const ids = new Set();\n            for (const room of rooms){\n                if (!this.rooms.has(room)) continue;\n                for (const id of this.rooms.get(room)){\n                    if (ids.has(id) || except.has(id)) continue;\n                    const socket = this.nsp.sockets.get(id);\n                    if (socket) {\n                        callback(socket);\n                        ids.add(id);\n                    }\n                }\n            }\n        } else {\n            for (const [id] of this.sids){\n                if (except.has(id)) continue;\n                const socket = this.nsp.sockets.get(id);\n                if (socket) callback(socket);\n            }\n        }\n    }\n    computeExceptSids(exceptRooms) {\n        const exceptSids = new Set();\n        if (exceptRooms && exceptRooms.size > 0) {\n            for (const room of exceptRooms){\n                if (this.rooms.has(room)) {\n                    this.rooms.get(room).forEach((sid)=>exceptSids.add(sid));\n                }\n            }\n        }\n        return exceptSids;\n    }\n    /**\n     * Send a packet to the other Socket.IO servers in the cluster\n     * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n     */ serverSideEmit(packet) {\n        console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n    }\n    /**\n     * Save the client session in order to restore it upon reconnection.\n     */ persistSession(session) {}\n    /**\n     * Restore the session and find the packets that were missed by the client.\n     * @param pid\n     * @param offset\n     */ restoreSession(pid, offset) {\n        return null;\n    }\n}\nexports.Adapter = Adapter;\nclass SessionAwareAdapter extends Adapter {\n    constructor(nsp){\n        super(nsp);\n        this.nsp = nsp;\n        this.sessions = new Map();\n        this.packets = [];\n        this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;\n        const timer = setInterval(()=>{\n            const threshold = Date.now() - this.maxDisconnectionDuration;\n            this.sessions.forEach((session, sessionId)=>{\n                const hasExpired = session.disconnectedAt < threshold;\n                if (hasExpired) {\n                    this.sessions.delete(sessionId);\n                }\n            });\n            for(let i = this.packets.length - 1; i >= 0; i--){\n                const hasExpired = this.packets[i].emittedAt < threshold;\n                if (hasExpired) {\n                    this.packets.splice(0, i + 1);\n                    break;\n                }\n            }\n        }, 60 * 1000);\n        // prevents the timer from keeping the process alive\n        timer.unref();\n    }\n    persistSession(session) {\n        session.disconnectedAt = Date.now();\n        this.sessions.set(session.pid, session);\n    }\n    restoreSession(pid, offset) {\n        const session = this.sessions.get(pid);\n        if (!session) {\n            // the session may have expired\n            return null;\n        }\n        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();\n        if (hasExpired) {\n            // the session has expired\n            this.sessions.delete(pid);\n            return null;\n        }\n        const index = this.packets.findIndex((packet)=>packet.id === offset);\n        if (index === -1) {\n            // the offset may be too old\n            return null;\n        }\n        const missedPackets = [];\n        for(let i = index + 1; i < this.packets.length; i++){\n            const packet = this.packets[i];\n            if (shouldIncludePacket(session.rooms, packet.opts)) {\n                missedPackets.push(packet.data);\n            }\n        }\n        return Promise.resolve(Object.assign(Object.assign({}, session), {\n            missedPackets\n        }));\n    }\n    broadcast(packet, opts) {\n        var _a;\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            const id = (0, yeast_1.yeast)();\n            // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has\n            // processed (and the format is backward-compatible)\n            packet.data.push(id);\n            this.packets.push({\n                id,\n                opts,\n                data: packet.data,\n                emittedAt: Date.now()\n            });\n        }\n        super.broadcast(packet, opts);\n    }\n}\nexports.SessionAwareAdapter = SessionAwareAdapter;\nfunction shouldIncludePacket(sessionRooms, opts) {\n    const included = opts.rooms.size === 0 || sessionRooms.some((room)=>opts.rooms.has(room));\n    const notExcluded = sessionRooms.every((room)=>!opts.except.has(room));\n    return included && notExcluded;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbi1tZW1vcnktYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBO0FBQ0pDLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDckQsTUFBTUksV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMscUZBQWlCO0FBQ3pDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDLDRDQUFJO0FBQzlCLE1BQU1HLHFCQUFxQixPQUFRLEVBQUNYLEtBQUtVLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVRSxNQUFNLE1BQU0sUUFBUVosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHYSxLQUFLLE1BQU07QUFDcEssTUFBTVAsZ0JBQWdCQyxTQUFTTyxZQUFZO0lBQ3ZDOzs7O0tBSUMsR0FDREMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSztRQUNMLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlDO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlEO1FBQ2hCLElBQUksQ0FBQ0UsT0FBTyxHQUFHSixJQUFJSyxNQUFNLENBQUNELE9BQU87SUFDckM7SUFDQTs7S0FFQyxHQUNERSxPQUFPLENBQUU7SUFDVDs7S0FFQyxHQUNEQyxRQUFRLENBQUU7SUFDVjs7OztLQUlDLEdBQ0RDLGNBQWM7UUFDVixPQUFPQyxRQUFRQyxPQUFPLENBQUM7SUFDM0I7SUFDQTs7Ozs7O0tBTUMsR0FDREMsT0FBT0MsRUFBRSxFQUFFWCxLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDRSxJQUFJLENBQUNVLEdBQUcsQ0FBQ0QsS0FBSztZQUNwQixJQUFJLENBQUNULElBQUksQ0FBQ1cs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QUFDRztJQUNsRSxPQUFPa0csWUFBWUU7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbi1tZW1vcnktYWRhcHRlci5qcz8wOGM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXNzaW9uQXdhcmVBZGFwdGVyID0gZXhwb3J0cy5BZGFwdGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgeWVhc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnRyaWIveWVhc3RcIik7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKFwid3NcIik7XG5jb25zdCBjYW5QcmVDb21wdXRlRnJhbWUgPSB0eXBlb2YgKChfYSA9IFdlYlNvY2tldCA9PT0gbnVsbCB8fCBXZWJTb2NrZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IFdlYlNvY2tldC5TZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcmFtZSkgPT09IFwiZnVuY3Rpb25cIjtcbmNsYXNzIEFkYXB0ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEluLW1lbW9yeSBhZGFwdGVyIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOYW1lc3BhY2V9IG5zcFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5zcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5zcCA9IG5zcDtcbiAgICAgICAgdGhpcy5yb29tcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zaWRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBuc3Auc2VydmVyLmVuY29kZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIG92ZXJyaWRkZW5cbiAgICAgKi9cbiAgICBpbml0KCkgeyB9XG4gICAgLyoqXG4gICAgICogVG8gYmUgb3ZlcnJpZGRlblxuICAgICAqL1xuICAgIGNsb3NlKCkgeyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIFNvY2tldC5JTyBzZXJ2ZXJzIGluIHRoZSBjbHVzdGVyXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2VydmVyQ291bnQoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzb2NrZXQgdG8gYSBsaXN0IG9mIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSAgaWQgICAgICB0aGUgc29ja2V0IGlkXG4gICAgICogQHBhcmFtIHtTZXQ8Um9vbT59IHJvb21zICAgYSBzZXQgb2Ygcm9vbXNcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYWRkQWxsKGlkLCByb29tcykge1xuICAgICAgICBpZiAoIXRoaXMuc2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNpZHMuc2V0KGlkLCBuZXcgU2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiByb29tcykge1xuICAgICAgICAgICAgdGhpcy5zaWRzLmdldChpZCkuYWRkKHJvb20pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21zLmhhcyhyb29tKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vbXMuc2V0KHJvb20sIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY3JlYXRlLXJvb21cIiwgcm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vbXMuZ2V0KHJvb20pLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb21zLmdldChyb29tKS5hZGQoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImpvaW4tcm9vbVwiLCByb29tLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNvY2tldCBmcm9tIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U29ja2V0SWR9IGlkICAgICB0aGUgc29ja2V0IGlkXG4gICAgICogQHBhcmFtIHtSb29tfSAgICAgcm9vbSAgIHRoZSByb29tIG5hbWVcbiAgICAgKi9cbiAgICBkZWwoaWQsIHJvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuc2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNpZHMuZ2V0KGlkKS5kZWxldGUocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVsKHJvb20sIGlkKTtcbiAgICB9XG4gICAgX2RlbChyb29tLCBpZCkge1xuICAgICAgICBjb25zdCBfcm9vbSA9IHRoaXMucm9vbXMuZ2V0KHJvb20pO1xuICAgICAgICBpZiAoX3Jvb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlZCA9IF9yb29tLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImxlYXZlLXJvb21cIiwgcm9vbSwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9yb29tLnNpemUgPT09IDAgJiYgdGhpcy5yb29tcy5kZWxldGUocm9vbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWxldGUtcm9vbVwiLCByb29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc29ja2V0IGZyb20gYWxsIHJvb21zIGl0J3Mgam9pbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTb2NrZXRJZH0gaWQgICB0aGUgc29ja2V0IGlkXG4gICAgICovXG4gICAgZGVsQWxsKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2YgdGhpcy5zaWRzLmdldChpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbChyb29tLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWRzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBPcHRpb25zOlxuICAgICAqICAtIGBmbGFnc2Age09iamVjdH0gZmxhZ3MgZm9yIHRoaXMgcGFja2V0XG4gICAgICogIC0gYGV4Y2VwdGAge0FycmF5fSBzaWRzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkXG4gICAgICogIC0gYHJvb21zYCB7QXJyYXl9IGxpc3Qgb2Ygcm9vbXMgdG8gYnJvYWRjYXN0IHRvXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0ICAgdGhlIHBhY2tldCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAgICAgdGhlIG9wdGlvbnNcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYnJvYWRjYXN0KHBhY2tldCwgb3B0cykge1xuICAgICAgICBjb25zdCBmbGFncyA9IG9wdHMuZmxhZ3MgfHwge307XG4gICAgICAgIGNvbnN0IHBhY2tldE9wdHMgPSB7XG4gICAgICAgICAgICBwcmVFbmNvZGVkOiB0cnVlLFxuICAgICAgICAgICAgdm9sYXRpbGU6IGZsYWdzLnZvbGF0aWxlLFxuICAgICAgICAgICAgY29tcHJlc3M6IGZsYWdzLmNvbXByZXNzLFxuICAgICAgICB9O1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLl9lbmNvZGUocGFja2V0LCBwYWNrZXRPcHRzKTtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvY2tldC5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Lm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXQuY2xpZW50LndyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIHBhY2tldE9wdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyBhIHBhY2tldCBhbmQgZXhwZWN0cyBtdWx0aXBsZSBhY2tub3dsZWRnZW1lbnRzLlxuICAgICAqXG4gICAgICogT3B0aW9uczpcbiAgICAgKiAgLSBgZmxhZ3NgIHtPYmplY3R9IGZsYWdzIGZvciB0aGlzIHBhY2tldFxuICAgICAqICAtIGBleGNlcHRgIHtBcnJheX0gc2lkcyB0aGF0IHNob3VsZCBiZSBleGNsdWRlZFxuICAgICAqICAtIGByb29tc2Age0FycmF5fSBsaXN0IG9mIHJvb21zIHRvIGJyb2FkY2FzdCB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAgIHRoZSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgICAgIHRoZSBvcHRpb25zXG4gICAgICogQHBhcmFtIGNsaWVudENvdW50Q2FsbGJhY2sgLSB0aGUgbnVtYmVyIG9mIGNsaWVudHMgdGhhdCByZWNlaXZlZCB0aGUgcGFja2V0XG4gICAgICogQHBhcmFtIGFjayAgICAgICAgICAgICAgICAgLSB0aGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBjbGllbnQgcmVzcG9uc2VcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBicm9hZGNhc3RXaXRoQWNrKHBhY2tldCwgb3B0cywgY2xpZW50Q291bnRDYWxsYmFjaywgYWNrKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gb3B0cy5mbGFncyB8fCB7fTtcbiAgICAgICAgY29uc3QgcGFja2V0T3B0cyA9IHtcbiAgICAgICAgICAgIHByZUVuY29kZWQ6IHRydWUsXG4gICAgICAgICAgICB2b2xhdGlsZTogZmxhZ3Mudm9sYXRpbGUsXG4gICAgICAgICAgICBjb21wcmVzczogZmxhZ3MuY29tcHJlc3MsXG4gICAgICAgIH07XG4gICAgICAgIHBhY2tldC5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGlkIGZvciBlYWNoIHBhY2tldCwgc2luY2UgdGhlIF9pZHMgY291bnRlciBpcyBjb21tb24gKG5vIGR1cGxpY2F0ZSlcbiAgICAgICAgcGFja2V0LmlkID0gdGhpcy5uc3AuX2lkcysrO1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuX2VuY29kZShwYWNrZXQsIHBhY2tldE9wdHMpO1xuICAgICAgICBsZXQgY2xpZW50Q291bnQgPSAwO1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIC8vIHRyYWNrIHRoZSB0b3RhbCBudW1iZXIgb2YgYWNrbm93bGVkZ2VtZW50cyB0aGF0IGFyZSBleHBlY3RlZFxuICAgICAgICAgICAgY2xpZW50Q291bnQrKztcbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGFjayBjYWxsYmFjayBmb3IgZWFjaCBjbGllbnQgcmVzcG9uc2VcbiAgICAgICAgICAgIHNvY2tldC5hY2tzLnNldChwYWNrZXQuaWQsIGFjayk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvY2tldC5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Lm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXQuY2xpZW50LndyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIHBhY2tldE9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xpZW50Q291bnRDYWxsYmFjayhjbGllbnRDb3VudCk7XG4gICAgfVxuICAgIF9lbmNvZGUocGFja2V0LCBwYWNrZXRPcHRzKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQpO1xuICAgICAgICBpZiAoY2FuUHJlQ29tcHV0ZUZyYW1lICYmXG4gICAgICAgICAgICBlbmNvZGVkUGFja2V0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlbmNvZGVkUGFja2V0c1swXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gXCI0XCIgYmVpbmcgdGhlIFwibWVzc2FnZVwiIHBhY2tldCB0eXBlIGluIHRoZSBFbmdpbmUuSU8gcHJvdG9jb2xcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShcIjRcIiArIGVuY29kZWRQYWNrZXRzWzBdKTtcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvNjE3I2lzc3VlY29tbWVudC0yODMwMDI0NjlcbiAgICAgICAgICAgIHBhY2tldE9wdHMud3NQcmVFbmNvZGVkRnJhbWUgPSBXZWJTb2NrZXQuU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgICAgICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWFzazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3Bjb2RlOiAxLFxuICAgICAgICAgICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVkUGFja2V0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2Ygc29ja2V0cyBieSBzaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NldDxSb29tPn0gcm9vbXMgICB0aGUgZXhwbGljaXQgc2V0IG9mIHJvb21zIHRvIGNoZWNrLlxuICAgICAqL1xuICAgIHNvY2tldHMocm9vbXMpIHtcbiAgICAgICAgY29uc3Qgc2lkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5hcHBseSh7IHJvb21zIH0sIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHNpZHMuYWRkKHNvY2tldC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNpZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIHJvb21zIGEgZ2l2ZW4gc29ja2V0IGhhcyBqb2luZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSBpZCAgIHRoZSBzb2NrZXQgaWRcbiAgICAgKi9cbiAgICBzb2NrZXRSb29tcyhpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWRzLmdldChpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMob3B0cykge1xuICAgICAgICBjb25zdCBzb2NrZXRzID0gW107XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0cy5wdXNoKHNvY2tldCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNvY2tldHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gcm9vbXMgLSB0aGUgcm9vbXMgdG8gam9pblxuICAgICAqL1xuICAgIGFkZFNvY2tldHMob3B0cywgcm9vbXMpIHtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuam9pbihyb29tcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgc3BlY2lmaWVkIHJvb21zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICogQHBhcmFtIHJvb21zIC0gdGhlIHJvb21zIHRvIGxlYXZlXG4gICAgICovXG4gICAgZGVsU29ja2V0cyhvcHRzLCByb29tcykge1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHJvb21zLmZvckVhY2goKHJvb20pID0+IHNvY2tldC5sZWF2ZShyb29tKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgZGlzY29ubmVjdFNvY2tldHMob3B0cywgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuZGlzY29ubmVjdChjbG9zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBseShvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCByb29tcyA9IG9wdHMucm9vbXM7XG4gICAgICAgIGNvbnN0IGV4Y2VwdCA9IHRoaXMuY29tcHV0ZUV4Y2VwdFNpZHMob3B0cy5leGNlcHQpO1xuICAgICAgICBpZiAocm9vbXMuc2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgaWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCByb29tIG9mIHJvb21zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21zLmhhcyhyb29tKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiB0aGlzLnJvb21zLmdldChyb29tKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWRzLmhhcyhpZCkgfHwgZXhjZXB0LmhhcyhpZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRzLmFkZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZF0gb2YgdGhpcy5zaWRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2VwdC5oYXMoaWQpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldClcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlRXhjZXB0U2lkcyhleGNlcHRSb29tcykge1xuICAgICAgICBjb25zdCBleGNlcHRTaWRzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoZXhjZXB0Um9vbXMgJiYgZXhjZXB0Um9vbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiBleGNlcHRSb29tcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb21zLmhhcyhyb29tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb21zLmdldChyb29tKS5mb3JFYWNoKChzaWQpID0+IGV4Y2VwdFNpZHMuYWRkKHNpZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhjZXB0U2lkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHBhY2tldCB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgaW4gdGhlIGNsdXN0ZXJcbiAgICAgKiBAcGFyYW0gcGFja2V0IC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0KHBhY2tldCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJ0aGlzIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc2VydmVyU2lkZUVtaXQoKSBmdW5jdGlvbmFsaXR5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBjbGllbnQgc2Vzc2lvbiBpbiBvcmRlciB0byByZXN0b3JlIGl0IHVwb24gcmVjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIHBlcnNpc3RTZXNzaW9uKHNlc3Npb24pIHsgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIHNlc3Npb24gYW5kIGZpbmQgdGhlIHBhY2tldHMgdGhhdCB3ZXJlIG1pc3NlZCBieSB0aGUgY2xpZW50LlxuICAgICAqIEBwYXJhbSBwaWRcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICovXG4gICAgcmVzdG9yZVNlc3Npb24ocGlkLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5BZGFwdGVyID0gQWRhcHRlcjtcbmNsYXNzIFNlc3Npb25Bd2FyZUFkYXB0ZXIgZXh0ZW5kcyBBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihuc3ApIHtcbiAgICAgICAgc3VwZXIobnNwKTtcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIHRoaXMuc2Vzc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGFja2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbiA9XG4gICAgICAgICAgICBuc3Auc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkubWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uO1xuICAgICAgICBjb25zdCB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IERhdGUubm93KCkgLSB0aGlzLm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuZm9yRWFjaCgoc2Vzc2lvbiwgc2Vzc2lvbklkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRXhwaXJlZCA9IHNlc3Npb24uZGlzY29ubmVjdGVkQXQgPCB0aHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBhY2tldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gdGhpcy5wYWNrZXRzW2ldLmVtaXR0ZWRBdCA8IHRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2tldHMuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCA2MCAqIDEwMDApO1xuICAgICAgICAvLyBwcmV2ZW50cyB0aGUgdGltZXIgZnJvbSBrZWVwaW5nIHRoZSBwcm9jZXNzIGFsaXZlXG4gICAgICAgIHRpbWVyLnVucmVmKCk7XG4gICAgfVxuICAgIHBlcnNpc3RTZXNzaW9uKHNlc3Npb24pIHtcbiAgICAgICAgc2Vzc2lvbi5kaXNjb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbnMuc2V0KHNlc3Npb24ucGlkLCBzZXNzaW9uKTtcbiAgICB9XG4gICAgcmVzdG9yZVNlc3Npb24ocGlkLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHBpZCk7XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgLy8gdGhlIHNlc3Npb24gbWF5IGhhdmUgZXhwaXJlZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzRXhwaXJlZCA9IHNlc3Npb24uZGlzY29ubmVjdGVkQXQgKyB0aGlzLm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbiA8IERhdGUubm93KCk7XG4gICAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAvLyB0aGUgc2Vzc2lvbiBoYXMgZXhwaXJlZFxuICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5kZWxldGUocGlkKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWNrZXRzLmZpbmRJbmRleCgocGFja2V0KSA9PiBwYWNrZXQuaWQgPT09IG9mZnNldCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvZmZzZXQgbWF5IGJlIHRvbyBvbGRcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc3NlZFBhY2tldHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgMTsgaSA8IHRoaXMucGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gdGhpcy5wYWNrZXRzW2ldO1xuICAgICAgICAgICAgaWYgKHNob3VsZEluY2x1ZGVQYWNrZXQoc2Vzc2lvbi5yb29tcywgcGFja2V0Lm9wdHMpKSB7XG4gICAgICAgICAgICAgICAgbWlzc2VkUGFja2V0cy5wdXNoKHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2Vzc2lvbiksIHsgbWlzc2VkUGFja2V0cyB9KSk7XG4gICAgfVxuICAgIGJyb2FkY2FzdChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpc0V2ZW50UGFja2V0ID0gcGFja2V0LnR5cGUgPT09IDI7XG4gICAgICAgIC8vIHBhY2tldHMgd2l0aCBhY2tub3dsZWRnZW1lbnQgYXJlIG5vdCBzdG9yZWQgYmVjYXVzZSB0aGUgYWNrbm93bGVkZ2VtZW50IGZ1bmN0aW9uIGNhbm5vdCBiZSBzZXJpYWxpemVkIGFuZFxuICAgICAgICAvLyByZXN0b3JlZCBvbiBhbm90aGVyIHNlcnZlciB1cG9uIHJlY29ubmVjdGlvblxuICAgICAgICBjb25zdCB3aXRob3V0QWNrbm93bGVkZ2VtZW50ID0gcGFja2V0LmlkID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG5vdFZvbGF0aWxlID0gKChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52b2xhdGlsZSkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlzRXZlbnRQYWNrZXQgJiYgd2l0aG91dEFja25vd2xlZGdlbWVudCAmJiBub3RWb2xhdGlsZSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSAoMCwgeWVhc3RfMS55ZWFzdCkoKTtcbiAgICAgICAgICAgIC8vIHRoZSBvZmZzZXQgaXMgc3RvcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGRhdGEgYXJyYXksIHNvIHRoZSBjbGllbnQga25vd3MgdGhlIElEIG9mIHRoZSBsYXN0IHBhY2tldCBpdCBoYXNcbiAgICAgICAgICAgIC8vIHByb2Nlc3NlZCAoYW5kIHRoZSBmb3JtYXQgaXMgYmFja3dhcmQtY29tcGF0aWJsZSlcbiAgICAgICAgICAgIHBhY2tldC5kYXRhLnB1c2goaWQpO1xuICAgICAgICAgICAgdGhpcy5wYWNrZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFja2V0LmRhdGEsXG4gICAgICAgICAgICAgICAgZW1pdHRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuYnJvYWRjYXN0KHBhY2tldCwgb3B0cyk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXNzaW9uQXdhcmVBZGFwdGVyID0gU2Vzc2lvbkF3YXJlQWRhcHRlcjtcbmZ1bmN0aW9uIHNob3VsZEluY2x1ZGVQYWNrZXQoc2Vzc2lvblJvb21zLCBvcHRzKSB7XG4gICAgY29uc3QgaW5jbHVkZWQgPSBvcHRzLnJvb21zLnNpemUgPT09IDAgfHwgc2Vzc2lvblJvb21zLnNvbWUoKHJvb20pID0+IG9wdHMucm9vbXMuaGFzKHJvb20pKTtcbiAgICBjb25zdCBub3RFeGNsdWRlZCA9IHNlc3Npb25Sb29tcy5ldmVyeSgocm9vbSkgPT4gIW9wdHMuZXhjZXB0Lmhhcyhyb29tKSk7XG4gICAgcmV0dXJuIGluY2x1ZGVkICYmIG5vdEV4Y2x1ZGVkO1xufVxuIl0sIm5hbWVzIjpbIl9hIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTZXNzaW9uQXdhcmVBZGFwdGVyIiwiQWRhcHRlciIsImV2ZW50c18xIiwicmVxdWlyZSIsInllYXN0XzEiLCJXZWJTb2NrZXQiLCJjYW5QcmVDb21wdXRlRnJhbWUiLCJTZW5kZXIiLCJmcmFtZSIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwibnNwIiwicm9vbXMiLCJNYXAiLCJzaWRzIiwiZW5jb2RlciIsInNlcnZlciIsImluaXQiLCJjbG9zZSIsInNlcnZlckNvdW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJhZGRBbGwiLCJpZCIsImhhcyIsInNldCIsIlNldCIsInJvb20iLCJnZXQiLCJhZGQiLCJlbWl0IiwiZGVsIiwiZGVsZXRlIiwiX2RlbCIsIl9yb29tIiwiZGVsZXRlZCIsInNpemUiLCJkZWxBbGwiLCJicm9hZGNhc3QiLCJwYWNrZXQiLCJvcHRzIiwiZmxhZ3MiLCJwYWNrZXRPcHRzIiwicHJlRW5jb2RlZCIsInZvbGF0aWxlIiwiY29tcHJlc3MiLCJuYW1lIiwiZW5jb2RlZFBhY2tldHMiLCJfZW5jb2RlIiwiYXBwbHkiLCJzb2NrZXQiLCJub3RpZnlPdXRnb2luZ0xpc3RlbmVycyIsImNsaWVudCIsIndyaXRlVG9FbmdpbmUiLCJicm9hZGNhc3RXaXRoQWNrIiwiY2xpZW50Q291bnRDYWxsYmFjayIsImFjayIsIl9pZHMiLCJjbGllbnRDb3VudCIsImFja3MiLCJlbmNvZGUiLCJsZW5ndGgiLCJkYXRhIiwiQnVmZmVyIiwiZnJvbSIsIndzUHJlRW5jb2RlZEZyYW1lIiwicmVhZE9ubHkiLCJtYXNrIiwicnN2MSIsIm9wY29kZSIsImZpbiIsInNvY2tldHMiLCJzb2NrZXRSb29tcyIsImZldGNoU29ja2V0cyIsInB1c2giLCJhZGRTb2NrZXRzIiwiam9pbiIsImRlbFNvY2tldHMiLCJmb3JFYWNoIiwibGVhdmUiLCJkaXNjb25uZWN0U29ja2V0cyIsImRpc2Nvbm5lY3QiLCJjYWxsYmFjayIsImV4Y2VwdCIsImNvbXB1dGVFeGNlcHRTaWRzIiwiaWRzIiwiZXhjZXB0Um9vbXMiLCJleGNlcHRTaWRzIiwic2lkIiwic2VydmVyU2lkZUVtaXQiLCJjb25zb2xlIiwid2FybiIsInBlcnNpc3RTZXNzaW9uIiwic2Vzc2lvbiIsInJlc3RvcmVTZXNzaW9uIiwicGlkIiwib2Zmc2V0Iiwic2Vzc2lvbnMiLCJwYWNrZXRzIiwibWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uIiwiY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkiLCJ0aW1lciIsInNldEludGVydmFsIiwidGhyZXNob2xkIiwiRGF0ZSIsIm5vdyIsInNlc3Npb25JZCIsImhhc0V4cGlyZWQiLCJkaXNjb25uZWN0ZWRBdCIsImkiLCJlbWl0dGVkQXQiLCJzcGxpY2UiLCJ1bnJlZiIsImluZGV4IiwiZmluZEluZGV4IiwibWlzc2VkUGFja2V0cyIsInNob3VsZEluY2x1ZGVQYWNrZXQiLCJhc3NpZ24iLCJpc0V2ZW50UGFja2V0IiwidHlwZSIsIndpdGhvdXRBY2tub3dsZWRnZW1lbnQiLCJ1bmRlZmluZWQiLCJub3RWb2xhdGlsZSIsInllYXN0Iiwic2Vzc2lvblJvb21zIiwiaW5jbHVkZWQiLCJzb21lIiwibm90RXhjbHVkZWQiLCJldmVyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MessageType = exports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.SessionAwareAdapter = exports.Adapter = void 0;\nvar in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nObject.defineProperty(exports, \"Adapter\", ({\n    enumerable: true,\n    get: function() {\n        return in_memory_adapter_1.Adapter;\n    }\n}));\nObject.defineProperty(exports, \"SessionAwareAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return in_memory_adapter_1.SessionAwareAdapter;\n    }\n}));\nvar cluster_adapter_1 = __webpack_require__(/*! ./cluster-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js\");\nObject.defineProperty(exports, \"ClusterAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_adapter_1.ClusterAdapter;\n    }\n}));\nObject.defineProperty(exports, \"ClusterAdapterWithHeartbeat\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_adapter_1.ClusterAdapterWithHeartbeat;\n    }\n}));\nObject.defineProperty(exports, \"MessageType\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_adapter_1.MessageType;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLG1DQUFtQyxHQUFHQSxzQkFBc0IsR0FBR0EsMkJBQTJCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzFJLElBQUlPLHNCQUFzQkMsbUJBQU9BLENBQUMsNkZBQXFCO0FBQ3ZEViwyQ0FBMEM7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsb0JBQW9CRCxPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDekhSLHVEQUFzRDtJQUFFVyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxvQkFBb0JGLG1CQUFtQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2pKLElBQUlNLG9CQUFvQkgsbUJBQU9BLENBQUMseUZBQW1CO0FBQ25EVixrREFBaUQ7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Msa0JBQWtCUCxjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDcklOLCtEQUE4RDtJQUFFVyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxrQkFBa0JSLDJCQUEyQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9KTCwrQ0FBOEM7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Msa0JBQWtCVCxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbmRleC5qcz8yZTRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXNzYWdlVHlwZSA9IGV4cG9ydHMuQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0ID0gZXhwb3J0cy5DbHVzdGVyQWRhcHRlciA9IGV4cG9ydHMuU2Vzc2lvbkF3YXJlQWRhcHRlciA9IGV4cG9ydHMuQWRhcHRlciA9IHZvaWQgMDtcbnZhciBpbl9tZW1vcnlfYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vaW4tbWVtb3J5LWFkYXB0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBZGFwdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbl9tZW1vcnlfYWRhcHRlcl8xLkFkYXB0ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXNzaW9uQXdhcmVBZGFwdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbl9tZW1vcnlfYWRhcHRlcl8xLlNlc3Npb25Bd2FyZUFkYXB0ZXI7IH0gfSk7XG52YXIgY2x1c3Rlcl9hZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9jbHVzdGVyLWFkYXB0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbHVzdGVyQWRhcHRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2x1c3Rlcl9hZGFwdGVyXzEuQ2x1c3RlckFkYXB0ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsdXN0ZXJfYWRhcHRlcl8xLkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbHVzdGVyX2FkYXB0ZXJfMS5NZXNzYWdlVHlwZTsgfSB9KTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk1lc3NhZ2VUeXBlIiwiQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0IiwiQ2x1c3RlckFkYXB0ZXIiLCJTZXNzaW9uQXdhcmVBZGFwdGVyIiwiQWRhcHRlciIsImluX21lbW9yeV9hZGFwdGVyXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsImNsdXN0ZXJfYWRhcHRlcl8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/browser.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ exports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNCQUFzQixHQUV0Qjs7Q0FFQyxHQUVEQSxrQkFBa0IsR0FBR0M7QUFDckJELFlBQVksR0FBR0U7QUFDZkYsWUFBWSxHQUFHRztBQUNmSCxpQkFBaUIsR0FBR0k7QUFDcEJKLGVBQWUsR0FBR007QUFDbEJOLGVBQWUsR0FBRyxDQUFDO0lBQ2xCLElBQUlRLFNBQVM7SUFFYixPQUFPO1FBQ04sSUFBSSxDQUFDQSxRQUFRO1lBQ1pBLFNBQVM7WUFDVEMsUUFBUUMsSUFBSSxDQUFDO1FBQ2Q7SUFDRDtBQUNEO0FBRUE7O0NBRUMsR0FFRFYsY0FBYyxHQUFHO0lBQ2hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0E7QUFFRDs7Ozs7O0NBTUMsR0FFRCxzQ0FBc0M7QUFDdEMsU0FBU0k7SUFDUiw0RUFBNEU7SUFDNUUsMEVBQTBFO0lBQzFFLGFBQWE7SUFDYixJQUFJLEtBQWdILEVBQUUsRUFFckg7SUFFRCxvREFBb0Q7SUFDcEQsSUFBSSxPQUFPWSxjQUFjLGVBQWVBLFVBQVVD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dkcsMkRBQTJEO1FBQzNELE9BQU80QztJQUNSLEVBQUUsT0FBT0wsT0FBTztJQUNmLFVBQVU7SUFDViwwQ0FBMEM7SUFDM0M7QUFDRDtBQUVBZCxPQUFPL0IsT0FBTyxHQUFHbUQsbUJBQU9BLENBQUMsMkZBQVluRDtBQUVyQyxNQUFNLEVBQUNvRCxVQUFVLEVBQUMsR0FBR3JCLE9BQU8vQixPQUFPO0FBRW5DOztDQUVDLEdBRURvRCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJO1FBQ0gsT0FBT0MsS0FBS0MsU0FBUyxDQUFDRjtJQUN2QixFQUFFLE9BQU9ULE9BQU87UUFDZixPQUFPLGlDQUFpQ0EsTUFBTVksT0FBTztJQUN0RDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmF2b2NoYXQtYXBwLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz8yZjVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJzdG9yYWdlIiwibG9jYWxzdG9yYWdlIiwiZGVzdHJveSIsIndhcm5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiY29sb3JzIiwid2luZG93IiwicHJvY2VzcyIsInR5cGUiLCJfX253anMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwibSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJXZWJraXRBcHBlYXJhbmNlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwicGFyc2VJbnQiLCJhcmdzIiwibmFtZXNwYWNlIiwibW9kdWxlIiwiaHVtYW5pemUiLCJkaWZmIiwiYyIsImNvbG9yIiwic3BsaWNlIiwiaW5kZXgiLCJsYXN0QyIsInJlcGxhY2UiLCJsb2ciLCJkZWJ1ZyIsIm5hbWVzcGFjZXMiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImVycm9yIiwiciIsImdldEl0ZW0iLCJlbnYiLCJERUJVRyIsImxvY2FsU3RvcmFnZSIsInJlcXVpcmUiLCJmb3JtYXR0ZXJzIiwiaiIsInYiLCJKU09OIiwic3RyaW5naWZ5IiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/common.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ function setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQ0E7OztDQUdDLEdBRUQsU0FBU0EsTUFBTUMsR0FBRztJQUNqQkMsWUFBWUMsS0FBSyxHQUFHRDtJQUNwQkEsWUFBWUUsT0FBTyxHQUFHRjtJQUN0QkEsWUFBWUcsTUFBTSxHQUFHQTtJQUNyQkgsWUFBWUksT0FBTyxHQUFHQTtJQUN0QkosWUFBWUssTUFBTSxHQUFHQTtJQUNyQkwsWUFBWU0sT0FBTyxHQUFHQTtJQUN0Qk4sWUFBWU8sUUFBUSxHQUFHQyxtQkFBT0EsQ0FBQztJQUMvQlIsWUFBWVMsT0FBTyxHQUFHQTtJQUV0QkMsT0FBT0MsSUFBSSxDQUFDWixLQUFLYSxPQUFPLENBQUNDLENBQUFBO1FBQ3hCYixXQUFXLENBQUNhLElBQUksR0FBR2QsR0FBRyxDQUFDYyxJQUFJO0lBQzVCO0lBRUE7O0NBRUEsR0FFQWIsWUFBWWMsS0FBSyxHQUFHLEVBQUU7SUFDdEJkLFlBQVllLEtBQUssR0FBRyxFQUFFO0lBRXRCOzs7O0NBSUEsR0FDQWYsWUFBWWdCLFVBQVUsR0FBRyxDQUFDO0lBRTFCOzs7OztDQUtBLEdBQ0EsU0FBU0MsWUFBWUMsU0FBUztRQUM3QixJQUFJQyxPQUFPO1FBRVgsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVVHLE1BQU0sRUFBRUQsSUFBSztZQUMxQ0QsT0FBTyxDQUFFQSxRQUFRLEtBQUtBLE9BQVFELFVBQVVJLFVBQVUsQ0FBQ0Y7WUFDbkRELFFBQVEsR0FBRywyQkFBMkI7UUFDdkM7UUFFQSxPQUFPbkIsWUFBWXVCLE1BQU0sQ0FBQ0MsS0FBS0MsR0FBRyxDQUFDTixRQUFRbkIsWUFBWXVCLE1BQU0sQ0FBQ0YsTUFBTSxDQUFDO0lBQ3RFO0lBQ0FyQixZQUFZaUIsV0FBVyxHQUFHQTtJQUUxQjs7Ozs7O0NBTUEsR0FDQSxTQUFTakIsWUFBWWtCLFNBQVM7UUFDN0Is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QUFHOEMsTUFBTWxFLFlBQVllLEtBQUssQ0FBQ00sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVllLEtBQUssQ0FBQ0ssRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLElBQUtyRCxJQUFJLEdBQUc4QyxNQUFNbEUsWUFBWWMsS0FBSyxDQUFDTyxNQUFNLEVBQUVELElBQUk4QyxLQUFLOUMsSUFBSztZQUN6RCxJQUFJcEIsWUFBWWMsS0FBSyxDQUFDTSxFQUFFLENBQUNzRCxJQUFJLENBQUNELE9BQU87Z0JBQ3BDLE9BQU87WUFDUjtRQUNEO1FBRUEsT0FBTztJQUNSO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU0YsWUFBWUksTUFBTTtRQUMxQixPQUFPQSxPQUFPQyxRQUFRLEdBQ3BCQyxTQUFTLENBQUMsR0FBR0YsT0FBT0MsUUFBUSxHQUFHdkQsTUFBTSxHQUFHLEdBQ3hDbUIsT0FBTyxDQUFDLFdBQVc7SUFDdEI7SUFFQTs7Ozs7O0NBTUEsR0FDQSxTQUFTckMsT0FBT3lDLEdBQUc7UUFDbEIsSUFBSUEsZUFBZWtDLE9BQU87WUFDekIsT0FBT2xDLElBQUltQyxLQUFLLElBQUluQyxJQUFJb0MsT0FBTztRQUNoQztRQUNBLE9BQU9wQztJQUNSO0lBRUE7OztDQUdBLEdBQ0EsU0FBU25DO1FBQ1J3RSxRQUFRQyxJQUFJLENBQUM7SUFDZDtJQUVBbEYsWUFBWUssTUFBTSxDQUFDTCxZQUFZbUYsSUFBSTtJQUVuQyxPQUFPbkY7QUFDUjtBQUVBb0YsT0FBT0MsT0FBTyxHQUFHdkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanM/YTYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sIm5hbWVzIjpbInNldHVwIiwiZW52IiwiY3JlYXRlRGVidWciLCJkZWJ1ZyIsImRlZmF1bHQiLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiZW5hYmxlZCIsImh1bWFuaXplIiwicmVxdWlyZSIsImRlc3Ryb3kiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIm5hbWVzIiwic2tpcHMiLCJmb3JtYXR0ZXJzIiwic2VsZWN0Q29sb3IiLCJuYW1lc3BhY2UiLCJoYXNoIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjb2xvcnMiLCJNYXRoIiwiYWJzIiwicHJldlRpbWUiLCJlbmFibGVPdmVycmlkZSIsIm5hbWVzcGFjZXNDYWNoZSIsImVuYWJsZWRDYWNoZSIsImFyZ3MiLCJzZWxmIiwiY3VyciIsIk51bWJlciIsIkRhdGUiLCJtcyIsImRpZmYiLCJwcmV2IiwidW5zaGlmdCIsImluZGV4IiwicmVwbGFjZSIsIm1hdGNoIiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwidmFsIiwiY2FsbCIsInNwbGljZSIsImZvcm1hdEFyZ3MiLCJsb2dGbiIsImxvZyIsImFwcGx5IiwidXNlQ29sb3JzIiwiY29sb3IiLCJleHRlbmQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJuYW1lc3BhY2VzIiwic2V0IiwidiIsImluaXQiLCJkZWxpbWl0ZXIiLCJuZXdEZWJ1ZyIsInNhdmUiLCJzcGxpdCIsImxlbiIsInB1c2giLCJSZWdFeHAiLCJzbGljZSIsIm1hcCIsInRvTmFtZXNwYWNlIiwiam9pbiIsIm5hbWUiLCJ0ZXN0IiwicmVnZXhwIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJFcnJvciIsInN0YWNrIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwibG9hZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ if (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0MsR0FFRCxJQUFJLE9BQU9BLFlBQVksZUFBZUEsUUFBUUMsSUFBSSxLQUFLLGNBQWNELEtBQWUsS0FBSyxRQUFRQSxRQUFRRyxNQUFNLEVBQUU7SUFDaEhDLG9JQUF5QjtBQUMxQixPQUFPO0lBQ05BLDhIQUF5QjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3Jhdm9jaGF0LWFwcC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzP2M3ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCBwcm9jZXNzLmJyb3dzZXIgPT09IHRydWUgfHwgcHJvY2Vzcy5fX253anMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsInR5cGUiLCJicm93c2VyIiwiX19ud2pzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/node.js":
/*!***********************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/node.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ const tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"?6268\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUM7QUFFckI7O0NBRUMsR0FFREUsWUFBWSxHQUFHQztBQUNmRCxXQUFXLEdBQUdFO0FBQ2RGLGtCQUFrQixHQUFHRztBQUNyQkgsWUFBWSxHQUFHSTtBQUNmSixZQUFZLEdBQUdLO0FBQ2ZMLGlCQUFpQixHQUFHTTtBQUNwQk4sZUFBZSxHQUFHRCxLQUFLUyxTQUFTLENBQy9CLEtBQU8sR0FDUDtBQUdEOztDQUVDLEdBRURSLGNBQWMsR0FBRztJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztDQUFFO0FBRW5DLElBQUk7SUFDSCwyR0FBMkc7SUFDM0csNkRBQTZEO0lBQzdELE1BQU1VLGdCQUFnQlosbUJBQU9BLENBQUM7SUFFOUIsSUFBSVksaUJBQWlCLENBQUNBLGNBQWNDLE1BQU0sSUFBSUQsYUFBWSxFQUFHRSxLQUFLLElBQUksR0FBRztRQUN4RVosY0FBYyxHQUFHO1lBQ2hCO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZ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TUFBTTNDLFdBQVcsR0FBRyxDQUFDO0lBRXJCLE1BQU1FLE9BQU9ELE9BQU9DLElBQUksQ0FBQ2hCLFFBQVFjLFdBQVc7SUFDNUMsSUFBSyxJQUFJNEMsSUFBSSxHQUFHQSxJQUFJMUMsS0FBSzJDLE1BQU0sRUFBRUQsSUFBSztRQUNyQ0QsTUFBTTNDLFdBQVcsQ0FBQ0UsSUFBSSxDQUFDMEMsRUFBRSxDQUFDLEdBQUcxRCxRQUFRYyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQztJQUMxRDtBQUNEO0FBRUFaLE9BQU85QyxPQUFPLEdBQUdGLG1CQUFPQSxDQUFDLDJGQUFZRTtBQUVyQyxNQUFNLEVBQUM0RCxVQUFVLEVBQUMsR0FBR2QsT0FBTzlDLE9BQU87QUFFbkM7O0NBRUMsR0FFRDRELFdBQVdDLENBQUMsR0FBRyxTQUFVQyxDQUFDO0lBQ3pCLElBQUksQ0FBQ2hELFdBQVcsQ0FBQ0wsTUFBTSxHQUFHLElBQUksQ0FBQ0gsU0FBUztJQUN4QyxPQUFPUCxLQUFLZ0UsT0FBTyxDQUFDRCxHQUFHLElBQUksQ0FBQ2hELFdBQVcsRUFDckM2QixLQUFLLENBQUMsTUFDTnFCLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUMsSUFBSSxJQUNuQnRCLElBQUksQ0FBQztBQUNSO0FBRUE7O0NBRUMsR0FFRGdCLFdBQVdPLENBQUMsR0FBRyxTQUFVTCxDQUFDO0lBQ3pCLElBQUksQ0FBQ2hELFdBQVcsQ0FBQ0wsTUFBTSxHQUFHLElBQUksQ0FBQ0gsU0FBUztJQUN4QyxPQUFPUCxLQUFLZ0UsT0FBTyxDQUFDRCxHQUFHLElBQUksQ0FBQ2hELFdBQVc7QUFDeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzPzQ1NjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuZGVzdHJveSA9IHV0aWwuZGVwcmVjYXRlKFxuXHQoKSA9PiB7fSxcblx0J0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nXG4pO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxudHJ5IHtcblx0Ly8gT3B0aW9uYWwgZGVwZW5kZW5jeSAoYXMgaW4sIGRvZXNuJ3QgbmVlZCB0byBiZSBpbnN0YWxsZWQsIE5PVCBsaWtlIG9wdGlvbmFsRGVwZW5kZW5jaWVzIGluIHBhY2thZ2UuanNvbilcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuXHRjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuXHRpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuXHRcdGV4cG9ydHMuY29sb3JzID0gW1xuXHRcdFx0MjAsXG5cdFx0XHQyMSxcblx0XHRcdDI2LFxuXHRcdFx0MjcsXG5cdFx0XHQzMixcblx0XHRcdDMzLFxuXHRcdFx0MzgsXG5cdFx0XHQzOSxcblx0XHRcdDQwLFxuXHRcdFx0NDEsXG5cdFx0XHQ0Mixcblx0XHRcdDQzLFxuXHRcdFx0NDQsXG5cdFx0XHQ0NSxcblx0XHRcdDU2LFxuXHRcdFx0NTcsXG5cdFx0XHQ2Mixcblx0XHRcdDYzLFxuXHRcdFx0NjgsXG5cdFx0XHQ2OSxcblx0XHRcdDc0LFxuXHRcdFx0NzUsXG5cdFx0XHQ3Nixcblx0XHRcdDc3LFxuXHRcdFx0NzgsXG5cdFx0XHQ3OSxcblx0XHRcdDgwLFxuXHRcdFx0ODEsXG5cdFx0XHQ5Mixcblx0XHRcdDkzLFxuXHRcdFx0OTgsXG5cdFx0XHQ5OSxcblx0XHRcdDExMixcblx0XHRcdDExMyxcblx0XHRcdDEyOCxcblx0XHRcdDEyOSxcblx0XHRcdDEzNCxcblx0XHRcdDEzNSxcblx0XHRcdDE0OCxcblx0XHRcdDE0OSxcblx0XHRcdDE2MCxcblx0XHRcdDE2MSxcblx0XHRcdDE2Mixcblx0XHRcdDE2Myxcblx0XHRcdDE2NCxcblx0XHRcdDE2NSxcblx0XHRcdDE2Nixcblx0XHRcdDE2Nyxcblx0XHRcdDE2OCxcblx0XHRcdDE2OSxcblx0XHRcdDE3MCxcblx0XHRcdDE3MSxcblx0XHRcdDE3Mixcblx0XHRcdDE3Myxcblx0XHRcdDE3OCxcblx0XHRcdDE3OSxcblx0XHRcdDE4NCxcblx0XHRcdDE4NSxcblx0XHRcdDE5Nixcblx0XHRcdDE5Nyxcblx0XHRcdDE5OCxcblx0XHRcdDE5OSxcblx0XHRcdDIwMCxcblx0XHRcdDIwMSxcblx0XHRcdDIwMixcblx0XHRcdDIwMyxcblx0XHRcdDIwNCxcblx0XHRcdDIwNSxcblx0XHRcdDIwNixcblx0XHRcdDIwNyxcblx0XHRcdDIwOCxcblx0XHRcdDIwOSxcblx0XHRcdDIxNCxcblx0XHRcdDIxNSxcblx0XHRcdDIyMCxcblx0XHRcdDIyMVxuXHRcdF07XG5cdH1cbn0gY2F0Y2ggKGVycm9yKSB7XG5cdC8vIFN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IHtcblx0cmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuXHQvLyBDYW1lbC1jYXNlXG5cdGNvbnN0IHByb3AgPSBrZXlcblx0XHQuc3Vic3RyaW5nKDYpXG5cdFx0LnRvTG93ZXJDYXNlKClcblx0XHQucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGspID0+IHtcblx0XHRcdHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cblx0Ly8gQ29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG5cdGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXHRpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gdHJ1ZTtcblx0fSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB7XG5cdFx0dmFsID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBOdW1iZXIodmFsKTtcblx0fVxuXG5cdG9ialtwcm9wXSA9IHZhbDtcblx0cmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHRyZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/XG5cdFx0Qm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycykgOlxuXHRcdHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRjb25zdCB7bmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnN9ID0gdGhpcztcblxuXHRpZiAodXNlQ29sb3JzKSB7XG5cdFx0Y29uc3QgYyA9IHRoaXMuY29sb3I7XG5cdFx0Y29uc3QgY29sb3JDb2RlID0gJ1xcdTAwMUJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG5cdFx0Y29uc3QgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHUwMDFCWzBtYDtcblxuXHRcdGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcblx0XHRhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxQlswbScpO1xuXHR9IGVsc2Uge1xuXHRcdGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuXHRpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXHRyZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5mdW5jdGlvbiBsb2coLi4uYXJncykge1xuXHRyZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhleHBvcnRzLmluc3BlY3RPcHRzLCAuLi5hcmdzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHRpZiAobmFtZXNwYWNlcykge1xuXHRcdHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcblx0fSBlbHNlIHtcblx0XHQvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcblx0XHQvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuXHRcdGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBpbml0KGRlYnVnKSB7XG5cdGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuXHRcdC5zcGxpdCgnXFxuJylcblx0XHQubWFwKHN0ciA9PiBzdHIudHJpbSgpKVxuXHRcdC5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlTyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG4iXSwibmFtZXMiOlsidHR5IiwicmVxdWlyZSIsInV0aWwiLCJleHBvcnRzIiwiaW5pdCIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsImRlc3Ryb3kiLCJkZXByZWNhdGUiLCJjb2xvcnMiLCJzdXBwb3J0c0NvbG9yIiwic3RkZXJyIiwibGV2ZWwiLCJlcnJvciIsImluc3BlY3RPcHRzIiwiT2JqZWN0Iiwia2V5cyIsInByb2Nlc3MiLCJlbnYiLCJmaWx0ZXIiLCJrZXkiLCJ0ZXN0IiwicmVkdWNlIiwib2JqIiwicHJvcCIsInN1YnN0cmluZyIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsIl8iLCJrIiwidG9VcHBlckNhc2UiLCJ2YWwiLCJOdW1iZXIiLCJCb29sZWFuIiwiaXNhdHR5IiwiZmQiLCJhcmdzIiwibmFtZXNwYWNlIiwibmFtZSIsImMiLCJjb2xvciIsImNvbG9yQ29kZSIsInByZWZpeCIsInNwbGl0Iiwiam9pbiIsInB1c2giLCJtb2R1bGUiLCJodW1hbml6ZSIsImRpZmYiLCJnZXREYXRlIiwiaGlkZURhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ3cml0ZSIsImZvcm1hdFdpdGhPcHRpb25zIiwibmFtZXNwYWNlcyIsIkRFQlVHIiwiZGVidWciLCJpIiwibGVuZ3RoIiwiZm9ybWF0dGVycyIsIm8iLCJ2IiwiaW5zcGVjdCIsIm1hcCIsInN0ciIsInRyaW0iLCJPIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/node.js\n");

/***/ })

};
;