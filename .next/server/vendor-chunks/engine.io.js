/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/engine.io";
exports.ids = ["vendor-chunks/engine.io"];
exports.modules = {

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ exports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsR0FFdEI7O0NBRUMsR0FFREEsa0JBQWtCLEdBQUdDO0FBQ3JCRCxZQUFZLEdBQUdFO0FBQ2ZGLFlBQVksR0FBR0c7QUFDZkgsaUJBQWlCLEdBQUdJO0FBQ3BCSixlQUFlLEdBQUdNO0FBQ2xCTixlQUFlLEdBQUcsQ0FBQztJQUNsQixJQUFJUSxTQUFTO0lBRWIsT0FBTztRQUNOLElBQUksQ0FBQ0EsUUFBUTtZQUNaQSxTQUFTO1lBQ1RDLFFBQVFDLElBQUksQ0FBQztRQUNkO0lBQ0Q7QUFDRDtBQUVBOztDQUVDLEdBRURWLGNBQWMsR0FBRztJQUNoQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNBO0FBRUQ7Ozs7OztDQU1DLEdBRUQsc0NBQXNDO0FBQ3RDLFNBQVNJO0lBQ1IsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxhQUFhO0lBQ2IsSUFBSSxLQUFnSCxFQUFFLEVBRXJIO0lBRUQsb0RBQW9EO0lBQ3BELElBQUksT0FBT1ksY0FBYyxlQUFlQSxVQUFVQyxTQUFTLElB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RDtRQUMzRCxPQUFPNEM7SUFDUixFQUFFLE9BQU9MLE9BQU87SUFDZixVQUFVO0lBQ1YsMENBQTBDO0lBQzNDO0FBQ0Q7QUFFQWQsT0FBTy9CLE9BQU8sR0FBR21ELG1CQUFPQSxDQUFDLG1GQUFZbkQ7QUFFckMsTUFBTSxFQUFDb0QsVUFBVSxFQUFDLEdBQUdyQixPQUFPL0IsT0FBTztBQUVuQzs7Q0FFQyxHQUVEb0QsV0FBV0MsQ0FBQyxHQUFHLFNBQVVDLENBQUM7SUFDekIsSUFBSTtRQUNILE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDdkIsRUFBRSxPQUFPVCxPQUFPO1FBQ2YsT0FBTyxpQ0FBaUNBLE1BQU1ZLE9BQU87SUFDdEQ7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3Jhdm9jaGF0LWFwcC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzPzVjYTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGxldCBtO1xuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIChtID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykpICYmIHBhcnNlSW50KG1bMV0sIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJsb2NhbHN0b3JhZ2UiLCJkZXN0cm95Iiwid2FybmVkIiwiY29uc29sZSIsIndhcm4iLCJjb2xvcnMiLCJ3aW5kb3ciLCJwcm9jZXNzIiwidHlwZSIsIl9fbndqcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwibWF0Y2giLCJtIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIldlYmtpdEFwcGVhcmFuY2UiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwidGFibGUiLCJwYXJzZUludCIsImFyZ3MiLCJuYW1lc3BhY2UiLCJtb2R1bGUiLCJodW1hbml6ZSIsImRpZmYiLCJjIiwiY29sb3IiLCJzcGxpY2UiLCJpbmRleCIsImxhc3RDIiwicmVwbGFjZSIsImxvZyIsImRlYnVnIiwibmFtZXNwYWNlcyIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZXJyb3IiLCJyIiwiZ2V0SXRlbSIsImVudiIsIkRFQlVHIiwibG9jYWxTdG9yYWdlIiwicmVxdWlyZSIsImZvcm1hdHRlcnMiLCJqIiwidiIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ function setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUNBOzs7Q0FHQyxHQUVELFNBQVNBLE1BQU1DLEdBQUc7SUFDakJDLFlBQVlDLEtBQUssR0FBR0Q7SUFDcEJBLFlBQVlFLE9BQU8sR0FBR0Y7SUFDdEJBLFlBQVlHLE1BQU0sR0FBR0E7SUFDckJILFlBQVlJLE9BQU8sR0FBR0E7SUFDdEJKLFlBQVlLLE1BQU0sR0FBR0E7SUFDckJMLFlBQVlNLE9BQU8sR0FBR0E7SUFDdEJOLFlBQVlPLFFBQVEsR0FBR0MsbUJBQU9BLENBQUM7SUFDL0JSLFlBQVlTLE9BQU8sR0FBR0E7SUFFdEJDLE9BQU9DLElBQUksQ0FBQ1osS0FBS2EsT0FBTyxDQUFDQyxDQUFBQTtRQUN4QmIsV0FBVyxDQUFDYSxJQUFJLEdBQUdkLEdBQUcsQ0FBQ2MsSUFBSTtJQUM1QjtJQUVBOztDQUVBLEdBRUFiLFlBQVljLEtBQUssR0FBRyxFQUFFO0lBQ3RCZCxZQUFZZSxLQUFLLEdBQUcsRUFBRTtJQUV0Qjs7OztDQUlBLEdBQ0FmLFlBQVlnQixVQUFVLEdBQUcsQ0FBQztJQUUxQjs7Ozs7Q0FLQSxHQUNBLFNBQVNDLFlBQVlDLFNBQVM7UUFDN0IsSUFBSUMsT0FBTztRQUVYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixVQUFVRyxNQUFNLEVBQUVELElBQUs7WUFDMUNELE9BQU8sQ0FBRUEsUUFBUSxLQUFLQSxPQUFRRCxVQUFVSSxVQUFVLENBQUNGO1lBQ25ERCxRQUFRLEdBQUcsMkJBQTJCO1FBQ3ZDO1FBRUEsT0FBT25CLFlBQVl1QixNQUFNLENBQUNDLEtBQUtDLEdBQUcsQ0FBQ04sUUFBUW5CLFlBQVl1QixNQUFNLENBQUNGLE1BQU0sQ0FBQztJQUN0RTtJQUNBckIsWUFBWWlCLFdBQVcsR0FBR0E7SUFFMUI7Ozs7OztDQU1BLEdBQ0EsU0FBU2pCLFlBQVlrQixTQUFTO1FBQzdCLElBQUlRO1FB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QU1sRSxZQUFZZSxLQUFLLENBQUNNLE1BQU0sRUFBRUQsSUFBSThDLEtBQUs5QyxJQUFLO1lBQ3pELElBQUlwQixZQUFZZSxLQUFLLENBQUNLLEVBQUUsQ0FBQ3NELElBQUksQ0FBQ0QsT0FBTztnQkFDcEMsT0FBTztZQUNSO1FBQ0Q7UUFFQSxJQUFLckQsSUFBSSxHQUFHOEMsTUFBTWxFLFlBQVljLEtBQUssQ0FBQ08sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVljLEtBQUssQ0FBQ00sRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLE9BQU87SUFDUjtJQUVBOzs7Ozs7Q0FNQSxHQUNBLFNBQVNGLFlBQVlJLE1BQU07UUFDMUIsT0FBT0EsT0FBT0MsUUFBUSxHQUNwQkMsU0FBUyxDQUFDLEdBQUdGLE9BQU9DLFFBQVEsR0FBR3ZELE1BQU0sR0FBRyxHQUN4Q21CLE9BQU8sQ0FBQyxXQUFXO0lBQ3RCO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU3JDLE9BQU95QyxHQUFHO1FBQ2xCLElBQUlBLGVBQWVrQyxPQUFPO1lBQ3pCLE9BQU9sQyxJQUFJbUMsS0FBSyxJQUFJbkMsSUFBSW9DLE9BQU87UUFDaEM7UUFDQSxPQUFPcEM7SUFDUjtJQUVBOzs7Q0FHQSxHQUNBLFNBQVNuQztRQUNSd0UsUUFBUUMsSUFBSSxDQUFDO0lBQ2Q7SUFFQWxGLFlBQVlLLE1BQU0sQ0FBQ0wsWUFBWW1GLElBQUk7SUFFbkMsT0FBT25GO0FBQ1I7QUFFQW9GLE9BQU9DLE9BQU8sR0FBR3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmF2b2NoYXQtYXBwLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcz81YTk5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwibmFtZXMiOlsic2V0dXAiLCJlbnYiLCJjcmVhdGVEZWJ1ZyIsImRlYnVnIiwiZGVmYXVsdCIsImNvZXJjZSIsImRpc2FibGUiLCJlbmFibGUiLCJlbmFibGVkIiwiaHVtYW5pemUiLCJyZXF1aXJlIiwiZGVzdHJveSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwibmFtZXMiLCJza2lwcyIsImZvcm1hdHRlcnMiLCJzZWxlY3RDb2xvciIsIm5hbWVzcGFjZSIsImhhc2giLCJpIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImNvbG9ycyIsIk1hdGgiLCJhYnMiLCJwcmV2VGltZSIsImVuYWJsZU92ZXJyaWRlIiwibmFtZXNwYWNlc0NhY2hlIiwiZW5hYmxlZENhY2hlIiwiYXJncyIsInNlbGYiLCJjdXJyIiwiTnVtYmVyIiwiRGF0ZSIsIm1zIiwiZGlmZiIsInByZXYiLCJ1bnNoaWZ0IiwiaW5kZXgiLCJyZXBsYWNlIiwibWF0Y2giLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJ2YWwiLCJjYWxsIiwic3BsaWNlIiwiZm9ybWF0QXJncyIsImxvZ0ZuIiwibG9nIiwiYXBwbHkiLCJ1c2VDb2xvcnMiLCJjb2xvciIsImV4dGVuZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImdldCIsIm5hbWVzcGFjZXMiLCJzZXQiLCJ2IiwiaW5pdCIsImRlbGltaXRlciIsIm5ld0RlYnVnIiwic2F2ZSIsInNwbGl0IiwibGVuIiwicHVzaCIsIlJlZ0V4cCIsInNsaWNlIiwibWFwIiwidG9OYW1lc3BhY2UiLCJqb2luIiwibmFtZSIsInRlc3QiLCJyZWdleHAiLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsIkVycm9yIiwic3RhY2siLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJsb2FkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ if (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUQsSUFBSSxPQUFPQSxZQUFZLGVBQWVBLFFBQVFDLElBQUksS0FBSyxjQUFjRCxLQUFlLEtBQUssUUFBUUEsUUFBUUcsTUFBTSxFQUFFO0lBQ2hIQyw0SEFBeUI7QUFDMUIsT0FBTztJQUNOQSxzSEFBeUI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanM/ZDFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciAvIG53anMgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwidHlwZSIsImJyb3dzZXIiLCJfX253anMiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ const tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"?a107\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBRXJCOztDQUVDLEdBRURFLFlBQVksR0FBR0M7QUFDZkQsV0FBVyxHQUFHRTtBQUNkRixrQkFBa0IsR0FBR0c7QUFDckJILFlBQVksR0FBR0k7QUFDZkosWUFBWSxHQUFHSztBQUNmTCxpQkFBaUIsR0FBR007QUFDcEJOLGVBQWUsR0FBR0QsS0FBS1MsU0FBUyxDQUMvQixLQUFPLEdBQ1A7QUFHRDs7Q0FFQyxHQUVEUixjQUFjLEdBQUc7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FBRTtBQUVuQyxJQUFJO0lBQ0gsMkdBQTJHO0lBQzNHLDZEQUE2RDtJQUM3RCxNQUFNVSxnQkFBZ0JaLG1CQUFPQSxDQUFDO0lBRTlCLElBQUlZLGlCQUFpQixDQUFDQSxjQUFjQyxNQUFNLElBQUlELGFBQVksRUFBR0UsS0FBSyxJQUFJLEdBQUc7UUFDeEVaLGNBQWMsR0FBRztZQUNoQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNB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QUFXLEdBQUcsQ0FBQztJQUVyQixNQUFNRSxPQUFPRCxPQUFPQyxJQUFJLENBQUNoQixRQUFRYyxXQUFXO0lBQzVDLElBQUssSUFBSTRDLElBQUksR0FBR0EsSUFBSTFDLEtBQUsyQyxNQUFNLEVBQUVELElBQUs7UUFDckNELE1BQU0zQyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQyxHQUFHMUQsUUFBUWMsV0FBVyxDQUFDRSxJQUFJLENBQUMwQyxFQUFFLENBQUM7SUFDMUQ7QUFDRDtBQUVBWixPQUFPOUMsT0FBTyxHQUFHRixtQkFBT0EsQ0FBQyxtRkFBWUU7QUFFckMsTUFBTSxFQUFDNEQsVUFBVSxFQUFDLEdBQUdkLE9BQU85QyxPQUFPO0FBRW5DOztDQUVDLEdBRUQ0RCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXLEVBQ3JDNkIsS0FBSyxDQUFDLE1BQ05xQixHQUFHLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLElBQUksSUFDbkJ0QixJQUFJLENBQUM7QUFDUjtBQUVBOztDQUVDLEdBRURnQixXQUFXTyxDQUFDLEdBQUcsU0FBVUwsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmF2b2NoYXQtYXBwLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanM/NzgxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5kZXN0cm95ID0gdXRpbC5kZXByZWNhdGUoXG5cdCgpID0+IHt9LFxuXHQnSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLidcbik7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuXHQvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5cdGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuXG5cdGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG5cdFx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdFx0XHQyMCxcblx0XHRcdDIxLFxuXHRcdFx0MjYsXG5cdFx0XHQyNyxcblx0XHRcdDMyLFxuXHRcdFx0MzMsXG5cdFx0XHQzOCxcblx0XHRcdDM5LFxuXHRcdFx0NDAsXG5cdFx0XHQ0MSxcblx0XHRcdDQyLFxuXHRcdFx0NDMsXG5cdFx0XHQ0NCxcblx0XHRcdDQ1LFxuXHRcdFx0NTYsXG5cdFx0XHQ1Nyxcblx0XHRcdDYyLFxuXHRcdFx0NjMsXG5cdFx0XHQ2OCxcblx0XHRcdDY5LFxuXHRcdFx0NzQsXG5cdFx0XHQ3NSxcblx0XHRcdDc2LFxuXHRcdFx0NzcsXG5cdFx0XHQ3OCxcblx0XHRcdDc5LFxuXHRcdFx0ODAsXG5cdFx0XHQ4MSxcblx0XHRcdDkyLFxuXHRcdFx0OTMsXG5cdFx0XHQ5OCxcblx0XHRcdDk5LFxuXHRcdFx0MTEyLFxuXHRcdFx0MTEzLFxuXHRcdFx0MTI4LFxuXHRcdFx0MTI5LFxuXHRcdFx0MTM0LFxuXHRcdFx0MTM1LFxuXHRcdFx0MTQ4LFxuXHRcdFx0MTQ5LFxuXHRcdFx0MTYwLFxuXHRcdFx0MTYxLFxuXHRcdFx0MTYyLFxuXHRcdFx0MTYzLFxuXHRcdFx0MTY0LFxuXHRcdFx0MTY1LFxuXHRcdFx0MTY2LFxuXHRcdFx0MTY3LFxuXHRcdFx0MTY4LFxuXHRcdFx0MTY5LFxuXHRcdFx0MTcwLFxuXHRcdFx0MTcxLFxuXHRcdFx0MTcyLFxuXHRcdFx0MTczLFxuXHRcdFx0MTc4LFxuXHRcdFx0MTc5LFxuXHRcdFx0MTg0LFxuXHRcdFx0MTg1LFxuXHRcdFx0MTk2LFxuXHRcdFx0MTk3LFxuXHRcdFx0MTk4LFxuXHRcdFx0MTk5LFxuXHRcdFx0MjAwLFxuXHRcdFx0MjAxLFxuXHRcdFx0MjAyLFxuXHRcdFx0MjAzLFxuXHRcdFx0MjA0LFxuXHRcdFx0MjA1LFxuXHRcdFx0MjA2LFxuXHRcdFx0MjA3LFxuXHRcdFx0MjA4LFxuXHRcdFx0MjA5LFxuXHRcdFx0MjE0LFxuXHRcdFx0MjE1LFxuXHRcdFx0MjIwLFxuXHRcdFx0MjIxXG5cdFx0XTtcblx0fVxufSBjYXRjaCAoZXJyb3IpIHtcblx0Ly8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihrZXkgPT4ge1xuXHRyZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdC8vIENhbWVsLWNhc2Vcblx0Y29uc3QgcHJvcCA9IGtleVxuXHRcdC5zdWJzdHJpbmcoNilcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuXHRcdFx0cmV0dXJuIGsudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblxuXHQvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblx0bGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG5cdGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcblx0XHR2YWwgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IE51bWJlcih2YWwpO1xuXHR9XG5cblx0b2JqW3Byb3BdID0gdmFsO1xuXHRyZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzID9cblx0XHRCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6XG5cdFx0dHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGNvbnN0IHtuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yc30gPSB0aGlzO1xuXG5cdGlmICh1c2VDb2xvcnMpIHtcblx0XHRjb25zdCBjID0gdGhpcy5jb2xvcjtcblx0XHRjb25zdCBjb2xvckNvZGUgPSAnXFx1MDAxQlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcblx0XHRjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxcdTAwMUJbMG1gO1xuXG5cdFx0YXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuXHRcdGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFCWzBtJyk7XG5cdH0gZWxzZSB7XG5cdFx0YXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG5cdGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXRXaXRoT3B0aW9ucygpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsLmZvcm1hdFdpdGhPcHRpb25zKGV4cG9ydHMuaW5zcGVjdE9wdHMsIC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5tYXAoc3RyID0+IHN0ci50cmltKCkpXG5cdFx0LmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcbiJdLCJuYW1lcyI6WyJ0dHkiLCJyZXF1aXJlIiwidXRpbCIsImV4cG9ydHMiLCJpbml0IiwibG9nIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwiZGVzdHJveSIsImRlcHJlY2F0ZSIsImNvbG9ycyIsInN1cHBvcnRzQ29sb3IiLCJzdGRlcnIiLCJsZXZlbCIsImVycm9yIiwiaW5zcGVjdE9wdHMiLCJPYmplY3QiLCJrZXlzIiwicHJvY2VzcyIsImVudiIsImZpbHRlciIsImtleSIsInRlc3QiLCJyZWR1Y2UiLCJvYmoiLCJwcm9wIiwic3Vic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwiXyIsImsiLCJ0b1VwcGVyQ2FzZSIsInZhbCIsIk51bWJlciIsIkJvb2xlYW4iLCJpc2F0dHkiLCJmZCIsImFyZ3MiLCJuYW1lc3BhY2UiLCJuYW1lIiwiYyIsImNvbG9yIiwiY29sb3JDb2RlIiwicHJlZml4Iiwic3BsaXQiLCJqb2luIiwicHVzaCIsIm1vZHVsZSIsImh1bWFuaXplIiwiZGlmZiIsImdldERhdGUiLCJoaWRlRGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIndyaXRlIiwiZm9ybWF0V2l0aE9wdGlvbnMiLCJuYW1lc3BhY2VzIiwiREVCVUciLCJkZWJ1ZyIsImkiLCJsZW5ndGgiLCJmb3JtYXR0ZXJzIiwibyIsInYiLCJpbnNwZWN0IiwibWFwIiwic3RyIiwidHJpbSIsIk8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/engine.io.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/engine.io.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.transports = exports.Server = void 0;\nexports.listen = listen;\nexports.attach = attach;\nconst http_1 = __webpack_require__(/*! http */ \"http\");\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/engine.io/build/server.js\");\nObject.defineProperty(exports, \"Server\", ({\n    enumerable: true,\n    get: function() {\n        return server_1.Server;\n    }\n}));\nconst index_1 = __webpack_require__(/*! ./transports/index */ \"(rsc)/./node_modules/engine.io/build/transports/index.js\");\nexports.transports = index_1.default;\nconst parser = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nexports.parser = parser;\nvar userver_1 = __webpack_require__(/*! ./userver */ \"(rsc)/./node_modules/engine.io/build/userver.js\");\nObject.defineProperty(exports, \"uServer\", ({\n    enumerable: true,\n    get: function() {\n        return userver_1.uServer;\n    }\n}));\nvar socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/engine.io/build/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({\n    enumerable: true,\n    get: function() {\n        return socket_1.Socket;\n    }\n}));\nvar transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nObject.defineProperty(exports, \"Transport\", ({\n    enumerable: true,\n    get: function() {\n        return transport_1.Transport;\n    }\n}));\nexports.protocol = parser.protocol;\n/**\n * Creates an http.Server exclusively used for WS upgrades.\n *\n * @param {Number} port\n * @param {Function} callback\n * @param {Object} options\n * @return {Server} websocket.io server\n */ function listen(port, options, fn) {\n    if (\"function\" === typeof options) {\n        fn = options;\n        options = {};\n    }\n    const server = (0, http_1.createServer)(function(req, res) {\n        res.writeHead(501);\n        res.end(\"Not Implemented\");\n    });\n    // create engine server\n    const engine = attach(server, options);\n    engine.httpServer = server;\n    server.listen(port, fn);\n    return engine;\n}\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @return {Server} engine server\n */ function attach(server, options) {\n    const engine = new server_1.Server(options);\n    engine.attach(server, options);\n    return engine;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL2VuZ2luZS5pby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLGlCQUFpQixHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxrQkFBa0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDdElBLGNBQWMsR0FBR1M7QUFDakJULGNBQWMsR0FBR1U7QUFDakIsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsZ0VBQVU7QUFDbkNkLDBDQUF5QztJQUFFZ0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsU0FBU0wsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVHLE1BQU1RLFVBQVVKLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUM1Q1osa0JBQWtCLEdBQUdnQixRQUFRQyxPQUFPO0FBQ3BDLE1BQU1YLFNBQVNNLG1CQUFPQSxDQUFDLGtGQUFrQjtBQUN6Q1osY0FBYyxHQUFHTTtBQUNqQixJQUFJWSxZQUFZTixtQkFBT0EsQ0FBQyxrRUFBVztBQUNuQ2QsMkNBQTBDO0lBQUVnQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxVQUFVYixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0csSUFBSWMsV0FBV1AsbUJBQU9BLENBQUMsZ0VBQVU7QUFDakNkLDBDQUF5QztJQUFFZ0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0ksU0FBU2YsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVHLElBQUlnQixjQUFjUixtQkFBT0EsQ0FBQyxzRUFBYTtBQUN2Q2QsNkNBQTRDO0lBQUVnQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSyxZQUFZakIsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JISCxnQkFBZ0IsR0FBR00sT0FBT0osUUFBUTtBQUNsQzs7Ozs7OztDQU9DLEdBQ0QsU0FBU08sT0FBT1ksSUFBSSxFQUFFQyxPQUFPLEVBQUVDLEVBQUU7SUFDN0IsSUFBSSxlQUFlLE9BQU9ELFNBQVM7UUFDL0JDLEtBQUtEO1FBQ0xBLFVBQVUsQ0FBQztJQUNmO0lBQ0EsTUFBTUUsU0FBUyxDQUFDLEdBQUdiLE9BQU9jLFlBQVksRUFBRSxTQUFVQyxHQUFHLEVBQUVDLEdBQUc7UUFDdERBLElBQUlDLFNBQVMsQ0FBQztRQUNkRCxJQUFJRSxHQUFHLENBQUM7SUFDWjtJQUNBLHVCQUF1QjtJQUN2QixNQUFNQyxTQUFTcEIsT0FBT2MsUUFBUUY7SUFDOUJRLE9BQU9DLFVBQVUsR0FBR1A7SUFDcEJBLE9BQU9mLE1BQU0sQ0FBQ1ksTUFBTUU7SUFDcEIsT0FBT087QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNwQixPQUFPYyxNQUFNLEVBQUVGLE9BQU87SUFDM0IsTUFBTVEsU0FBUyxJQUFJakIsU0FBU0wsTUFBTSxDQUFDYztJQUNuQ1EsT0FBT3BCLE1BQU0sQ0FBQ2MsUUFBUUY7SUFDdEIsT0FBT1E7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3Jhdm9jaGF0LWFwcC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvZW5naW5lLmlvLmpzP2IwOWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3RvY29sID0gZXhwb3J0cy5UcmFuc3BvcnQgPSBleHBvcnRzLlNvY2tldCA9IGV4cG9ydHMudVNlcnZlciA9IGV4cG9ydHMucGFyc2VyID0gZXhwb3J0cy50cmFuc3BvcnRzID0gZXhwb3J0cy5TZXJ2ZXIgPSB2b2lkIDA7XG5leHBvcnRzLmxpc3RlbiA9IGxpc3RlbjtcbmV4cG9ydHMuYXR0YWNoID0gYXR0YWNoO1xuY29uc3QgaHR0cF8xID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyXzEuU2VydmVyOyB9IH0pO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHMvaW5kZXhcIik7XG5leHBvcnRzLnRyYW5zcG9ydHMgPSBpbmRleF8xLmRlZmF1bHQ7XG5jb25zdCBwYXJzZXIgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xudmFyIHVzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXJ2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1U2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1c2VydmVyXzEudVNlcnZlcjsgfSB9KTtcbnZhciBzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3NvY2tldFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ja2V0XzEuU29ja2V0OyB9IH0pO1xudmFyIHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNwb3J0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc3BvcnRfMS5UcmFuc3BvcnQ7IH0gfSk7XG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuLyoqXG4gKiBDcmVhdGVzIGFuIGh0dHAuU2VydmVyIGV4Y2x1c2l2ZWx5IHVzZWQgZm9yIFdTIHVwZ3JhZGVzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3J0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NlcnZlcn0gd2Vic29ja2V0LmlvIHNlcnZlclxuICovXG5mdW5jdGlvbiBsaXN0ZW4ocG9ydCwgb3B0aW9ucywgZm4pIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgICAgICBmbiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgc2VydmVyID0gKDAsIGh0dHBfMS5jcmVhdGVTZXJ2ZXIpKGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICAgICAgICByZXMud3JpdGVIZWFkKDUwMSk7XG4gICAgICAgIHJlcy5lbmQoXCJOb3QgSW1wbGVtZW50ZWRcIik7XG4gICAgfSk7XG4gICAgLy8gY3JlYXRlIGVuZ2luZSBzZXJ2ZXJcbiAgICBjb25zdCBlbmdpbmUgPSBhdHRhY2goc2VydmVyLCBvcHRpb25zKTtcbiAgICBlbmdpbmUuaHR0cFNlcnZlciA9IHNlcnZlcjtcbiAgICBzZXJ2ZXIubGlzdGVuKHBvcnQsIGZuKTtcbiAgICByZXR1cm4gZW5naW5lO1xufVxuLyoqXG4gKiBDYXB0dXJlcyB1cGdyYWRlIHJlcXVlc3RzIGZvciBhIGh0dHAuU2VydmVyLlxuICpcbiAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJ9IHNlcnZlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NlcnZlcn0gZW5naW5lIHNlcnZlclxuICovXG5mdW5jdGlvbiBhdHRhY2goc2VydmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IHNlcnZlcl8xLlNlcnZlcihvcHRpb25zKTtcbiAgICBlbmdpbmUuYXR0YWNoKHNlcnZlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGVuZ2luZTtcbn1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInByb3RvY29sIiwiVHJhbnNwb3J0IiwiU29ja2V0IiwidVNlcnZlciIsInBhcnNlciIsInRyYW5zcG9ydHMiLCJTZXJ2ZXIiLCJsaXN0ZW4iLCJhdHRhY2giLCJodHRwXzEiLCJyZXF1aXJlIiwic2VydmVyXzEiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaW5kZXhfMSIsImRlZmF1bHQiLCJ1c2VydmVyXzEiLCJzb2NrZXRfMSIsInRyYW5zcG9ydF8xIiwicG9ydCIsIm9wdGlvbnMiLCJmbiIsInNlcnZlciIsImNyZWF0ZVNlcnZlciIsInJlcSIsInJlcyIsIndyaXRlSGVhZCIsImVuZCIsImVuZ2luZSIsImh0dHBTZXJ2ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/engine.io.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/parser-v3/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.packets = exports.protocol = void 0;\nexports.encodePacket = encodePacket;\nexports.encodeBase64Packet = encodeBase64Packet;\nexports.decodePacket = decodePacket;\nexports.decodeBase64Packet = decodeBase64Packet;\nexports.encodePayload = encodePayload;\nexports.decodePayload = decodePayload;\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\n/**\n * Module dependencies.\n */ var utf8 = __webpack_require__(/*! ./utf8 */ \"(rsc)/./node_modules/engine.io/build/parser-v3/utf8.js\");\n/**\n * Current protocol version.\n */ exports.protocol = 3;\nconst hasBinary = (packets)=>{\n    for (const packet of packets){\n        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Packet types.\n */ exports.packets = {\n    open: 0 // non-ws\n    ,\n    close: 1 // non-ws\n    ,\n    ping: 2,\n    pong: 3,\n    message: 4,\n    upgrade: 5,\n    noop: 6\n};\nvar packetslist = Object.keys(exports.packets);\n/**\n * Premade error packet.\n */ var err = {\n    type: \"error\",\n    data: \"parser error\"\n};\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */ function encodePacket(packet, supportsBinary, utf8encode, callback) {\n    if (typeof supportsBinary === \"function\") {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (typeof utf8encode === \"function\") {\n        callback = utf8encode;\n        utf8encode = null;\n    }\n    if (Buffer.isBuffer(packet.data)) {\n        return encodeBuffer(packet, supportsBinary, callback);\n    } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n        return encodeBuffer({\n            type: packet.type,\n            data: arrayBufferToBuffer(packet.data)\n        }, supportsBinary, callback);\n    }\n    // Sending data as a utf-8 string\n    var encoded = exports.packets[packet.type];\n    // data fragment is optional\n    if (undefined !== packet.data) {\n        encoded += utf8encode ? utf8.encode(String(packet.data), {\n            strict: false\n        }) : String(packet.data);\n    }\n    return callback(\"\" + encoded);\n}\n;\n/**\n * Encode Buffer data\n */ function encodeBuffer(packet, supportsBinary, callback) {\n    if (!supportsBinary) {\n        return encodeBase64Packet(packet, callback);\n    }\n    var data = packet.data;\n    var typeBuffer = Buffer.allocUnsafe(1);\n    typeBuffer[0] = exports.packets[packet.type];\n    return callback(Buffer.concat([\n        typeBuffer,\n        data\n    ]));\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */ function encodeBase64Packet(packet, callback) {\n    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n    var message = \"b\" + exports.packets[packet.type];\n    message += data.toString(\"base64\");\n    return callback(message);\n}\n;\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */ function decodePacket(data, binaryType, utf8decode) {\n    if (data === undefined) {\n        return err;\n    }\n    var type;\n    // String data\n    if (typeof data === \"string\") {\n        type = data.charAt(0);\n        if (type === \"b\") {\n            return decodeBase64Packet(data.slice(1), binaryType);\n        }\n        if (utf8decode) {\n            data = tryDecode(data);\n            if (data === false) {\n                return err;\n            }\n        }\n        if (Number(type) != type || !packetslist[type]) {\n            return err;\n        }\n        if (data.length > 1) {\n            return {\n                type: packetslist[type],\n                data: data.slice(1)\n            };\n        } else {\n            return {\n                type: packetslist[type]\n            };\n        }\n    }\n    // Binary data\n    if (binaryType === \"arraybuffer\") {\n        // wrap Buffer/ArrayBuffer data into an Uint8Array\n        var intArray = new Uint8Array(data);\n        type = intArray[0];\n        return {\n            type: packetslist[type],\n            data: intArray.buffer.slice(1)\n        };\n    }\n    if (data instanceof ArrayBuffer) {\n        data = arrayBufferToBuffer(data);\n    }\n    type = data[0];\n    return {\n        type: packetslist[type],\n        data: data.slice(1)\n    };\n}\n;\nfunction tryDecode(data) {\n    try {\n        data = utf8.decode(data, {\n            strict: false\n        });\n    } catch (e) {\n        return false;\n    }\n    return data;\n}\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */ function decodeBase64Packet(msg, binaryType) {\n    var type = packetslist[msg.charAt(0)];\n    var data = Buffer.from(msg.slice(1), \"base64\");\n    if (binaryType === \"arraybuffer\") {\n        var abv = new Uint8Array(data.length);\n        for(var i = 0; i < abv.length; i++){\n            abv[i] = data[i];\n        }\n        // @ts-ignore\n        data = abv.buffer;\n    }\n    return {\n        type: type,\n        data: data\n    };\n}\n;\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */ function encodePayload(packets, supportsBinary, callback) {\n    if (typeof supportsBinary === \"function\") {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (supportsBinary && hasBinary(packets)) {\n        return encodePayloadAsBinary(packets, callback);\n    }\n    if (!packets.length) {\n        return callback(\"0:\");\n    }\n    function encodeOne(packet, doneCallback) {\n        encodePacket(packet, supportsBinary, false, function(message) {\n            doneCallback(null, setLengthHeader(message));\n        });\n    }\n    map(packets, encodeOne, function(err, results) {\n        return callback(results.join(\"\"));\n    });\n}\n;\nfunction setLengthHeader(message) {\n    return message.length + \":\" + message;\n}\n/**\n * Async array map using after\n */ function map(ary, each, done) {\n    const results = new Array(ary.length);\n    let count = 0;\n    for(let i = 0; i < ary.length; i++){\n        each(ary[i], (error, msg)=>{\n            results[i] = msg;\n            if (++count === ary.length) {\n                done(null, results);\n            }\n        });\n    }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */ function decodePayload(data, binaryType, callback) {\n    if (typeof data !== \"string\") {\n        return decodePayloadAsBinary(data, binaryType, callback);\n    }\n    if (typeof binaryType === \"function\") {\n        callback = binaryType;\n        binaryType = null;\n    }\n    if (data === \"\") {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n    var length = \"\", n, msg, packet;\n    for(var i = 0, l = data.length; i < l; i++){\n        var chr = data.charAt(i);\n        if (chr !== \":\") {\n            length += chr;\n            continue;\n        }\n        // @ts-ignore\n        if (length === \"\" || length != (n = Number(length))) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        msg = data.slice(i + 1, i + 1 + n);\n        if (length != msg.length) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        if (msg.length) {\n            packet = decodePacket(msg, binaryType, false);\n            if (err.type === packet.type && err.data === packet.data) {\n                // parser error in individual packet - ignoring payload\n                return callback(err, 0, 1);\n            }\n            var more = callback(packet, i + n, l);\n            if (false === more) return;\n        }\n        // advance cursor\n        i += n;\n        length = \"\";\n    }\n    if (length !== \"\") {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n}\n;\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */ function bufferToString(buffer) {\n    var str = \"\";\n    for(var i = 0, l = buffer.length; i < l; i++){\n        str += String.fromCharCode(buffer[i]);\n    }\n    return str;\n}\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */ function stringToBuffer(string) {\n    var buf = Buffer.allocUnsafe(string.length);\n    for(var i = 0, l = string.length; i < l; i++){\n        buf.writeUInt8(string.charCodeAt(i), i);\n    }\n    return buf;\n}\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */ function arrayBufferToBuffer(data) {\n    // data is either an ArrayBuffer or ArrayBufferView.\n    var length = data.byteLength || data.length;\n    var offset = data.byteOffset || 0;\n    return Buffer.from(data.buffer || data, offset, length);\n}\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */ function encodePayloadAsBinary(packets, callback) {\n    if (!packets.length) {\n        return callback(EMPTY_BUFFER);\n    }\n    map(packets, encodeOneBinaryPacket, function(err, results) {\n        return callback(Buffer.concat(results));\n    });\n}\n;\nfunction encodeOneBinaryPacket(p, doneCallback) {\n    function onBinaryPacketEncode(packet) {\n        var encodingLength = \"\" + packet.length;\n        var sizeBuffer;\n        if (typeof packet === \"string\") {\n            sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n            sizeBuffer[0] = 0; // is a string (not true binary = 0)\n            for(var i = 0; i < encodingLength.length; i++){\n                sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n            }\n            sizeBuffer[sizeBuffer.length - 1] = 255;\n            return doneCallback(null, Buffer.concat([\n                sizeBuffer,\n                stringToBuffer(packet)\n            ]));\n        }\n        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n        sizeBuffer[0] = 1; // is binary (true binary = 1)\n        for(var i = 0; i < encodingLength.length; i++){\n            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n        }\n        sizeBuffer[sizeBuffer.length - 1] = 255;\n        doneCallback(null, Buffer.concat([\n            sizeBuffer,\n            packet\n        ]));\n    }\n    encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */ function decodePayloadAsBinary(data, binaryType, callback) {\n    if (typeof binaryType === \"function\") {\n        callback = binaryType;\n        binaryType = null;\n    }\n    var bufferTail = data;\n    var buffers = [];\n    var i;\n    while(bufferTail.length > 0){\n        var strLen = \"\";\n        var isString = bufferTail[0] === 0;\n        for(i = 1;; i++){\n            if (bufferTail[i] === 255) break;\n            // 310 = char length of Number.MAX_VALUE\n            if (strLen.length > 310) {\n                return callback(err, 0, 1);\n            }\n            strLen += \"\" + bufferTail[i];\n        }\n        bufferTail = bufferTail.slice(strLen.length + 1);\n        var msgLength = parseInt(strLen, 10);\n        var msg = bufferTail.slice(1, msgLength + 1);\n        if (isString) msg = bufferToString(msg);\n        buffers.push(msg);\n        bufferTail = bufferTail.slice(msgLength + 1);\n    }\n    var total = buffers.length;\n    for(i = 0; i < total; i++){\n        var buffer = buffers[i];\n        callback(decodePacket(buffer, binaryType, true), i, total);\n    }\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3BhcnNlci12My9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHdFQUF3RTtBQUN4RUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUMxQ0Esb0JBQW9CLEdBQUdJO0FBQ3ZCSiwwQkFBMEIsR0FBR0s7QUFDN0JMLG9CQUFvQixHQUFHTTtBQUN2Qk4sMEJBQTBCLEdBQUdPO0FBQzdCUCxxQkFBcUIsR0FBR1E7QUFDeEJSLHFCQUFxQixHQUFHUztBQUN4QlQsNkJBQTZCLEdBQUdVO0FBQ2hDViw2QkFBNkIsR0FBR1c7QUFDaEM7O0NBRUMsR0FDRCxJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQjs7Q0FFQyxHQUNEYixnQkFBZ0IsR0FBRztBQUNuQixNQUFNYyxZQUFZLENBQUNaO0lBQ2YsS0FBSyxNQUFNYSxVQUFVYixRQUFTO1FBQzFCLElBQUlhLE9BQU9DLElBQUksWUFBWUMsZUFBZUEsWUFBWUMsTUFBTSxDQUFDSCxPQUFPQyxJQUFJLEdBQUc7WUFDdkUsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7Q0FFQyxHQUNEaEIsZUFBZSxHQUFHO0lBQ2RtQixNQUFNLEVBQUUsU0FBUzs7SUFFakJDLE9BQU8sRUFBRSxTQUFTOztJQUVsQkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxNQUFNO0FBQ1Y7QUFDQSxJQUFJQyxjQUFjNUIsT0FBTzZCLElBQUksQ0FBQzNCLFFBQVFFLE9BQU87QUFDN0M7O0NBRUMsR0FDRCxJQUFJMEIsTUFBTTtJQUFFQyxNQUFNO0lBQVNiLE1BQU07QUFBZTtBQUNoRCxNQUFNYyxlQUFlQyxPQUFPQyxNQUFNLENBQUMsRUFBRTtBQUNyQzs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELFNBQVM1QixhQUFhVyxNQUFNLEVBQUVrQixj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QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3Jhdm9jaGF0LWFwcC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvcGFyc2VyLXYzL2luZGV4LmpzP2ZhMGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tcGFyc2VyL3RyZWUvMi4yLnhcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFja2V0cyA9IGV4cG9ydHMucHJvdG9jb2wgPSB2b2lkIDA7XG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGVuY29kZVBhY2tldDtcbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZW5jb2RlQmFzZTY0UGFja2V0O1xuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBkZWNvZGVQYWNrZXQ7XG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGRlY29kZUJhc2U2NFBhY2tldDtcbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGVuY29kZVBheWxvYWQ7XG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBkZWNvZGVQYXlsb2FkO1xuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCaW5hcnkgPSBlbmNvZGVQYXlsb2FkQXNCaW5hcnk7XG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGRlY29kZVBheWxvYWRBc0JpbmFyeTtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xudmFyIHV0ZjggPSByZXF1aXJlKCcuL3V0ZjgnKTtcbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5leHBvcnRzLnByb3RvY29sID0gMztcbmNvbnN0IGhhc0JpbmFyeSA9IChwYWNrZXRzKSA9PiB7XG4gICAgZm9yIChjb25zdCBwYWNrZXQgb2YgcGFja2V0cykge1xuICAgICAgICBpZiAocGFja2V0LmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcocGFja2V0LmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cbmV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAwIC8vIG5vbi13c1xuICAgICxcbiAgICBjbG9zZTogMSAvLyBub24td3NcbiAgICAsXG4gICAgcGluZzogMixcbiAgICBwb25nOiAzLFxuICAgIG1lc3NhZ2U6IDQsXG4gICAgdXBncmFkZTogNSxcbiAgICBub29wOiA2XG59O1xudmFyIHBhY2tldHNsaXN0ID0gT2JqZWN0LmtleXMoZXhwb3J0cy5wYWNrZXRzKTtcbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5jb25zdCBFTVBUWV9CVUZGRVIgPSBCdWZmZXIuY29uY2F0KFtdKTtcbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICAgICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgICAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwYWNrZXQuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhY2tldC5kYXRhICYmIChwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGEpIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJ1ZmZlcih7IHR5cGU6IHBhY2tldC50eXBlLCBkYXRhOiBhcnJheUJ1ZmZlclRvQnVmZmVyKHBhY2tldC5kYXRhKSB9LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgICB2YXIgZW5jb2RlZCA9IGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gICAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICAgIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSksIHsgc3RyaWN0OiBmYWxzZSB9KSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xufVxuO1xuLyoqXG4gKiBFbmNvZGUgQnVmZmVyIGRhdGFcbiAqL1xuZnVuY3Rpb24gZW5jb2RlQnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICAgIHZhciB0eXBlQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDEpO1xuICAgIHR5cGVCdWZmZXJbMF0gPSBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICAgIHJldHVybiBjYWxsYmFjayhCdWZmZXIuY29uY2F0KFt0eXBlQnVmZmVyLCBkYXRhXSkpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IEJ1ZmZlci5pc0J1ZmZlcihwYWNrZXQuZGF0YSkgPyBwYWNrZXQuZGF0YSA6IGFycmF5QnVmZmVyVG9CdWZmZXIocGFja2V0LmRhdGEpO1xuICAgIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgICBtZXNzYWdlICs9IGRhdGEudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cbjtcbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gRGF0YSBhbHNvIGF2YWlsYWJsZSBhcyBhbiBBcnJheUJ1ZmZlciBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlUGFja2V0KGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIHZhciB0eXBlO1xuICAgIC8vIFN0cmluZyBkYXRhXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG4gICAgICAgIGlmICh0eXBlID09PSAnYicpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zbGljZSgxKSwgYmluYXJ5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc2xpY2UoMSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmluYXJ5IGRhdGFcbiAgICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAvLyB3cmFwIEJ1ZmZlci9BcnJheUJ1ZmZlciBkYXRhIGludG8gYW4gVWludDhBcnJheVxuICAgICAgICB2YXIgaW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgdHlwZSA9IGludEFycmF5WzBdO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogaW50QXJyYXkuYnVmZmVyLnNsaWNlKDEpIH07XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgZGF0YSA9IGFycmF5QnVmZmVyVG9CdWZmZXIoZGF0YSk7XG4gICAgfVxuICAgIHR5cGUgPSBkYXRhWzBdO1xuICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnNsaWNlKDEpIH07XG59XG47XG5mdW5jdGlvbiB0cnlEZWNvZGUoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5mdW5jdGlvbiBkZWNvZGVCYXNlNjRQYWNrZXQobXNnLCBiaW5hcnlUeXBlKSB7XG4gICAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgICB2YXIgZGF0YSA9IEJ1ZmZlci5mcm9tKG1zZy5zbGljZSgxKSwgJ2Jhc2U2NCcpO1xuICAgIGlmIChiaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWJ2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhYnZbaV0gPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZGF0YSA9IGFidi5idWZmZXI7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn1cbjtcbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVBheWxvYWQocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgICAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBoYXNCaW5hcnkocGFja2V0cykpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVBheWxvYWRBc0JpbmFyeShwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICAgICAgZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgICB9KTtcbn1cbjtcbmZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbn1cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWFjaChhcnlbaV0sIChlcnJvciwgbXNnKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gbXNnO1xuICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGFyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkb25lKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlUGF5bG9hZChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YSA9PT0gJycpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9ICcnLCBuLCBtc2csIHBhY2tldDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNociAhPT0gJzonKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gY2hyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbXNnID0gZGF0YS5zbGljZShpICsgMSwgaSArIDEgKyBuKTtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFja2V0ID0gZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGVyci50eXBlID09PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW9yZSA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICAgICAgaWYgKGZhbHNlID09PSBtb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgICBpICs9IG47XG4gICAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cbn1cbjtcbi8qKlxuICpcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGEgdXRmOC5qcyBlbmNvZGVkIHN0cmluZ1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBidWZmZXJUb1N0cmluZyhidWZmZXIpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlcltpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqXG4gKiBDb252ZXJ0cyBhIHV0ZjguanMgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXJcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9CdWZmZXIoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYnVmLndyaXRlVUludDgoc3RyaW5nLmNoYXJDb2RlQXQoaSksIGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuLyoqXG4gKlxuICogQ29udmVydHMgYW4gQXJyYXlCdWZmZXIgdG8gYSBCdWZmZXJcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0J1ZmZlcihkYXRhKSB7XG4gICAgLy8gZGF0YSBpcyBlaXRoZXIgYW4gQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3LlxuICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGg7XG4gICAgdmFyIG9mZnNldCA9IGRhdGEuYnl0ZU9mZnNldCB8fCAwO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhLmJ1ZmZlciB8fCBkYXRhLCBvZmZzZXQsIGxlbmd0aCk7XG59XG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGVQYXlsb2FkQXNCaW5hcnkocGFja2V0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhFTVBUWV9CVUZGRVIpO1xuICAgIH1cbiAgICBtYXAocGFja2V0cywgZW5jb2RlT25lQmluYXJ5UGFja2V0LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCdWZmZXIuY29uY2F0KHJlc3VsdHMpKTtcbiAgICB9KTtcbn1cbjtcbmZ1bmN0aW9uIGVuY29kZU9uZUJpbmFyeVBhY2tldChwLCBkb25lQ2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBvbkJpbmFyeVBhY2tldEVuY29kZShwYWNrZXQpIHtcbiAgICAgICAgdmFyIGVuY29kaW5nTGVuZ3RoID0gJycgKyBwYWNrZXQubGVuZ3RoO1xuICAgICAgICB2YXIgc2l6ZUJ1ZmZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWNrZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzaXplQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoLmxlbmd0aCArIDIpO1xuICAgICAgICAgICAgc2l6ZUJ1ZmZlclswXSA9IDA7IC8vIGlzIGEgc3RyaW5nIChub3QgdHJ1ZSBiaW5hcnkgPSAwKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGluZ0xlbmd0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNpemVCdWZmZXJbaSArIDFdID0gcGFyc2VJbnQoZW5jb2RpbmdMZW5ndGhbaV0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemVCdWZmZXJbc2l6ZUJ1ZmZlci5sZW5ndGggLSAxXSA9IDI1NTtcbiAgICAgICAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChbc2l6ZUJ1ZmZlciwgc3RyaW5nVG9CdWZmZXIocGFja2V0KV0pKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoLmxlbmd0aCArIDIpO1xuICAgICAgICBzaXplQnVmZmVyWzBdID0gMTsgLy8gaXMgYmluYXJ5ICh0cnVlIGJpbmFyeSA9IDEpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RpbmdMZW5ndGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNpemVCdWZmZXJbaSArIDFdID0gcGFyc2VJbnQoZW5jb2RpbmdMZW5ndGhbaV0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplQnVmZmVyW3NpemVCdWZmZXIubGVuZ3RoIC0gMV0gPSAyNTU7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBCdWZmZXIuY29uY2F0KFtzaXplQnVmZmVyLCBwYWNrZXRdKSk7XG4gICAgfVxuICAgIGVuY29kZVBhY2tldChwLCB0cnVlLCB0cnVlLCBvbkJpbmFyeVBhY2tldEVuY29kZSk7XG59XG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcblxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICAgICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gICAgfVxuICAgIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHdoaWxlIChidWZmZXJUYWlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHN0ckxlbiA9ICcnO1xuICAgICAgICB2YXIgaXNTdHJpbmcgPSBidWZmZXJUYWlsWzBdID09PSAwO1xuICAgICAgICBmb3IgKGkgPSAxOzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyVGFpbFtpXSA9PT0gMjU1KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gMzEwID0gY2hhciBsZW5ndGggb2YgTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgICAgICAgaWYgKHN0ckxlbi5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ckxlbiArPSAnJyArIGJ1ZmZlclRhaWxbaV07XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyVGFpbCA9IGJ1ZmZlclRhaWwuc2xpY2Uoc3RyTGVuLmxlbmd0aCArIDEpO1xuICAgICAgICB2YXIgbXNnTGVuZ3RoID0gcGFyc2VJbnQoc3RyTGVuLCAxMCk7XG4gICAgICAgIHZhciBtc2cgPSBidWZmZXJUYWlsLnNsaWNlKDEsIG1zZ0xlbmd0aCArIDEpO1xuICAgICAgICBpZiAoaXNTdHJpbmcpXG4gICAgICAgICAgICBtc2cgPSBidWZmZXJUb1N0cmluZyhtc2cpO1xuICAgICAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICAgICAgYnVmZmVyVGFpbCA9IGJ1ZmZlclRhaWwuc2xpY2UobXNnTGVuZ3RoICsgMSk7XG4gICAgfVxuICAgIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgICBjYWxsYmFjayhkZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICAgIH1cbn1cbjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhY2tldHMiLCJwcm90b2NvbCIsImVuY29kZVBhY2tldCIsImVuY29kZUJhc2U2NFBhY2tldCIsImRlY29kZVBhY2tldCIsImRlY29kZUJhc2U2NFBhY2tldCIsImVuY29kZVBheWxvYWQiLCJkZWNvZGVQYXlsb2FkIiwiZW5jb2RlUGF5bG9hZEFzQmluYXJ5IiwiZGVjb2RlUGF5bG9hZEFzQmluYXJ5IiwidXRmOCIsInJlcXVpcmUiLCJoYXNCaW5hcnkiLCJwYWNrZXQiLCJkYXRhIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJvcGVuIiwiY2xvc2UiLCJwaW5nIiwicG9uZyIsIm1lc3NhZ2UiLCJ1cGdyYWRlIiwibm9vcCIsInBhY2tldHNsaXN0Iiwia2V5cyIsImVyciIsInR5cGUiLCJFTVBUWV9CVUZGRVIiLCJCdWZmZXIiLCJjb25jYXQiLCJzdXBwb3J0c0JpbmFyeSIsInV0ZjhlbmNvZGUiLCJjYWxsYmFjayIsImlzQnVmZmVyIiwiZW5jb2RlQnVmZmVyIiwiYnVmZmVyIiwiYXJyYXlCdWZmZXJUb0J1ZmZlciIsImVuY29kZWQiLCJ1bmRlZmluZWQiLCJlbmNvZGUiLCJTdHJpbmciLCJzdHJpY3QiLCJ0eXBlQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJ0b1N0cmluZyIsImJpbmFyeVR5cGUiLCJ1dGY4ZGVjb2RlIiwiY2hhckF0Iiwic2xpY2UiLCJ0cnlEZWNvZGUiLCJOdW1iZXIiLCJsZW5ndGgiLCJpbnRBcnJheSIsIlVpbnQ4QXJyYXkiLCJkZWNvZGUiLCJlIiwibXNnIiwiZnJvbSIsImFidiIsImkiLCJlbmNvZGVPbmUiLCJkb25lQ2FsbGJhY2siLCJzZXRMZW5ndGhIZWFkZXIiLCJtYXAiLCJyZXN1bHRzIiwiam9pbiIsImFyeSIsImVhY2giLCJkb25lIiwiQXJyYXkiLCJjb3VudCIsImVycm9yIiwibiIsImwiLCJjaHIiLCJtb3JlIiwiYnVmZmVyVG9TdHJpbmciLCJzdHIiLCJmcm9tQ2hhckNvZGUiLCJzdHJpbmdUb0J1ZmZlciIsInN0cmluZyIsImJ1ZiIsIndyaXRlVUludDgiLCJjaGFyQ29kZUF0IiwiYnl0ZUxlbmd0aCIsIm9mZnNldCIsImJ5dGVPZmZzZXQiLCJlbmNvZGVPbmVCaW5hcnlQYWNrZXQiLCJwIiwib25CaW5hcnlQYWNrZXRFbmNvZGUiLCJlbmNvZGluZ0xlbmd0aCIsInNpemVCdWZmZXIiLCJwYXJzZUludCIsImJ1ZmZlclRhaWwiLCJidWZmZXJzIiwic3RyTGVuIiwiaXNTdHJpbmciLCJtc2dMZW5ndGgiLCJwdXNoIiwidG90YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/parser-v3/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/parser-v3/utf8.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/utf8.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/*! https://mths.be/utf8js v2.1.2 by @mathias */ var stringFromCharCode = String.fromCharCode;\n// Taken from https://mths.be/punycode\nfunction ucs2decode(string) {\n    var output = [];\n    var counter = 0;\n    var length = string.length;\n    var value;\n    var extra;\n    while(counter < length){\n        value = string.charCodeAt(counter++);\n        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n            // high surrogate, and there is a next character\n            extra = string.charCodeAt(counter++);\n            if ((extra & 0xFC00) == 0xDC00) {\n                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n            } else {\n                // unmatched surrogate; only append this code unit, in case the next\n                // code unit is the high surrogate of a surrogate pair\n                output.push(value);\n                counter--;\n            }\n        } else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n// Taken from https://mths.be/punycode\nfunction ucs2encode(array) {\n    var length = array.length;\n    var index = -1;\n    var value;\n    var output = \"\";\n    while(++index < length){\n        value = array[index];\n        if (value > 0xFFFF) {\n            value -= 0x10000;\n            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n            value = 0xDC00 | value & 0x3FF;\n        }\n        output += stringFromCharCode(value);\n    }\n    return output;\n}\nfunction checkScalarValue(codePoint, strict) {\n    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n        if (strict) {\n            throw Error(\"Lone surrogate U+\" + codePoint.toString(16).toUpperCase() + \" is not a scalar value\");\n        }\n        return false;\n    }\n    return true;\n}\n/*--------------------------------------------------------------------------*/ function createByte(codePoint, shift) {\n    return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);\n}\nfunction encodeCodePoint(codePoint, strict) {\n    if ((codePoint & 0xFFFFFF80) == 0) {\n        return stringFromCharCode(codePoint);\n    }\n    var symbol = \"\";\n    if ((codePoint & 0xFFFFF800) == 0) {\n        symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);\n    } else if ((codePoint & 0xFFFF0000) == 0) {\n        if (!checkScalarValue(codePoint, strict)) {\n            codePoint = 0xFFFD;\n        }\n        symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);\n        symbol += createByte(codePoint, 6);\n    } else if ((codePoint & 0xFFE00000) == 0) {\n        symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);\n        symbol += createByte(codePoint, 12);\n        symbol += createByte(codePoint, 6);\n    }\n    symbol += stringFromCharCode(codePoint & 0x3F | 0x80);\n    return symbol;\n}\nfunction utf8encode(string, opts) {\n    opts = opts || {};\n    var strict = false !== opts.strict;\n    var codePoints = ucs2decode(string);\n    var length = codePoints.length;\n    var index = -1;\n    var codePoint;\n    var byteString = \"\";\n    while(++index < length){\n        codePoint = codePoints[index];\n        byteString += encodeCodePoint(codePoint, strict);\n    }\n    return byteString;\n}\n/*--------------------------------------------------------------------------*/ function readContinuationByte() {\n    if (byteIndex >= byteCount) {\n        throw Error(\"Invalid byte index\");\n    }\n    var continuationByte = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n    if ((continuationByte & 0xC0) == 0x80) {\n        return continuationByte & 0x3F;\n    }\n    // If we end up here, its not a continuation byte\n    throw Error(\"Invalid continuation byte\");\n}\nfunction decodeSymbol(strict) {\n    var byte1;\n    var byte2;\n    var byte3;\n    var byte4;\n    var codePoint;\n    if (byteIndex > byteCount) {\n        throw Error(\"Invalid byte index\");\n    }\n    if (byteIndex == byteCount) {\n        return false;\n    }\n    // Read first byte\n    byte1 = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n    // 1-byte sequence (no continuation bytes)\n    if ((byte1 & 0x80) == 0) {\n        return byte1;\n    }\n    // 2-byte sequence\n    if ((byte1 & 0xE0) == 0xC0) {\n        byte2 = readContinuationByte();\n        codePoint = (byte1 & 0x1F) << 6 | byte2;\n        if (codePoint >= 0x80) {\n            return codePoint;\n        } else {\n            throw Error(\"Invalid continuation byte\");\n        }\n    }\n    // 3-byte sequence (may include unpaired surrogates)\n    if ((byte1 & 0xF0) == 0xE0) {\n        byte2 = readContinuationByte();\n        byte3 = readContinuationByte();\n        codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;\n        if (codePoint >= 0x0800) {\n            return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;\n        } else {\n            throw Error(\"Invalid continuation byte\");\n        }\n    }\n    // 4-byte sequence\n    if ((byte1 & 0xF8) == 0xF0) {\n        byte2 = readContinuationByte();\n        byte3 = readContinuationByte();\n        byte4 = readContinuationByte();\n        codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;\n        if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n            return codePoint;\n        }\n    }\n    throw Error(\"Invalid UTF-8 detected\");\n}\nvar byteArray;\nvar byteCount;\nvar byteIndex;\nfunction utf8decode(byteString, opts) {\n    opts = opts || {};\n    var strict = false !== opts.strict;\n    byteArray = ucs2decode(byteString);\n    byteCount = byteArray.length;\n    byteIndex = 0;\n    var codePoints = [];\n    var tmp;\n    while((tmp = decodeSymbol(strict)) !== false){\n        codePoints.push(tmp);\n    }\n    return ucs2encode(codePoints);\n}\nmodule.exports = {\n    version: \"2.1.2\",\n    encode: utf8encode,\n    decode: utf8decode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3BhcnNlci12My91dGY4LmpzP2E5ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMS4yIGJ5IEBtYXRoaWFzICovXG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBleHRyYTtcbiAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID4gMHhGRkZGKSB7XG4gICAgICAgICAgICB2YWx1ZSAtPSAweDEwMDAwO1xuICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICAgICAgICB2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG4gICAgaWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuICAgIHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuICAgIGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgcmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgIH1cbiAgICB2YXIgc3ltYm9sID0gJyc7XG4gICAgaWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuICAgICAgICBzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gMHhGRkZEO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgc3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG4gICAgICAgIHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuICAgIH1cbiAgICBzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuICAgIHJldHVybiBzeW1ib2w7XG59XG5mdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG4gICAgdmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG4gICAgdmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgdmFyIGJ5dGVTdHJpbmcgPSAnJztcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcbiAgICAgICAgYnl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZVN0cmluZztcbn1cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG4gICAgaWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuICAgIH1cbiAgICB2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcbiAgICBieXRlSW5kZXgrKztcbiAgICBpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcbiAgICB9XG4gICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5mdW5jdGlvbiBkZWNvZGVTeW1ib2woc3RyaWN0KSB7XG4gICAgdmFyIGJ5dGUxO1xuICAgIHZhciBieXRlMjtcbiAgICB2YXIgYnl0ZTM7XG4gICAgdmFyIGJ5dGU0O1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgaWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG4gICAgfVxuICAgIGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUmVhZCBmaXJzdCBieXRlXG4gICAgYnl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG4gICAgYnl0ZUluZGV4Kys7XG4gICAgLy8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG4gICAgaWYgKChieXRlMSAmIDB4ODApID09IDApIHtcbiAgICAgICAgcmV0dXJuIGJ5dGUxO1xuICAgIH1cbiAgICAvLyAyLWJ5dGUgc2VxdWVuY2VcbiAgICBpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4ODApIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcbiAgICBpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgY29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA0LWJ5dGUgc2VxdWVuY2VcbiAgICBpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgYnl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuICAgICAgICAgICAgKGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZVBvaW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG59XG52YXIgYnl0ZUFycmF5O1xudmFyIGJ5dGVDb3VudDtcbnZhciBieXRlSW5kZXg7XG5mdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuICAgIGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG4gICAgYnl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcbiAgICBieXRlSW5kZXggPSAwO1xuICAgIHZhciBjb2RlUG9pbnRzID0gW107XG4gICAgdmFyIHRtcDtcbiAgICB3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbChzdHJpY3QpKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29kZVBvaW50cy5wdXNoKHRtcCk7XG4gICAgfVxuICAgIHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdmVyc2lvbjogJzIuMS4yJyxcbiAgICBlbmNvZGU6IHV0ZjhlbmNvZGUsXG4gICAgZGVjb2RlOiB1dGY4ZGVjb2RlXG59O1xuIl0sIm5hbWVzIjpbInN0cmluZ0Zyb21DaGFyQ29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInVjczJkZWNvZGUiLCJzdHJpbmciLCJvdXRwdXQiLCJjb3VudGVyIiwibGVuZ3RoIiwidmFsdWUiLCJleHRyYSIsImNoYXJDb2RlQXQiLCJwdXNoIiwidWNzMmVuY29kZSIsImFycmF5IiwiaW5kZXgiLCJjaGVja1NjYWxhclZhbHVlIiwiY29kZVBvaW50Iiwic3RyaWN0IiwiRXJyb3IiLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwiY3JlYXRlQnl0ZSIsInNoaWZ0IiwiZW5jb2RlQ29kZVBvaW50Iiwic3ltYm9sIiwidXRmOGVuY29kZSIsIm9wdHMiLCJjb2RlUG9pbnRzIiwiYnl0ZVN0cmluZyIsInJlYWRDb250aW51YXRpb25CeXRlIiwiYnl0ZUluZGV4IiwiYnl0ZUNvdW50IiwiY29udGludWF0aW9uQnl0ZSIsImJ5dGVBcnJheSIsImRlY29kZVN5bWJvbCIsImJ5dGUxIiwiYnl0ZTIiLCJieXRlMyIsImJ5dGU0IiwidXRmOGRlY29kZSIsInRtcCIsIm1vZHVsZSIsImV4cG9ydHMiLCJ2ZXJzaW9uIiwiZW5jb2RlIiwiZGVjb2RlIl0sIm1hcHBpbmdzIjoiQUFBQSw4Q0FBOEMsR0FDOUMsSUFBSUEscUJBQXFCQyxPQUFPQyxZQUFZO0FBQzVDLHNDQUFzQztBQUN0QyxTQUFTQyxXQUFXQyxNQUFNO0lBQ3RCLElBQUlDLFNBQVMsRUFBRTtJQUNmLElBQUlDLFVBQVU7SUFDZCxJQUFJQyxTQUFTSCxPQUFPRyxNQUFNO0lBQzFCLElBQUlDO0lBQ0osSUFBSUM7SUFDSixNQUFPSCxVQUFVQyxPQUFRO1FBQ3JCQyxRQUFRSixPQUFPTSxVQUFVLENBQUNKO1FBQzFCLElBQUlFLFNBQVMsVUFBVUEsU0FBUyxVQUFVRixVQUFVQyxRQUFRO1lBQ3hELGdEQUFnRDtZQUNoREUsUUFBUUwsT0FBT00sVUFBVSxDQUFDSjtZQUMxQixJQUFJLEFBQUNHLENBQUFBLFFBQVEsTUFBSyxLQUFNLFFBQVE7Z0JBQzVCSixPQUFPTSxJQUFJLENBQUMsQUFBQyxDQUFBLEFBQUNILENBQUFBLFFBQVEsS0FBSSxLQUFNLEVBQUMsSUFBTUMsQ0FBQUEsUUFBUSxLQUFJLElBQUs7WUFD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QUFZQSxhQUFhLFVBQVU7WUFDaEQsT0FBT0E7UUFDWDtJQUNKO0lBQ0EsTUFBTUUsTUFBTTtBQUNoQjtBQUNBLElBQUllO0FBQ0osSUFBSUY7QUFDSixJQUFJRDtBQUNKLFNBQVNTLFdBQVdYLFVBQVUsRUFBRUYsSUFBSTtJQUNoQ0EsT0FBT0EsUUFBUSxDQUFDO0lBQ2hCLElBQUlULFNBQVMsVUFBVVMsS0FBS1QsTUFBTTtJQUNsQ2dCLFlBQVk5QixXQUFXeUI7SUFDdkJHLFlBQVlFLFVBQVUxQixNQUFNO0lBQzVCdUIsWUFBWTtJQUNaLElBQUlILGFBQWEsRUFBRTtJQUNuQixJQUFJYTtJQUNKLE1BQU8sQUFBQ0EsQ0FBQUEsTUFBTU4sYUFBYWpCLE9BQU0sTUFBTyxNQUFPO1FBQzNDVSxXQUFXaEIsSUFBSSxDQUFDNkI7SUFDcEI7SUFDQSxPQUFPNUIsV0FBV2U7QUFDdEI7QUFDQWMsT0FBT0MsT0FBTyxHQUFHO0lBQ2JDLFNBQVM7SUFDVEMsUUFBUW5CO0lBQ1JvQixRQUFRTjtBQUNaIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9wYXJzZXItdjMvdXRmOC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/parser-v3/utf8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/server.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = exports.BaseServer = void 0;\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst base64id = __webpack_require__(/*! base64id */ \"(rsc)/./node_modules/base64id/lib/base64id.js\");\nconst transports_1 = __webpack_require__(/*! ./transports */ \"(rsc)/./node_modules/engine.io/build/transports/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/engine.io/build/socket.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst cookie_1 = __webpack_require__(/*! cookie */ \"(rsc)/./node_modules/cookie/index.js\");\nconst ws_1 = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/index.js\");\nconst webtransport_1 = __webpack_require__(/*! ./transports/webtransport */ \"(rsc)/./node_modules/engine.io/build/transports/webtransport.js\");\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nconst debug = (0, debug_1.default)(\"engine\");\nconst kResponseHeaders = Symbol(\"responseHeaders\");\nfunction parseSessionId(data) {\n    try {\n        const parsed = JSON.parse(data);\n        if (typeof parsed.sid === \"string\") {\n            return parsed.sid;\n        }\n    } catch (e) {}\n}\nclass BaseServer extends events_1.EventEmitter {\n    /**\n     * Server constructor.\n     *\n     * @param {Object} opts - options\n     */ constructor(opts = {}){\n        super();\n        this.middlewares = [];\n        this.clients = {};\n        this.clientsCount = 0;\n        this.opts = Object.assign({\n            wsEngine: ws_1.Server,\n            pingTimeout: 20000,\n            pingInterval: 25000,\n            upgradeTimeout: 10000,\n            maxHttpBufferSize: 1e6,\n            transports: [\n                \"polling\",\n                \"websocket\"\n            ],\n            allowUpgrades: true,\n            httpCompression: {\n                threshold: 1024\n            },\n            cors: false,\n            allowEIO3: false\n        }, opts);\n        if (opts.cookie) {\n            this.opts.cookie = Object.assign({\n                name: \"io\",\n                path: \"/\",\n                // @ts-ignore\n                httpOnly: opts.cookie.path !== false,\n                sameSite: \"lax\"\n            }, opts.cookie);\n        }\n        if (this.opts.cors) {\n            this.use(__webpack_require__(/*! cors */ \"(rsc)/./node_modules/cors/lib/index.js\")(this.opts.cors));\n        }\n        if (opts.perMessageDeflate) {\n            this.opts.perMessageDeflate = Object.assign({\n                threshold: 1024\n            }, opts.perMessageDeflate);\n        }\n        this.init();\n    }\n    /**\n     * Compute the pathname of the requests that are handled by the server\n     * @param options\n     * @protected\n     */ _computePath(options) {\n        let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n        if (options.addTrailingSlash !== false) {\n            // normalize path\n            path += \"/\";\n        }\n        return path;\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     */ upgrades(transport) {\n        if (!this.opts.allowUpgrades) return [];\n        return transports_1.default[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {EngineRequest} req\n     * @param upgrade - whether it's an upgrade request\n     * @param fn\n     * @protected\n     */ verify(req, upgrade, fn) {\n        // transport check\n        const transport = req._query.transport;\n        // WebTransport does not go through the verify() method, see the onWebTransportSession() method\n        if (!~this.opts.transports.indexOf(transport) || transport === \"webtransport\") {\n            debug('unknown transport \"%s\"', transport);\n            return fn(Server.errors.UNKNOWN_TRANSPORT, {\n                transport\n            });\n        }\n        // 'Origin' header check\n        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n        if (isOriginInvalid) {\n            const origin = req.headers.origin;\n            req.headers.origin = null;\n            debug(\"origin header invalid\");\n            return fn(Server.errors.BAD_REQUEST, {\n                name: \"INVALID_ORIGIN\",\n                origin\n            });\n        }\n        // sid check\n        const sid = req._query.sid;\n        if (sid) {\n            if (!this.clients.hasOwnProperty(sid)) {\n                debug('unknown sid \"%s\"', sid);\n                return fn(Server.errors.UNKNOWN_SID, {\n                    sid\n                });\n            }\n            const previousTransport = this.clients[sid].transport.name;\n            if (!upgrade && previousTransport !== transport) {\n                debug(\"bad request: unexpected transport without upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_MISMATCH\",\n                    transport,\n                    previousTransport\n                });\n            }\n        } else {\n            // handshake is GET only\n            if (\"GET\" !== req.method) {\n                return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n                    method: req.method\n                });\n            }\n            if (transport === \"websocket\" && !upgrade) {\n                debug(\"invalid transport upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\"\n                });\n            }\n            if (!this.opts.allowRequest) return fn();\n            return this.opts.allowRequest(req, (message, success)=>{\n                if (!success) {\n                    return fn(Server.errors.FORBIDDEN, {\n                        message\n                    });\n                }\n                fn();\n            });\n        }\n        fn();\n    }\n    /**\n     * Adds a new middleware.\n     *\n     * @example\n     * import helmet from \"helmet\";\n     *\n     * engine.use(helmet());\n     *\n     * @param fn\n     */ use(fn) {\n        this.middlewares.push(fn);\n    }\n    /**\n     * Apply the middlewares to the request.\n     *\n     * @param req\n     * @param res\n     * @param callback\n     * @protected\n     */ _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            debug(\"no middleware to apply, skipping\");\n            return callback();\n        }\n        const apply = (i)=>{\n            debug(\"applying middleware n\\xb0%d\", i + 1);\n            this.middlewares[i](req, res, (err)=>{\n                if (err) {\n                    return callback(err);\n                }\n                if (i + 1 < this.middlewares.length) {\n                    apply(i + 1);\n                } else {\n                    callback();\n                }\n            });\n        };\n        apply(0);\n    }\n    /**\n     * Closes all clients.\n     */ close() {\n        debug(\"closing all open clients\");\n        for(let i in this.clients){\n            if (this.clients.hasOwnProperty(i)) {\n                this.clients[i].close(true);\n            }\n        }\n        this.cleanup();\n        return this;\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {IncomingMessage} req - the request object\n     */ generateId(req) {\n        return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transportName\n     * @param {Object} req - the request object\n     * @param {Function} closeConnection\n     *\n     * @protected\n     */ async handshake(transportName, req, closeConnection) {\n        const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        if (protocol === 3 && !this.opts.allowEIO3) {\n            debug(\"unsupported protocol version\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                context: {\n                    protocol\n                }\n            });\n            closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n            return;\n        }\n        let id;\n        try {\n            id = await this.generateId(req);\n        } catch (e) {\n            debug(\"error while generating an id\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: e\n                }\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        debug('handshaking client \"%s\"', id);\n        try {\n            var transport = this.createTransport(transportName, req);\n            if (\"polling\" === transportName) {\n                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                transport.httpCompression = this.opts.httpCompression;\n            } else if (\"websocket\" === transportName) {\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n            }\n        } catch (e) {\n            debug('error handshaking to transport \"%s\"', transportName);\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: e\n                }\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        const socket = new socket_1.Socket(id, this, transport, req, protocol);\n        transport.on(\"headers\", (headers, req)=>{\n            const isInitialRequest = !req._query.sid;\n            if (isInitialRequest) {\n                if (this.opts.cookie) {\n                    headers[\"Set-Cookie\"] = [\n                        // @ts-ignore\n                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)\n                    ];\n                }\n                this.emit(\"initial_headers\", headers, req);\n            }\n            this.emit(\"headers\", headers, req);\n        });\n        transport.onRequest(req);\n        this.clients[id] = socket;\n        this.clientsCount++;\n        socket.once(\"close\", ()=>{\n            delete this.clients[id];\n            this.clientsCount--;\n        });\n        this.emit(\"connection\", socket);\n        return transport;\n    }\n    async onWebTransportSession(session) {\n        const timeout = setTimeout(()=>{\n            debug(\"the client failed to establish a bidirectional stream in the given period\");\n            session.close();\n        }, this.opts.upgradeTimeout);\n        const streamReader = session.incomingBidirectionalStreams.getReader();\n        const result = await streamReader.read();\n        if (result.done) {\n            debug(\"session is closed\");\n            return;\n        }\n        const stream = result.value;\n        const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, \"nodebuffer\");\n        const reader = stream.readable.pipeThrough(transformStream).getReader();\n        // reading the first packet of the stream\n        const { value, done } = await reader.read();\n        if (done) {\n            debug(\"stream is closed\");\n            return;\n        }\n        clearTimeout(timeout);\n        if (value.type !== \"open\") {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        if (value.data === undefined) {\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            // note: we cannot use \"this.generateId()\", because there is no \"req\" argument\n            const id = base64id.generateId();\n            debug('handshaking client \"%s\" (WebTransport)', id);\n            const socket = new socket_1.Socket(id, this, transport, null, 4);\n            this.clients[id] = socket;\n            this.clientsCount++;\n            socket.once(\"close\", ()=>{\n                delete this.clients[id];\n                this.clientsCount--;\n            });\n            this.emit(\"connection\", socket);\n            return;\n        }\n        const sid = parseSessionId(value.data);\n        if (!sid) {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        const client = this.clients[sid];\n        if (!client) {\n            debug(\"upgrade attempt for closed client\");\n            session.close();\n        } else if (client.upgrading) {\n            debug(\"transport has already been trying to upgrade\");\n            session.close();\n        } else if (client.upgraded) {\n            debug(\"transport had already been upgraded\");\n            session.close();\n        } else {\n            debug(\"upgrading existing transport\");\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            client._maybeUpgrade(transport);\n        }\n    }\n}\nexports.BaseServer = BaseServer;\n/**\n * Protocol errors mappings.\n */ BaseServer.errors = {\n    UNKNOWN_TRANSPORT: 0,\n    UNKNOWN_SID: 1,\n    BAD_HANDSHAKE_METHOD: 2,\n    BAD_REQUEST: 3,\n    FORBIDDEN: 4,\n    UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nBaseServer.errorMessages = {\n    0: \"Transport unknown\",\n    1: \"Session ID unknown\",\n    2: \"Bad handshake method\",\n    3: \"Bad request\",\n    4: \"Forbidden\",\n    5: \"Unsupported protocol version\"\n};\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */ class WebSocketResponse {\n    constructor(req, socket){\n        this.req = req;\n        this.socket = socket;\n        // temporarily store the response headers on the req object (see the \"headers\" event)\n        req[kResponseHeaders] = {};\n    }\n    setHeader(name, value) {\n        this.req[kResponseHeaders][name] = value;\n    }\n    getHeader(name) {\n        return this.req[kResponseHeaders][name];\n    }\n    removeHeader(name) {\n        delete this.req[kResponseHeaders][name];\n    }\n    write() {}\n    writeHead() {}\n    end() {\n        // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n        this.socket.destroy();\n    }\n}\n/**\n * An Engine.IO server based on Node.js built-in HTTP server and the `ws` package for WebSocket connections.\n */ class Server extends BaseServer {\n    /**\n     * Initialize websocket server\n     *\n     * @protected\n     */ init() {\n        if (!~this.opts.transports.indexOf(\"websocket\")) return;\n        if (this.ws) this.ws.close();\n        this.ws = new this.opts.wsEngine({\n            noServer: true,\n            clientTracking: false,\n            perMessageDeflate: this.opts.perMessageDeflate,\n            maxPayload: this.opts.maxHttpBufferSize\n        });\n        if (typeof this.ws.on === \"function\") {\n            this.ws.on(\"headers\", (headersArray, req)=>{\n                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n                // we could also try to parse the array and then sync the values, but that will be error-prone\n                const additionalHeaders = req[kResponseHeaders] || {};\n                delete req[kResponseHeaders];\n                const isInitialRequest = !req._query.sid;\n                if (isInitialRequest) {\n                    this.emit(\"initial_headers\", additionalHeaders, req);\n                }\n                this.emit(\"headers\", additionalHeaders, req);\n                debug(\"writing headers: %j\", additionalHeaders);\n                Object.keys(additionalHeaders).forEach((key)=>{\n                    headersArray.push(`${key}: ${additionalHeaders[key]}`);\n                });\n            });\n        }\n    }\n    cleanup() {\n        if (this.ws) {\n            debug(\"closing webSocketServer\");\n            this.ws.close();\n        // don't delete this.ws because it can be used again if the http server starts listening again\n        }\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @private\n     */ prepare(req) {\n        // try to leverage pre-existing `req._query` (e.g: from connect)\n        if (!req._query) {\n            req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n        }\n    }\n    createTransport(transportName, req) {\n        return new transports_1.default[transportName](req);\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {EngineRequest} req\n     * @param {ServerResponse} res\n     */ handleRequest(req, res) {\n        debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n        this.prepare(req);\n        req.res = res;\n        const callback = (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                this.clients[req._query.sid].transport.onRequest(req);\n            } else {\n                const closeConnection = (errorCode, errorContext)=>abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     */ handleUpgrade(req, socket, upgradeHead) {\n        this.prepare(req);\n        const res = new WebSocketResponse(req, socket);\n        const callback = (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                abortUpgrade(socket, errorCode, errorContext);\n                return;\n            }\n            const head = Buffer.from(upgradeHead);\n            upgradeHead = null;\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            res.writeHead();\n            // delegate to ws\n            this.ws.handleUpgrade(req, socket, head, (websocket)=>{\n                this.onWebSocket(req, socket, websocket);\n            });\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @private\n     */ onWebSocket(req, socket, websocket) {\n        websocket.on(\"error\", onUpgradeError);\n        if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n            debug(\"transport doesnt handle upgraded requests\");\n            websocket.close();\n            return;\n        }\n        // get client id\n        const id = req._query.sid;\n        // keep a reference to the ws.Socket\n        req.websocket = websocket;\n        if (id) {\n            const client = this.clients[id];\n            if (!client) {\n                debug(\"upgrade attempt for closed client\");\n                websocket.close();\n            } else if (client.upgrading) {\n                debug(\"transport has already been trying to upgrade\");\n                websocket.close();\n            } else if (client.upgraded) {\n                debug(\"transport had already been upgraded\");\n                websocket.close();\n            } else {\n                debug(\"upgrading existing transport\");\n                // transport error handling takes over\n                websocket.removeListener(\"error\", onUpgradeError);\n                const transport = this.createTransport(req._query.transport, req);\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n                client._maybeUpgrade(transport);\n            }\n        } else {\n            const closeConnection = (errorCode, errorContext)=>abortUpgrade(socket, errorCode, errorContext);\n            this.handshake(req._query.transport, req, closeConnection);\n        }\n        function onUpgradeError() {\n            debug(\"websocket error before upgrade\");\n        // websocket.close() not needed\n        }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     */ attach(server, options = {}) {\n        const path = this._computePath(options);\n        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n        function check(req) {\n            // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n            return path === req.url.slice(0, path.length);\n        }\n        // cache and clean up listeners\n        const listeners = server.listeners(\"request\").slice(0);\n        server.removeAllListeners(\"request\");\n        server.on(\"close\", this.close.bind(this));\n        server.on(\"listening\", this.init.bind(this));\n        // add request handler\n        server.on(\"request\", (req, res)=>{\n            if (check(req)) {\n                debug('intercepting request for path \"%s\"', path);\n                this.handleRequest(req, res);\n            } else {\n                let i = 0;\n                const l = listeners.length;\n                for(; i < l; i++){\n                    listeners[i].call(server, req, res);\n                }\n            }\n        });\n        if (~this.opts.transports.indexOf(\"websocket\")) {\n            server.on(\"upgrade\", (req, socket, head)=>{\n                if (check(req)) {\n                    this.handleUpgrade(req, socket, head);\n                } else if (false !== options.destroyUpgrade) {\n                    // default node behavior is to disconnect when no handlers\n                    // but by adding a handler, we prevent that\n                    // and if no eio thing handles the upgrade\n                    // then the socket needs to die!\n                    setTimeout(function() {\n                        // @ts-ignore\n                        if (socket.writable && socket.bytesWritten <= 0) {\n                            socket.on(\"error\", (e)=>{\n                                debug(\"error while destroying upgrade: %s\", e.message);\n                            });\n                            return socket.end();\n                        }\n                    }, destroyUpgradeTimeout);\n                }\n            });\n        }\n    }\n}\nexports.Server = Server;\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @private\n */ function abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n    const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n    res.writeHead(statusCode, {\n        \"Content-Type\": \"application/json\"\n    });\n    res.end(JSON.stringify({\n        code: errorCode,\n        message\n    }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n */ function abortUpgrade(socket, errorCode, errorContext = {}) {\n    socket.on(\"error\", ()=>{\n        debug(\"ignoring error from closed connection\");\n    });\n    if (socket.writable) {\n        const message = errorContext.message || Server.errorMessages[errorCode];\n        const length = Buffer.byteLength(message);\n        socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n    }\n    socket.destroy();\n}\n/* eslint-disable */ /**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/ // prettier-ignore\nconst validHdrChars = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1 // ... 255\n];\nfunction checkInvalidHeaderChar(val) {\n    val += \"\";\n    if (val.length < 1) return false;\n    if (!validHdrChars[val.charCodeAt(0)]) {\n        debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n        return true;\n    }\n    if (val.length < 2) return false;\n    if (!validHdrChars[val.charCodeAt(1)]) {\n        debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n        return true;\n    }\n    if (val.length < 3) return false;\n    if (!validHdrChars[val.charCodeAt(2)]) {\n        debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n        return true;\n    }\n    if (val.length < 4) return false;\n    if (!validHdrChars[val.charCodeAt(3)]) {\n        debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n        return true;\n    }\n    for(let i = 4; i < val.length; ++i){\n        if (!validHdrChars[val.charCodeAt(i)]) {\n            debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3NlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQzNDLE1BQU1JLEtBQUtDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ2hDLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLCtEQUFVO0FBQ25DLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDLDhFQUFjO0FBQzNDLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1LLFdBQVdMLG1CQUFPQSxDQUFDLGdFQUFVO0FBQ25DLE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1PLFdBQVdQLG1CQUFPQSxDQUFDLG9EQUFRO0FBQ2pDLE1BQU1RLE9BQU9SLG1CQUFPQSxDQUFDLDRDQUFJO0FBQ3pCLE1BQU1TLGlCQUFpQlQsbUJBQU9BLENBQUMsa0dBQTJCO0FBQzFELE1BQU1VLHFCQUFxQlYsbUJBQU9BLENBQUMsa0ZBQWtCO0FBQ3JELE1BQU1XLFFBQVEsQ0FBQyxHQUFHTCxRQUFRTSxPQUFPLEVBQUU7QUFDbkMsTUFBTUMsbUJBQW1CQyxPQUFPO0FBQ2hDLFNBQVNDLGVBQWVDLElBQUk7SUFDeEIsSUFBSTtRQUNBLE1BQU1DLFNBQVNDLEtBQUtDLEtBQUssQ0FBQ0g7UUFDMUIsSUFBSSxPQUFPQyxPQUFPRyxHQUFHLEtBQUssVUFBVTtZQUNoQyxPQUFPSCxPQUFPRyxHQUFHO1FBQ3JCO0lBQ0osRUFDQSxPQUFPQyxHQUFHLENBQUU7QUFDaEI7QUFDQSxNQUFNdkIsbUJBQW1CTSxTQUFTa0IsWUFBWTtJQUMxQzs7OztLQUlDLEdBQ0RDLFlBQVlDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FB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O0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHLEVBQUUsVUFBVTtDQUM1RDtBQUNELFNBQVN4SCx1QkFBdUJ5SCxHQUFHO0lBQy9CQSxPQUFPO0lBQ1AsSUFBSUEsSUFBSXhHLE1BQU0sR0FBRyxHQUNiLE9BQU87SUFDWCxJQUFJLENBQUN1RyxhQUFhLENBQUNDLElBQUlDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDbkMvSyxNQUFNLHNDQUFzQzhLLElBQUlDLFVBQVUsQ0FBQztRQUMzRCxPQUFPO0lBQ1g7SUFDQSxJQUFJRCxJQUFJeEcsTUFBTSxHQUFHLEdBQ2IsT0FBTztJQUNYLElBQUksQ0FBQ3VHLGFBQWEsQ0FBQ0MsSUFBSUMsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNuQy9LLE1BQU0sc0NBQXNDOEssSUFBSUMsVUFBVSxDQUFDO1FBQzNELE9BQU87SUFDWDtJQUNBLElBQUlELElBQUl4RyxNQUFNLEdBQUcsR0FDYixPQUFPO0lBQ1gsSUFBSSxDQUFDdUcsYUFBYSxDQUFDQyxJQUFJQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ25DL0ssTUFBTSxzQ0FBc0M4SyxJQUFJQyxVQUFVLENBQUM7UUFDM0QsT0FBTztJQUNYO0lBQ0EsSUFBSUQsSUFBSXhHLE1BQU0sR0FBRyxHQUNiLE9BQU87SUFDWCxJQUFJLENBQUN1RyxhQUFhLENBQUNDLElBQUlDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDbkMvSyxNQUFNLHNDQUFzQzhLLElBQUlDLFVBQVUsQ0FBQztRQUMzRCxPQUFPO0lBQ1g7SUFDQSxJQUFLLElBQUl2RyxJQUFJLEdBQUdBLElBQUlzRyxJQUFJeEcsTUFBTSxFQUFFLEVBQUVFLEVBQUc7UUFDakMsSUFBSSxDQUFDcUcsYUFBYSxDQUFDQyxJQUFJQyxVQUFVLENBQUN2RyxHQUFHLEVBQUU7WUFDbkN4RSxNQUFNLHlDQUF5Q3dFLEdBQUdzRyxJQUFJQyxVQUFVLENBQUN2RztZQUNqRSxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3Jhdm9jaGF0LWFwcC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvc2VydmVyLmpzPzY1OWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlciA9IGV4cG9ydHMuQmFzZVNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IHFzID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgYmFzZTY0aWQgPSByZXF1aXJlKFwiYmFzZTY0aWRcIik7XG5jb25zdCB0cmFuc3BvcnRzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3Qgc29ja2V0XzEgPSByZXF1aXJlKFwiLi9zb2NrZXRcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgY29va2llXzEgPSByZXF1aXJlKFwiY29va2llXCIpO1xuY29uc3Qgd3NfMSA9IHJlcXVpcmUoXCJ3c1wiKTtcbmNvbnN0IHdlYnRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy93ZWJ0cmFuc3BvcnRcIik7XG5jb25zdCBlbmdpbmVfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmVcIik7XG5jb25zdCBrUmVzcG9uc2VIZWFkZXJzID0gU3ltYm9sKFwicmVzcG9uc2VIZWFkZXJzXCIpO1xuZnVuY3Rpb24gcGFyc2VTZXNzaW9uSWQoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyc2VkLnNpZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC5zaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxufVxuY2xhc3MgQmFzZVNlcnZlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogU2VydmVyIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jbGllbnRzID0ge307XG4gICAgICAgIHRoaXMuY2xpZW50c0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB3c0VuZ2luZTogd3NfMS5TZXJ2ZXIsXG4gICAgICAgICAgICBwaW5nVGltZW91dDogMjAwMDAsXG4gICAgICAgICAgICBwaW5nSW50ZXJ2YWw6IDI1MDAwLFxuICAgICAgICAgICAgdXBncmFkZVRpbWVvdXQ6IDEwMDAwLFxuICAgICAgICAgICAgbWF4SHR0cEJ1ZmZlclNpemU6IDFlNixcbiAgICAgICAgICAgIHRyYW5zcG9ydHM6IFtcInBvbGxpbmdcIiwgXCJ3ZWJzb2NrZXRcIl0sIC8vIFdlYlRyYW5zcG9ydCBpcyBkaXNhYmxlZCBieSBkZWZhdWx0XG4gICAgICAgICAgICBhbGxvd1VwZ3JhZGVzOiB0cnVlLFxuICAgICAgICAgICAgaHR0cENvbXByZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxMDI0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvcnM6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dFSU8zOiBmYWxzZSxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIGlmIChvcHRzLmNvb2tpZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRzLmNvb2tpZSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiaW9cIixcbiAgICAgICAgICAgICAgICBwYXRoOiBcIi9cIixcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaHR0cE9ubHk6IG9wdHMuY29va2llLnBhdGggIT09IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNhbWVTaXRlOiBcImxheFwiLFxuICAgICAgICAgICAgfSwgb3B0cy5jb29raWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29ycykge1xuICAgICAgICAgICAgdGhpcy51c2UocmVxdWlyZShcImNvcnNcIikodGhpcy5vcHRzLmNvcnMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxMDI0LFxuICAgICAgICAgICAgfSwgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHBhdGhuYW1lIG9mIHRoZSByZXF1ZXN0cyB0aGF0IGFyZSBoYW5kbGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY29tcHV0ZVBhdGgob3B0aW9ucykge1xuICAgICAgICBsZXQgcGF0aCA9IChvcHRpb25zLnBhdGggfHwgXCIvZW5naW5lLmlvXCIpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWRkVHJhaWxpbmdTbGFzaCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBwYXRoXG4gICAgICAgICAgICBwYXRoICs9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBmb3IgdXBncmFkZSBnaXZlbiBhIGNlcnRhaW4gdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgdXBncmFkZXModHJhbnNwb3J0KSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRzLmFsbG93VXBncmFkZXMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnRzXzEuZGVmYXVsdFt0cmFuc3BvcnRdLnVwZ3JhZGVzVG8gfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5naW5lUmVxdWVzdH0gcmVxXG4gICAgICogQHBhcmFtIHVwZ3JhZGUgLSB3aGV0aGVyIGl0J3MgYW4gdXBncmFkZSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGZuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHZlcmlmeShyZXEsIHVwZ3JhZGUsIGZuKSB7XG4gICAgICAgIC8vIHRyYW5zcG9ydCBjaGVja1xuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSByZXEuX3F1ZXJ5LnRyYW5zcG9ydDtcbiAgICAgICAgLy8gV2ViVHJhbnNwb3J0IGRvZXMgbm90IGdvIHRocm91Z2ggdGhlIHZlcmlmeSgpIG1ldGhvZCwgc2VlIHRoZSBvbldlYlRyYW5zcG9ydFNlc3Npb24oKSBtZXRob2RcbiAgICAgICAgaWYgKCF+dGhpcy5vcHRzLnRyYW5zcG9ydHMuaW5kZXhPZih0cmFuc3BvcnQpIHx8XG4gICAgICAgICAgICB0cmFuc3BvcnQgPT09IFwid2VidHJhbnNwb3J0XCIpIHtcbiAgICAgICAgICAgIGRlYnVnKCd1bmtub3duIHRyYW5zcG9ydCBcIiVzXCInLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuVU5LTk9XTl9UUkFOU1BPUlQsIHsgdHJhbnNwb3J0IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vICdPcmlnaW4nIGhlYWRlciBjaGVja1xuICAgICAgICBjb25zdCBpc09yaWdpbkludmFsaWQgPSBjaGVja0ludmFsaWRIZWFkZXJDaGFyKHJlcS5oZWFkZXJzLm9yaWdpbik7XG4gICAgICAgIGlmIChpc09yaWdpbkludmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IHJlcS5oZWFkZXJzLm9yaWdpbjtcbiAgICAgICAgICAgIHJlcS5oZWFkZXJzLm9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgICBkZWJ1ZyhcIm9yaWdpbiBoZWFkZXIgaW52YWxpZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJJTlZBTElEX09SSUdJTlwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNpZCBjaGVja1xuICAgICAgICBjb25zdCBzaWQgPSByZXEuX3F1ZXJ5LnNpZDtcbiAgICAgICAgaWYgKHNpZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuaGFzT3duUHJvcGVydHkoc2lkKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCd1bmtub3duIHNpZCBcIiVzXCInLCBzaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLlVOS05PV05fU0lELCB7XG4gICAgICAgICAgICAgICAgICAgIHNpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVHJhbnNwb3J0ID0gdGhpcy5jbGllbnRzW3NpZF0udHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgICAgICBpZiAoIXVwZ3JhZGUgJiYgcHJldmlvdXNUcmFuc3BvcnQgIT09IHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiYmFkIHJlcXVlc3Q6IHVuZXhwZWN0ZWQgdHJhbnNwb3J0IHdpdGhvdXQgdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRSQU5TUE9SVF9NSVNNQVRDSFwiLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZHNoYWtlIGlzIEdFVCBvbmx5XG4gICAgICAgICAgICBpZiAoXCJHRVRcIiAhPT0gcmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkJBRF9IQU5EU0hBS0VfTUVUSE9ELCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgPT09IFwid2Vic29ja2V0XCIgJiYgIXVwZ3JhZGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImludmFsaWQgdHJhbnNwb3J0IHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJUUkFOU1BPUlRfSEFORFNIQUtFX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0cy5hbGxvd1JlcXVlc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRzLmFsbG93UmVxdWVzdChyZXEsIChtZXNzYWdlLCBzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkZPUkJJRERFTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IG1pZGRsZXdhcmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCBoZWxtZXQgZnJvbSBcImhlbG1ldFwiO1xuICAgICAqXG4gICAgICogZW5naW5lLnVzZShoZWxtZXQoKSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm5cbiAgICAgKi9cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlcy5wdXNoKGZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIG1pZGRsZXdhcmVzIHRvIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqIEBwYXJhbSByZXNcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2FwcGx5TWlkZGxld2FyZXMocmVxLCByZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1pZGRsZXdhcmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVidWcoXCJubyBtaWRkbGV3YXJlIHRvIGFwcGx5LCBza2lwcGluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGx5ID0gKGkpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiYXBwbHlpbmcgbWlkZGxld2FyZSBuwrAlZFwiLCBpICsgMSk7XG4gICAgICAgICAgICB0aGlzLm1pZGRsZXdhcmVzW2ldKHJlcSwgcmVzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgdGhpcy5taWRkbGV3YXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHkoaSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgYXBwbHkoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBhbGwgY2xpZW50cy5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nIGFsbCBvcGVuIGNsaWVudHNcIik7XG4gICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5jbGllbnRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnRzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRzW2ldLmNsb3NlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgYSBzb2NrZXQgaWQuXG4gICAgICogT3ZlcndyaXRlIHRoaXMgbWV0aG9kIHRvIGdlbmVyYXRlIHlvdXIgY3VzdG9tIHNvY2tldCBpZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbmNvbWluZ01lc3NhZ2V9IHJlcSAtIHRoZSByZXF1ZXN0IG9iamVjdFxuICAgICAqL1xuICAgIGdlbmVyYXRlSWQocmVxKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjRpZC5nZW5lcmF0ZUlkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRzaGFrZXMgYSBuZXcgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydE5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxIC0gdGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvc2VDb25uZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgaGFuZHNoYWtlKHRyYW5zcG9ydE5hbWUsIHJlcSwgY2xvc2VDb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmVxLl9xdWVyeS5FSU8gPT09IFwiNFwiID8gNCA6IDM7IC8vIDNyZCByZXZpc2lvbiBieSBkZWZhdWx0XG4gICAgICAgIGlmIChwcm90b2NvbCA9PT0gMyAmJiAhdGhpcy5vcHRzLmFsbG93RUlPMykge1xuICAgICAgICAgICAgZGVidWcoXCJ1bnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uXCIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIGNvZGU6IFNlcnZlci5lcnJvcnMuVU5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tTZXJ2ZXIuZXJyb3JzLlVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT05dLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xvc2VDb25uZWN0aW9uKFNlcnZlci5lcnJvcnMuVU5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWQgPSBhd2FpdCB0aGlzLmdlbmVyYXRlSWQocmVxKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVidWcoXCJlcnJvciB3aGlsZSBnZW5lcmF0aW5nIGFuIGlkXCIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIGNvZGU6IFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVF0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIklEX0dFTkVSQVRJT05fRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xvc2VDb25uZWN0aW9uKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdoYW5kc2hha2luZyBjbGllbnQgXCIlc1wiJywgaWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydE5hbWUsIHJlcSk7XG4gICAgICAgICAgICBpZiAoXCJwb2xsaW5nXCIgPT09IHRyYW5zcG9ydE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQubWF4SHR0cEJ1ZmZlclNpemUgPSB0aGlzLm9wdHMubWF4SHR0cEJ1ZmZlclNpemU7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0Lmh0dHBDb21wcmVzc2lvbiA9IHRoaXMub3B0cy5odHRwQ29tcHJlc3Npb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcIndlYnNvY2tldFwiID09PSB0cmFuc3BvcnROYW1lKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZygnZXJyb3IgaGFuZHNoYWtpbmcgdG8gdHJhbnNwb3J0IFwiJXNcIicsIHRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIGNvZGU6IFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVF0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRSQU5TUE9SVF9IQU5EU0hBS0VfRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xvc2VDb25uZWN0aW9uKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBzb2NrZXRfMS5Tb2NrZXQoaWQsIHRoaXMsIHRyYW5zcG9ydCwgcmVxLCBwcm90b2NvbCk7XG4gICAgICAgIHRyYW5zcG9ydC5vbihcImhlYWRlcnNcIiwgKGhlYWRlcnMsIHJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNJbml0aWFsUmVxdWVzdCA9ICFyZXEuX3F1ZXJ5LnNpZDtcbiAgICAgICAgICAgIGlmIChpc0luaXRpYWxSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jb29raWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tcIlNldC1Db29raWVcIl0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgY29va2llXzEuc2VyaWFsaXplKSh0aGlzLm9wdHMuY29va2llLm5hbWUsIGlkLCB0aGlzLm9wdHMuY29va2llKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaW5pdGlhbF9oZWFkZXJzXCIsIGhlYWRlcnMsIHJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJoZWFkZXJzXCIsIGhlYWRlcnMsIHJlcSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc3BvcnQub25SZXF1ZXN0KHJlcSk7XG4gICAgICAgIHRoaXMuY2xpZW50c1tpZF0gPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuY2xpZW50c0NvdW50Kys7XG4gICAgICAgIHNvY2tldC5vbmNlKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2xpZW50c1tpZF07XG4gICAgICAgICAgICB0aGlzLmNsaWVudHNDb3VudC0tO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvblwiLCBzb2NrZXQpO1xuICAgICAgICByZXR1cm4gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBvbldlYlRyYW5zcG9ydFNlc3Npb24oc2Vzc2lvbikge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRoZSBjbGllbnQgZmFpbGVkIHRvIGVzdGFibGlzaCBhIGJpZGlyZWN0aW9uYWwgc3RyZWFtIGluIHRoZSBnaXZlbiBwZXJpb2RcIik7XG4gICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIH0sIHRoaXMub3B0cy51cGdyYWRlVGltZW91dCk7XG4gICAgICAgIGNvbnN0IHN0cmVhbVJlYWRlciA9IHNlc3Npb24uaW5jb21pbmdCaWRpcmVjdGlvbmFsU3RyZWFtcy5nZXRSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RyZWFtUmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInNlc3Npb24gaXMgY2xvc2VkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3RyZWFtID0gKDAsIGVuZ2luZV9pb19wYXJzZXJfMS5jcmVhdGVQYWNrZXREZWNvZGVyU3RyZWFtKSh0aGlzLm9wdHMubWF4SHR0cEJ1ZmZlclNpemUsIFwibm9kZWJ1ZmZlclwiKTtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLnJlYWRhYmxlLnBpcGVUaHJvdWdoKHRyYW5zZm9ybVN0cmVhbSkuZ2V0UmVhZGVyKCk7XG4gICAgICAgIC8vIHJlYWRpbmcgdGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgc3RyZWFtXG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInN0cmVhbSBpcyBjbG9zZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaW52YWxpZCBXZWJUcmFuc3BvcnQgaGFuZHNoYWtlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgd2VidHJhbnNwb3J0XzEuV2ViVHJhbnNwb3J0KHNlc3Npb24sIHN0cmVhbSwgcmVhZGVyKTtcbiAgICAgICAgICAgIC8vIG5vdGU6IHdlIGNhbm5vdCB1c2UgXCJ0aGlzLmdlbmVyYXRlSWQoKVwiLCBiZWNhdXNlIHRoZXJlIGlzIG5vIFwicmVxXCIgYXJndW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGlkID0gYmFzZTY0aWQuZ2VuZXJhdGVJZCgpO1xuICAgICAgICAgICAgZGVidWcoJ2hhbmRzaGFraW5nIGNsaWVudCBcIiVzXCIgKFdlYlRyYW5zcG9ydCknLCBpZCk7XG4gICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgc29ja2V0XzEuU29ja2V0KGlkLCB0aGlzLCB0cmFuc3BvcnQsIG51bGwsIDQpO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRzW2lkXSA9IHNvY2tldDtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50c0NvdW50Kys7XG4gICAgICAgICAgICBzb2NrZXQub25jZShcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jbGllbnRzW2lkXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudHNDb3VudC0tO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lkID0gcGFyc2VTZXNzaW9uSWQodmFsdWUuZGF0YSk7XG4gICAgICAgIGlmICghc2lkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImludmFsaWQgV2ViVHJhbnNwb3J0IGhhbmRzaGFrZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzW3NpZF07XG4gICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGUgYXR0ZW1wdCBmb3IgY2xvc2VkIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkaW5nKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBoYXMgYWxyZWFkeSBiZWVuIHRyeWluZyB0byB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRlZCkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFkIGFscmVhZHkgYmVlbiB1cGdyYWRlZFwiKTtcbiAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwidXBncmFkaW5nIGV4aXN0aW5nIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyB3ZWJ0cmFuc3BvcnRfMS5XZWJUcmFuc3BvcnQoc2Vzc2lvbiwgc3RyZWFtLCByZWFkZXIpO1xuICAgICAgICAgICAgY2xpZW50Ll9tYXliZVVwZ3JhZGUodHJhbnNwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVNlcnZlciA9IEJhc2VTZXJ2ZXI7XG4vKipcbiAqIFByb3RvY29sIGVycm9ycyBtYXBwaW5ncy5cbiAqL1xuQmFzZVNlcnZlci5lcnJvcnMgPSB7XG4gICAgVU5LTk9XTl9UUkFOU1BPUlQ6IDAsXG4gICAgVU5LTk9XTl9TSUQ6IDEsXG4gICAgQkFEX0hBTkRTSEFLRV9NRVRIT0Q6IDIsXG4gICAgQkFEX1JFUVVFU1Q6IDMsXG4gICAgRk9SQklEREVOOiA0LFxuICAgIFVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT046IDUsXG59O1xuQmFzZVNlcnZlci5lcnJvck1lc3NhZ2VzID0ge1xuICAgIDA6IFwiVHJhbnNwb3J0IHVua25vd25cIixcbiAgICAxOiBcIlNlc3Npb24gSUQgdW5rbm93blwiLFxuICAgIDI6IFwiQmFkIGhhbmRzaGFrZSBtZXRob2RcIixcbiAgICAzOiBcIkJhZCByZXF1ZXN0XCIsXG4gICAgNDogXCJGb3JiaWRkZW5cIixcbiAgICA1OiBcIlVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb25cIixcbn07XG4vKipcbiAqIEV4cG9zZXMgYSBzdWJzZXQgb2YgdGhlIGh0dHAuU2VydmVyUmVzcG9uc2UgaW50ZXJmYWNlLCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIGFwcGx5IHRoZSBtaWRkbGV3YXJlcyB0byBhbiB1cGdyYWRlXG4gKiByZXF1ZXN0LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjY2xhc3MtaHR0cHNlcnZlcnJlc3BvbnNlXG4gKi9cbmNsYXNzIFdlYlNvY2tldFJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXEsIHNvY2tldCkge1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IHN0b3JlIHRoZSByZXNwb25zZSBoZWFkZXJzIG9uIHRoZSByZXEgb2JqZWN0IChzZWUgdGhlIFwiaGVhZGVyc1wiIGV2ZW50KVxuICAgICAgICByZXFba1Jlc3BvbnNlSGVhZGVyc10gPSB7fTtcbiAgICB9XG4gICAgc2V0SGVhZGVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVxW2tSZXNwb25zZUhlYWRlcnNdW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGdldEhlYWRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcVtrUmVzcG9uc2VIZWFkZXJzXVtuYW1lXTtcbiAgICB9XG4gICAgcmVtb3ZlSGVhZGVyKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVxW2tSZXNwb25zZUhlYWRlcnNdW25hbWVdO1xuICAgIH1cbiAgICB3cml0ZSgpIHsgfVxuICAgIHdyaXRlSGVhZCgpIHsgfVxuICAgIGVuZCgpIHtcbiAgICAgICAgLy8gd2UgY291bGQgcmV0dXJuIGEgcHJvcGVyIGVycm9yIGNvZGUsIGJ1dCB0aGUgV2ViU29ja2V0IGNsaWVudCB3aWxsIGVtaXQgYW4gXCJlcnJvclwiIGV2ZW50IGFueXdheS5cbiAgICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogQW4gRW5naW5lLklPIHNlcnZlciBiYXNlZCBvbiBOb2RlLmpzIGJ1aWx0LWluIEhUVFAgc2VydmVyIGFuZCB0aGUgYHdzYCBwYWNrYWdlIGZvciBXZWJTb2NrZXQgY29ubmVjdGlvbnMuXG4gKi9cbmNsYXNzIFNlcnZlciBleHRlbmRzIEJhc2VTZXJ2ZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgd2Vic29ja2V0IHNlcnZlclxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIGlmICghfnRoaXMub3B0cy50cmFuc3BvcnRzLmluZGV4T2YoXCJ3ZWJzb2NrZXRcIikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLndzKVxuICAgICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICB0aGlzLndzID0gbmV3IHRoaXMub3B0cy53c0VuZ2luZSh7XG4gICAgICAgICAgICBub1NlcnZlcjogdHJ1ZSxcbiAgICAgICAgICAgIGNsaWVudFRyYWNraW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLm9wdHMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdHMubWF4SHR0cEJ1ZmZlclNpemUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMud3Mub24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy53cy5vbihcImhlYWRlcnNcIiwgKGhlYWRlcnNBcnJheSwgcmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbm90ZTogJ3dzJyB1c2VzIGFuIGFycmF5IG9mIGhlYWRlcnMsIHdoaWxlIEVuZ2luZS5JTyB1c2VzIGFuIG9iamVjdCAocmVzcG9uc2Uud3JpdGVIZWFkKCkgYWNjZXB0cyBib3RoIGZvcm1hdHMpXG4gICAgICAgICAgICAgICAgLy8gd2UgY291bGQgYWxzbyB0cnkgdG8gcGFyc2UgdGhlIGFycmF5IGFuZCB0aGVuIHN5bmMgdGhlIHZhbHVlcywgYnV0IHRoYXQgd2lsbCBiZSBlcnJvci1wcm9uZVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxIZWFkZXJzID0gcmVxW2tSZXNwb25zZUhlYWRlcnNdIHx8IHt9O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXFba1Jlc3BvbnNlSGVhZGVyc107XG4gICAgICAgICAgICAgICAgY29uc3QgaXNJbml0aWFsUmVxdWVzdCA9ICFyZXEuX3F1ZXJ5LnNpZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJpbml0aWFsX2hlYWRlcnNcIiwgYWRkaXRpb25hbEhlYWRlcnMsIHJlcSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImhlYWRlcnNcIiwgYWRkaXRpb25hbEhlYWRlcnMsIHJlcSk7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ3cml0aW5nIGhlYWRlcnM6ICVqXCIsIGFkZGl0aW9uYWxIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsSGVhZGVycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNBcnJheS5wdXNoKGAke2tleX06ICR7YWRkaXRpb25hbEhlYWRlcnNba2V5XX1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNsb3Npbmcgd2ViU29ja2V0U2VydmVyXCIpO1xuICAgICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICAgICAgLy8gZG9uJ3QgZGVsZXRlIHRoaXMud3MgYmVjYXVzZSBpdCBjYW4gYmUgdXNlZCBhZ2FpbiBpZiB0aGUgaHR0cCBzZXJ2ZXIgc3RhcnRzIGxpc3RlbmluZyBhZ2FpblxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgcmVxdWVzdCBieSBwcm9jZXNzaW5nIHRoZSBxdWVyeSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByZXBhcmUocmVxKSB7XG4gICAgICAgIC8vIHRyeSB0byBsZXZlcmFnZSBwcmUtZXhpc3RpbmcgYHJlcS5fcXVlcnlgIChlLmc6IGZyb20gY29ubmVjdClcbiAgICAgICAgaWYgKCFyZXEuX3F1ZXJ5KSB7XG4gICAgICAgICAgICByZXEuX3F1ZXJ5ID0gKH5yZXEudXJsLmluZGV4T2YoXCI/XCIpID8gcXMucGFyc2UoKDAsIHVybF8xLnBhcnNlKShyZXEudXJsKS5xdWVyeSkgOiB7fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydE5hbWUsIHJlcSkge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zcG9ydHNfMS5kZWZhdWx0W3RyYW5zcG9ydE5hbWVdKHJlcSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYW4gRW5naW5lLklPIEhUVFAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5naW5lUmVxdWVzdH0gcmVxXG4gICAgICogQHBhcmFtIHtTZXJ2ZXJSZXNwb25zZX0gcmVzXG4gICAgICovXG4gICAgaGFuZGxlUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBkZWJ1ZygnaGFuZGxpbmcgXCIlc1wiIGh0dHAgcmVxdWVzdCBcIiVzXCInLCByZXEubWV0aG9kLCByZXEudXJsKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlKHJlcSk7XG4gICAgICAgIHJlcS5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGVycm9yQ29udGV4dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcS5fcXVlcnkuc2lkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzZXR0aW5nIG5ldyByZXF1ZXN0IGZvciBleGlzdGluZyBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRzW3JlcS5fcXVlcnkuc2lkXS50cmFuc3BvcnQub25SZXF1ZXN0KHJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZUNvbm5lY3Rpb24gPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IGFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRzaGFrZShyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxLCBjbG9zZUNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwgeyBuYW1lOiBcIk1JRERMRVdBUkVfRkFJTFVSRVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnkocmVxLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbiBFbmdpbmUuSU8gSFRUUCBVcGdyYWRlLlxuICAgICAqL1xuICAgIGhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIHVwZ3JhZGVIZWFkKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZShyZXEpO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgV2ViU29ja2V0UmVzcG9uc2UocmVxLCBzb2NrZXQpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBlcnJvckNvbnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWJvcnRVcGdyYWRlKHNvY2tldCwgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbSh1cGdyYWRlSGVhZCk7XG4gICAgICAgICAgICB1cGdyYWRlSGVhZCA9IG51bGw7XG4gICAgICAgICAgICAvLyBzb21lIG1pZGRsZXdhcmVzIChsaWtlIGV4cHJlc3Mtc2Vzc2lvbikgd2FpdCBmb3IgdGhlIHdyaXRlSGVhZCgpIGNhbGwgdG8gZmx1c2ggdGhlaXIgaGVhZGVyc1xuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9leHByZXNzanMvc2Vzc2lvbi9ibG9iLzEwMTBmYWRjMmYwNzFkZGYyYWRkOTQyMzVkNzIyMjRjZjY1MTU5YzYvaW5kZXguanMjTDIyMC1MMjQ0XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKCk7XG4gICAgICAgICAgICAvLyBkZWxlZ2F0ZSB0byB3c1xuICAgICAgICAgICAgdGhpcy53cy5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCAod2Vic29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbldlYlNvY2tldChyZXEsIHNvY2tldCwgd2Vic29ja2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwgeyBuYW1lOiBcIk1JRERMRVdBUkVfRkFJTFVSRVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnkocmVxLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHdzLmlvIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3dzLlNvY2tldH0gd2Vic29ja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbldlYlNvY2tldChyZXEsIHNvY2tldCwgd2Vic29ja2V0KSB7XG4gICAgICAgIHdlYnNvY2tldC5vbihcImVycm9yXCIsIG9uVXBncmFkZUVycm9yKTtcbiAgICAgICAgaWYgKHRyYW5zcG9ydHNfMS5kZWZhdWx0W3JlcS5fcXVlcnkudHJhbnNwb3J0XSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhdHJhbnNwb3J0c18xLmRlZmF1bHRbcmVxLl9xdWVyeS50cmFuc3BvcnRdLnByb3RvdHlwZS5oYW5kbGVzVXBncmFkZXMpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGRvZXNudCBoYW5kbGUgdXBncmFkZWQgcmVxdWVzdHNcIik7XG4gICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgY2xpZW50IGlkXG4gICAgICAgIGNvbnN0IGlkID0gcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHdzLlNvY2tldFxuICAgICAgICByZXEud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50c1tpZF07XG4gICAgICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwidXBncmFkZSBhdHRlbXB0IGZvciBjbG9zZWQgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGluZykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhcyBhbHJlYWR5IGJlZW4gdHJ5aW5nIHRvIHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkZWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBoYWQgYWxyZWFkeSBiZWVuIHVwZ3JhZGVkXCIpO1xuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ1cGdyYWRpbmcgZXhpc3RpbmcgdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zcG9ydCBlcnJvciBoYW5kbGluZyB0YWtlcyBvdmVyXG4gICAgICAgICAgICAgICAgd2Vic29ja2V0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25VcGdyYWRlRXJyb3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5wZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgICAgICAgICBjbGllbnQuX21heWJlVXBncmFkZSh0cmFuc3BvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2xvc2VDb25uZWN0aW9uID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiBhYm9ydFVwZ3JhZGUoc29ja2V0LCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRzaGFrZShyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxLCBjbG9zZUNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uVXBncmFkZUVycm9yKCkge1xuICAgICAgICAgICAgZGVidWcoXCJ3ZWJzb2NrZXQgZXJyb3IgYmVmb3JlIHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAvLyB3ZWJzb2NrZXQuY2xvc2UoKSBub3QgbmVlZGVkXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZXMgdXBncmFkZSByZXF1ZXN0cyBmb3IgYSBodHRwLlNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJ9IHNlcnZlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgYXR0YWNoKHNlcnZlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLl9jb21wdXRlUGF0aChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGVzdHJveVVwZ3JhZGVUaW1lb3V0ID0gb3B0aW9ucy5kZXN0cm95VXBncmFkZVRpbWVvdXQgfHwgMTAwMDtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2socmVxKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHVzZSBgcGF0aCA9PT0gbmV3IFVSTCguLi4pLnBhdGhuYW1lYCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlIChyZWY6IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdXJsLmh0bWwpXG4gICAgICAgICAgICByZXR1cm4gcGF0aCA9PT0gcmVxLnVybC5zbGljZSgwLCBwYXRoLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FjaGUgYW5kIGNsZWFuIHVwIGxpc3RlbmVyc1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBzZXJ2ZXIubGlzdGVuZXJzKFwicmVxdWVzdFwiKS5zbGljZSgwKTtcbiAgICAgICAgc2VydmVyLnJlbW92ZUFsbExpc3RlbmVycyhcInJlcXVlc3RcIik7XG4gICAgICAgIHNlcnZlci5vbihcImNsb3NlXCIsIHRoaXMuY2xvc2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHNlcnZlci5vbihcImxpc3RlbmluZ1wiLCB0aGlzLmluaXQuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIGFkZCByZXF1ZXN0IGhhbmRsZXJcbiAgICAgICAgc2VydmVyLm9uKFwicmVxdWVzdFwiLCAocmVxLCByZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGVjayhyZXEpKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ2ludGVyY2VwdGluZyByZXF1ZXN0IGZvciBwYXRoIFwiJXNcIicsIHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VydmVyLCByZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKH50aGlzLm9wdHMudHJhbnNwb3J0cy5pbmRleE9mKFwid2Vic29ja2V0XCIpKSB7XG4gICAgICAgICAgICBzZXJ2ZXIub24oXCJ1cGdyYWRlXCIsIChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGVjayhyZXEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZhbHNlICE9PSBvcHRpb25zLmRlc3Ryb3lVcGdyYWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgbm9kZSBiZWhhdmlvciBpcyB0byBkaXNjb25uZWN0IHdoZW4gbm8gaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGJ5IGFkZGluZyBhIGhhbmRsZXIsIHdlIHByZXZlbnQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaWYgbm8gZWlvIHRoaW5nIGhhbmRsZXMgdGhlIHVwZ3JhZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgc29ja2V0IG5lZWRzIHRvIGRpZSFcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LndyaXRhYmxlICYmIHNvY2tldC5ieXRlc1dyaXR0ZW4gPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbihcImVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZXJyb3Igd2hpbGUgZGVzdHJveWluZyB1cGdyYWRlOiAlc1wiLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGRlc3Ryb3lVcGdyYWRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbi8qKlxuICogQ2xvc2UgdGhlIEhUVFAgbG9uZy1wb2xsaW5nIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0gcmVzIC0gdGhlIHJlc3BvbnNlIG9iamVjdFxuICogQHBhcmFtIGVycm9yQ29kZSAtIHRoZSBlcnJvciBjb2RlXG4gKiBAcGFyYW0gZXJyb3JDb250ZXh0IC0gYWRkaXRpb25hbCBlcnJvciBjb250ZXh0XG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpIHtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gZXJyb3JDb2RlID09PSBTZXJ2ZXIuZXJyb3JzLkZPUkJJRERFTiA/IDQwMyA6IDQwMDtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JDb250ZXh0ICYmIGVycm9yQ29udGV4dC5tZXNzYWdlXG4gICAgICAgID8gZXJyb3JDb250ZXh0Lm1lc3NhZ2VcbiAgICAgICAgOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdO1xuICAgIHJlcy53cml0ZUhlYWQoc3RhdHVzQ29kZSwgeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KTtcbiAgICByZXMuZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICBtZXNzYWdlLFxuICAgIH0pKTtcbn1cbi8qKlxuICogQ2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gKlxuICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvckNvZGUgLSB0aGUgZXJyb3IgY29kZVxuICogQHBhcmFtIHtvYmplY3R9IGVycm9yQ29udGV4dCAtIGFkZGl0aW9uYWwgZXJyb3IgY29udGV4dFxuICovXG5mdW5jdGlvbiBhYm9ydFVwZ3JhZGUoc29ja2V0LCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCA9IHt9KSB7XG4gICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICBkZWJ1ZyhcImlnbm9yaW5nIGVycm9yIGZyb20gY2xvc2VkIGNvbm5lY3Rpb25cIik7XG4gICAgfSk7XG4gICAgaWYgKHNvY2tldC53cml0YWJsZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JDb250ZXh0Lm1lc3NhZ2UgfHwgU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSk7XG4gICAgICAgIHNvY2tldC53cml0ZShcIkhUVFAvMS4xIDQwMCBCYWQgUmVxdWVzdFxcclxcblwiICtcbiAgICAgICAgICAgIFwiQ29ubmVjdGlvbjogY2xvc2VcXHJcXG5cIiArXG4gICAgICAgICAgICBcIkNvbnRlbnQtdHlwZTogdGV4dC9odG1sXFxyXFxuXCIgK1xuICAgICAgICAgICAgXCJDb250ZW50LUxlbmd0aDogXCIgK1xuICAgICAgICAgICAgbGVuZ3RoICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCIgK1xuICAgICAgICAgICAgXCJcXHJcXG5cIiArXG4gICAgICAgICAgICBtZXNzYWdlKTtcbiAgICB9XG4gICAgc29ja2V0LmRlc3Ryb3koKTtcbn1cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjguNC4wL2xpYi9faHR0cF9jb21tb24uanMjTDMwMy1MMzU0XG4gKlxuICogVHJ1ZSBpZiB2YWwgY29udGFpbnMgYW4gaW52YWxpZCBmaWVsZC12Y2hhclxuICogIGZpZWxkLXZhbHVlICAgID0gKiggZmllbGQtY29udGVudCAvIG9icy1mb2xkIClcbiAqICBmaWVsZC1jb250ZW50ICA9IGZpZWxkLXZjaGFyIFsgMSooIFNQIC8gSFRBQiApIGZpZWxkLXZjaGFyIF1cbiAqICBmaWVsZC12Y2hhciAgICA9IFZDSEFSIC8gb2JzLXRleHRcbiAqXG4gKiBjaGVja0ludmFsaWRIZWFkZXJDaGFyKCkgaXMgY3VycmVudGx5IGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSBieSB2OCxcbiAqIHNvIHRha2UgY2FyZSB3aGVuIG1ha2luZyBjaGFuZ2VzIHRvIHRoZSBpbXBsZW1lbnRhdGlvbiBzbyB0aGF0IHRoZSBzb3VyY2VcbiAqIGNvZGUgc2l6ZSBkb2VzIG5vdCBleGNlZWQgdjgncyBkZWZhdWx0IG1heF9pbmxpbmVkX3NvdXJjZV9zaXplIHNldHRpbmcuXG4gKiovXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHZhbGlkSGRyQ2hhcnMgPSBbXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMCAtIDE1XG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDMyIC0gNDdcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA0OCAtIDYzXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDgwIC0gOTVcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5NiAtIDExMVxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIC8vIDExMiAtIDEyN1xuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDEyOCAuLi5cbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxIC8vIC4uLiAyNTVcbl07XG5mdW5jdGlvbiBjaGVja0ludmFsaWRIZWFkZXJDaGFyKHZhbCkge1xuICAgIHZhbCArPSBcIlwiO1xuICAgIGlmICh2YWwubGVuZ3RoIDwgMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdCgwKV0pIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCAwLCBjaGFyIFwiJXNcIicsIHZhbC5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdCgxKV0pIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCAxLCBjaGFyIFwiJXNcIicsIHZhbC5jaGFyQ29kZUF0KDEpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoIDwgMylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdCgyKV0pIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCAyLCBjaGFyIFwiJXNcIicsIHZhbC5jaGFyQ29kZUF0KDIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoIDwgNClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdCgzKV0pIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCAzLCBjaGFyIFwiJXNcIicsIHZhbC5jaGFyQ29kZUF0KDMpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSA0OyBpIDwgdmFsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdChpKV0pIHtcbiAgICAgICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggXCIlaVwiLCBjaGFyIFwiJXNcIicsIGksIHZhbC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNlcnZlciIsIkJhc2VTZXJ2ZXIiLCJxcyIsInJlcXVpcmUiLCJ1cmxfMSIsImJhc2U2NGlkIiwidHJhbnNwb3J0c18xIiwiZXZlbnRzXzEiLCJzb2NrZXRfMSIsImRlYnVnXzEiLCJjb29raWVfMSIsIndzXzEiLCJ3ZWJ0cmFuc3BvcnRfMSIsImVuZ2luZV9pb19wYXJzZXJfMSIsImRlYnVnIiwiZGVmYXVsdCIsImtSZXNwb25zZUhlYWRlcnMiLCJTeW1ib2wiLCJwYXJzZVNlc3Npb25JZCIsImRhdGEiLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJzaWQiLCJlIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwibWlkZGxld2FyZXMiLCJjbGllbnRzIiwiY2xpZW50c0NvdW50IiwiYXNzaWduIiwid3NFbmdpbmUiLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbCIsInVwZ3JhZGVUaW1lb3V0IiwibWF4SHR0cEJ1ZmZlclNpemUiLCJ0cmFuc3BvcnRzIiwiYWxsb3dVcGdyYWRlcyIsImh0dHBDb21wcmVzc2lvbiIsInRocmVzaG9sZCIsImNvcnMiLCJhbGxvd0VJTzMiLCJjb29raWUiLCJuYW1lIiwicGF0aCIsImh0dHBPbmx5Iiwic2FtZVNpdGUiLCJ1c2UiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImluaXQiLCJfY29tcHV0ZVBhdGgiLCJvcHRpb25zIiwicmVwbGFjZSIsImFkZFRyYWlsaW5nU2xhc2giLCJ1cGdyYWRlcyIsInRyYW5zcG9ydCIsInVwZ3JhZGVzVG8iLCJ2ZXJpZnkiLCJyZXEiLCJ1cGdyYWRlIiwiZm4iLCJfcXVlcnkiLCJpbmRleE9mIiwiZXJyb3JzIiwiVU5LTk9XTl9UUkFOU1BPUlQiLCJpc09yaWdpbkludmFsaWQiLCJjaGVja0ludmFsaWRIZWFkZXJDaGFyIiwiaGVhZGVycyIsIm9yaWdpbiIsIkJBRF9SRVFVRVNUIiwiaGFzT3duUHJvcGVydHkiLCJVTktOT1dOX1NJRCIsInByZXZpb3VzVHJhbnNwb3J0IiwibWV0aG9kIiwiQkFEX0hBTkRTSEFLRV9NRVRIT0QiLCJhbGxvd1JlcXVlc3QiLCJtZXNzYWdlIiwic3VjY2VzcyIsIkZPUkJJRERFTiIsInB1c2giLCJfYXBwbHlNaWRkbGV3YXJlcyIsInJlcyIsImNhbGxiYWNrIiwibGVuZ3RoIiwiYXBwbHkiLCJpIiwiZXJyIiwiY2xvc2UiLCJjbGVhbnVwIiwiZ2VuZXJhdGVJZCIsImhhbmRzaGFrZSIsInRyYW5zcG9ydE5hbWUiLCJjbG9zZUNvbm5lY3Rpb24iLCJwcm90b2NvbCIsIkVJTyIsImVtaXQiLCJjb2RlIiwiVU5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTiIsImVycm9yTWVzc2FnZXMiLCJjb250ZXh0IiwiaWQiLCJlcnJvciIsImNyZWF0ZVRyYW5zcG9ydCIsInNvY2tldCIsIlNvY2tldCIsIm9uIiwiaXNJbml0aWFsUmVxdWVzdCIsInNlcmlhbGl6ZSIsIm9uUmVxdWVzdCIsIm9uY2UiLCJvbldlYlRyYW5zcG9ydFNlc3Npb24iLCJzZXNzaW9uIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJzdHJlYW1SZWFkZXIiLCJpbmNvbWluZ0JpZGlyZWN0aW9uYWxTdHJlYW1zIiwiZ2V0UmVhZGVyIiwicmVzdWx0IiwicmVhZCIsImRvbmUiLCJzdHJlYW0iLCJ0cmFuc2Zvcm1TdHJlYW0iLCJjcmVhdGVQYWNrZXREZWNvZGVyU3RyZWFtIiwicmVhZGVyIiwicmVhZGFibGUiLCJwaXBlVGhyb3VnaCIsImNsZWFyVGltZW91dCIsInR5cGUiLCJ1bmRlZmluZWQiLCJXZWJUcmFuc3BvcnQiLCJjbGllbnQiLCJ1cGdyYWRpbmciLCJ1cGdyYWRlZCIsIl9tYXliZVVwZ3JhZGUiLCJXZWJTb2NrZXRSZXNwb25zZSIsInNldEhlYWRlciIsImdldEhlYWRlciIsInJlbW92ZUhlYWRlciIsIndyaXRlIiwid3JpdGVIZWFkIiwiZW5kIiwiZGVzdHJveSIsIndzIiwibm9TZXJ2ZXIiLCJjbGllbnRUcmFja2luZyIsIm1heFBheWxvYWQiLCJoZWFkZXJzQXJyYXkiLCJhZGRpdGlvbmFsSGVhZGVycyIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwicHJlcGFyZSIsInVybCIsInF1ZXJ5IiwiaGFuZGxlUmVxdWVzdCIsImVycm9yQ29kZSIsImVycm9yQ29udGV4dCIsImFib3J0UmVxdWVzdCIsImhhbmRsZVVwZ3JhZGUiLCJ1cGdyYWRlSGVhZCIsImFib3J0VXBncmFkZSIsImhlYWQiLCJCdWZmZXIiLCJmcm9tIiwid2Vic29ja2V0Iiwib25XZWJTb2NrZXQiLCJvblVwZ3JhZGVFcnJvciIsInByb3RvdHlwZSIsImhhbmRsZXNVcGdyYWRlcyIsInJlbW92ZUxpc3RlbmVyIiwiYXR0YWNoIiwic2VydmVyIiwiZGVzdHJveVVwZ3JhZGVUaW1lb3V0IiwiY2hlY2siLCJzbGljZSIsImxpc3RlbmVycyIsInJlbW92ZUFsbExpc3RlbmVycyIsImJpbmQiLCJsIiwiY2FsbCIsImRlc3Ryb3lVcGdyYWRlIiwid3JpdGFibGUiLCJieXRlc1dyaXR0ZW4iLCJzdGF0dXNDb2RlIiwic3RyaW5naWZ5IiwiYnl0ZUxlbmd0aCIsInZhbGlkSGRyQ2hhcnMiLCJ2YWwiLCJjaGFyQ29kZUF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/socket.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/socket.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Socket = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst timers_1 = __webpack_require__(/*! timers */ \"timers\");\nconst debug = (0, debug_1.default)(\"engine:socket\");\nclass Socket extends events_1.EventEmitter {\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s\", this._readyState, state);\n        this._readyState = state;\n    }\n    constructor(id, server, transport, req, protocol){\n        super();\n        /**\n         * The current state of the socket.\n         */ this._readyState = \"opening\";\n        /* private */ this.upgrading = false;\n        /* private */ this.upgraded = false;\n        this.writeBuffer = [];\n        this.packetsFn = [];\n        this.sentCallbackFn = [];\n        this.cleanupFn = [];\n        this.id = id;\n        this.server = server;\n        this.request = req;\n        this.protocol = protocol;\n        // Cache IP since it might not be in the req later\n        if (req) {\n            if (req.websocket && req.websocket._socket) {\n                this.remoteAddress = req.websocket._socket.remoteAddress;\n            } else {\n                this.remoteAddress = req.connection.remoteAddress;\n            }\n        } else {\n        // TODO there is currently no way to get the IP address of the client when it connects with WebTransport\n        //  see https://github.com/fails-components/webtransport/issues/114\n        }\n        this.pingTimeoutTimer = null;\n        this.pingIntervalTimer = null;\n        this.setTransport(transport);\n        this.onOpen();\n    }\n    /**\n     * Called upon transport considered open.\n     *\n     * @private\n     */ onOpen() {\n        this.readyState = \"open\";\n        // sends an `open` packet\n        this.transport.sid = this.id;\n        this.sendPacket(\"open\", JSON.stringify({\n            sid: this.id,\n            upgrades: this.getAvailableUpgrades(),\n            pingInterval: this.server.opts.pingInterval,\n            pingTimeout: this.server.opts.pingTimeout,\n            maxPayload: this.server.opts.maxHttpBufferSize\n        }));\n        if (this.server.opts.initialPacket) {\n            this.sendPacket(\"message\", this.server.opts.initialPacket);\n        }\n        this.emit(\"open\");\n        if (this.protocol === 3) {\n            // in protocol v3, the client sends a ping, and the server answers with a pong\n            this.resetPingTimeout();\n        } else {\n            // in protocol v4, the server sends a ping, and the client answers with a pong\n            this.schedulePing();\n        }\n    }\n    /**\n     * Called upon transport packet.\n     *\n     * @param {Object} packet\n     * @private\n     */ onPacket(packet) {\n        if (\"open\" !== this.readyState) {\n            return debug(\"packet received with closed socket\");\n        }\n        // export packet event\n        debug(`received packet ${packet.type}`);\n        this.emit(\"packet\", packet);\n        switch(packet.type){\n            case \"ping\":\n                if (this.transport.protocol !== 3) {\n                    this.onError(new Error(\"invalid heartbeat direction\"));\n                    return;\n                }\n                debug(\"got ping\");\n                this.pingTimeoutTimer.refresh();\n                this.sendPacket(\"pong\");\n                this.emit(\"heartbeat\");\n                break;\n            case \"pong\":\n                if (this.transport.protocol === 3) {\n                    this.onError(new Error(\"invalid heartbeat direction\"));\n                    return;\n                }\n                debug(\"got pong\");\n                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n                this.pingIntervalTimer.refresh();\n                this.emit(\"heartbeat\");\n                break;\n            case \"error\":\n                this.onClose(\"parse error\");\n                break;\n            case \"message\":\n                this.emit(\"data\", packet.data);\n                this.emit(\"message\", packet.data);\n                break;\n        }\n    }\n    /**\n     * Called upon transport error.\n     *\n     * @param {Error} err - error object\n     * @private\n     */ onError(err) {\n        debug(\"transport error\");\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Pings client every `this.pingInterval` and expects response\n     * within `this.pingTimeout` or closes connection.\n     *\n     * @private\n     */ schedulePing() {\n        this.pingIntervalTimer = (0, timers_1.setTimeout)(()=>{\n            debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n            this.sendPacket(\"ping\");\n            this.resetPingTimeout();\n        }, this.server.opts.pingInterval);\n    }\n    /**\n     * Resets ping timeout.\n     *\n     * @private\n     */ resetPingTimeout() {\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = (0, timers_1.setTimeout)(()=>{\n            if (this.readyState === \"closed\") return;\n            this.onClose(\"ping timeout\");\n        }, this.protocol === 3 ? this.server.opts.pingInterval + this.server.opts.pingTimeout : this.server.opts.pingTimeout);\n    }\n    /**\n     * Attaches handlers for the given transport.\n     *\n     * @param {Transport} transport\n     * @private\n     */ setTransport(transport) {\n        const onError = this.onError.bind(this);\n        const onReady = ()=>this.flush();\n        const onPacket = this.onPacket.bind(this);\n        const onDrain = this.onDrain.bind(this);\n        const onClose = this.onClose.bind(this, \"transport close\");\n        this.transport = transport;\n        this.transport.once(\"error\", onError);\n        this.transport.on(\"ready\", onReady);\n        this.transport.on(\"packet\", onPacket);\n        this.transport.on(\"drain\", onDrain);\n        this.transport.once(\"close\", onClose);\n        this.cleanupFn.push(function() {\n            transport.removeListener(\"error\", onError);\n            transport.removeListener(\"ready\", onReady);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"drain\", onDrain);\n            transport.removeListener(\"close\", onClose);\n        });\n    }\n    /**\n     * Upon transport \"drain\" event\n     *\n     * @private\n     */ onDrain() {\n        if (this.sentCallbackFn.length > 0) {\n            debug(\"executing batch send callback\");\n            const seqFn = this.sentCallbackFn.shift();\n            if (seqFn) {\n                for(let i = 0; i < seqFn.length; i++){\n                    seqFn[i](this.transport);\n                }\n            }\n        }\n    }\n    /**\n     * Upgrades socket to the given transport\n     *\n     * @param {Transport} transport\n     * @private\n     */ /* private */ _maybeUpgrade(transport) {\n        debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n        this.upgrading = true;\n        // set transport upgrade timer\n        const upgradeTimeoutTimer = (0, timers_1.setTimeout)(()=>{\n            debug(\"client did not complete upgrade - closing transport\");\n            cleanup();\n            if (\"open\" === transport.readyState) {\n                transport.close();\n            }\n        }, this.server.opts.upgradeTimeout);\n        let checkIntervalTimer;\n        const onPacket = (packet)=>{\n            if (\"ping\" === packet.type && \"probe\" === packet.data) {\n                debug(\"got probe ping packet, sending pong\");\n                transport.send([\n                    {\n                        type: \"pong\",\n                        data: \"probe\"\n                    }\n                ]);\n                this.emit(\"upgrading\", transport);\n                clearInterval(checkIntervalTimer);\n                checkIntervalTimer = setInterval(check, 100);\n            } else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n                debug(\"got upgrade packet - upgrading\");\n                cleanup();\n                this.transport.discard();\n                this.upgraded = true;\n                this.clearTransport();\n                this.setTransport(transport);\n                this.emit(\"upgrade\", transport);\n                this.flush();\n                if (this.readyState === \"closing\") {\n                    transport.close(()=>{\n                        this.onClose(\"forced close\");\n                    });\n                }\n            } else {\n                cleanup();\n                transport.close();\n            }\n        };\n        // we force a polling cycle to ensure a fast upgrade\n        const check = ()=>{\n            if (\"polling\" === this.transport.name && this.transport.writable) {\n                debug(\"writing a noop packet to polling for fast upgrade\");\n                this.transport.send([\n                    {\n                        type: \"noop\"\n                    }\n                ]);\n            }\n        };\n        const cleanup = ()=>{\n            this.upgrading = false;\n            clearInterval(checkIntervalTimer);\n            (0, timers_1.clearTimeout)(upgradeTimeoutTimer);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"close\", onTransportClose);\n            transport.removeListener(\"error\", onError);\n            this.removeListener(\"close\", onClose);\n        };\n        const onError = (err)=>{\n            debug(\"client did not complete upgrade - %s\", err);\n            cleanup();\n            transport.close();\n            transport = null;\n        };\n        const onTransportClose = ()=>{\n            onError(\"transport closed\");\n        };\n        const onClose = ()=>{\n            onError(\"socket closed\");\n        };\n        transport.on(\"packet\", onPacket);\n        transport.once(\"close\", onTransportClose);\n        transport.once(\"error\", onError);\n        this.once(\"close\", onClose);\n    }\n    /**\n     * Clears listeners and timers associated with current transport.\n     *\n     * @private\n     */ clearTransport() {\n        let cleanup;\n        const toCleanUp = this.cleanupFn.length;\n        for(let i = 0; i < toCleanUp; i++){\n            cleanup = this.cleanupFn.shift();\n            cleanup();\n        }\n        // silence further transport errors and prevent uncaught exceptions\n        this.transport.on(\"error\", function() {\n            debug(\"error triggered by discarded transport\");\n        });\n        // ensure transport won't stay open\n        this.transport.close();\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    }\n    /**\n     * Called upon transport considered closed.\n     * Possible reasons: `ping timeout`, `client error`, `parse error`,\n     * `transport error`, `server close`, `transport close`\n     */ onClose(reason, description) {\n        if (\"closed\" !== this.readyState) {\n            this.readyState = \"closed\";\n            // clear timers\n            (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n            // clean writeBuffer in next tick, so developers can still\n            // grab the writeBuffer on 'close' event\n            process.nextTick(()=>{\n                this.writeBuffer = [];\n            });\n            this.packetsFn = [];\n            this.sentCallbackFn = [];\n            this.clearTransport();\n            this.emit(\"close\", reason, description);\n        }\n    }\n    /**\n     * Sends a message packet.\n     *\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Function} callback\n     * @return {Socket} for chaining\n     */ send(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Alias of {@link send}.\n     *\n     * @param data\n     * @param options\n     * @param callback\n     */ write(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type - packet type\n     * @param {String} data\n     * @param {Object} options\n     * @param {Function} callback\n     *\n     * @private\n     */ sendPacket(type, data, options = {}, callback) {\n        if (\"function\" === typeof options) {\n            callback = options;\n            options = {};\n        }\n        if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n            debug('sending packet \"%s\" (%s)', type, data);\n            // compression is enabled by default\n            options.compress = options.compress !== false;\n            const packet = {\n                type,\n                options: options\n            };\n            if (data) packet.data = data;\n            // exports packetCreate event\n            this.emit(\"packetCreate\", packet);\n            this.writeBuffer.push(packet);\n            // add send callback to object, if defined\n            if (\"function\" === typeof callback) this.packetsFn.push(callback);\n            this.flush();\n        }\n    }\n    /**\n     * Attempts to flush the packets buffer.\n     *\n     * @private\n     */ flush() {\n        if (\"closed\" !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n            debug(\"flushing buffer to transport\");\n            this.emit(\"flush\", this.writeBuffer);\n            this.server.emit(\"flush\", this, this.writeBuffer);\n            const wbuf = this.writeBuffer;\n            this.writeBuffer = [];\n            if (this.packetsFn.length) {\n                this.sentCallbackFn.push(this.packetsFn);\n                this.packetsFn = [];\n            } else {\n                this.sentCallbackFn.push(null);\n            }\n            this.transport.send(wbuf);\n            this.emit(\"drain\");\n            this.server.emit(\"drain\", this);\n        }\n    }\n    /**\n     * Get available upgrades for this socket.\n     *\n     * @private\n     */ getAvailableUpgrades() {\n        const availableUpgrades = [];\n        const allUpgrades = this.server.upgrades(this.transport.name);\n        for(let i = 0; i < allUpgrades.length; ++i){\n            const upg = allUpgrades[i];\n            if (this.server.opts.transports.indexOf(upg) !== -1) {\n                availableUpgrades.push(upg);\n            }\n        }\n        return availableUpgrades;\n    }\n    /**\n     * Closes the socket and underlying transport.\n     *\n     * @param {Boolean} discard - optional, discard the transport\n     * @return {Socket} for chaining\n     */ close(discard) {\n        if (discard && (this.readyState === \"open\" || this.readyState === \"closing\")) {\n            return this.closeTransport(discard);\n        }\n        if (\"open\" !== this.readyState) return;\n        this.readyState = \"closing\";\n        if (this.writeBuffer.length) {\n            debug(\"there are %d remaining packets in the buffer, waiting for the 'drain' event\", this.writeBuffer.length);\n            this.once(\"drain\", ()=>{\n                debug(\"all packets have been sent, closing the transport\");\n                this.closeTransport(discard);\n            });\n            return;\n        }\n        debug(\"the buffer is empty, closing the transport right away\");\n        this.closeTransport(discard);\n    }\n    /**\n     * Closes the underlying transport.\n     *\n     * @param {Boolean} discard\n     * @private\n     */ closeTransport(discard) {\n        debug(\"closing the transport (discard? %s)\", !!discard);\n        if (discard) this.transport.discard();\n        this.transport.close(this.onClose.bind(this, \"forced close\"));\n    }\n}\nexports.Socket = Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3NvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsNkVBQU87QUFDL0IsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUcsUUFBUSxDQUFDLEdBQUdGLFFBQVFHLE9BQU8sRUFBRTtBQUNuQyxNQUFNTixlQUFlQyxTQUFTTSxZQUFZO0lBQ3RDLElBQUlDLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ0MsV0FBVztJQUMzQjtJQUNBLElBQUlELFdBQVdFLEtBQUssRUFBRTtRQUNsQkwsTUFBTSxvQ0FBb0MsSUFBSSxDQUFDSSxXQUFXLEVBQUVDO1FBQzVELElBQUksQ0FBQ0QsV0FBVyxHQUFHQztJQUN2QjtJQUNBQyxZQUFZQyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsQ0FBRTtRQUM5QyxLQUFLO1FBQ0w7O1NBRUMsR0FDRCxJQUFJLENBQUNQLFdBQVcsR0FBRztRQUNuQixXQUFXLEdBQUcsSUFBSSxDQUFDUSxTQUFTLEdBQUc7UUFDL0IsV0FBVyxHQUFHLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQzlCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEVBQUU7UUFDckIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDVixFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDVSxPQUFPLEdBQUdSO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdB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QUFVLElBQUksQ0FBQ0EsVUFBVSxLQUFLLFNBQVEsR0FBSTtZQUMvRCxPQUFPLElBQUksQ0FBQzRGLGNBQWMsQ0FBQ25CO1FBQy9CO1FBQ0EsSUFBSSxXQUFXLElBQUksQ0FBQ3pFLFVBQVUsRUFDMUI7UUFDSixJQUFJLENBQUNBLFVBQVUsR0FBRztRQUNsQixJQUFJLElBQUksQ0FBQ1csV0FBVyxDQUFDK0MsTUFBTSxFQUFFO1lBQ3pCN0QsTUFBTSwrRUFBK0UsSUFBSSxDQUFDYyxXQUFXLENBQUMrQyxNQUFNO1lBQzVHLElBQUksQ0FBQ0osSUFBSSxDQUFDLFNBQVM7Z0JBQ2Z6RCxNQUFNO2dCQUNOLElBQUksQ0FBQytGLGNBQWMsQ0FBQ25CO1lBQ3hCO1lBQ0E7UUFDSjtRQUNBNUUsTUFBTTtRQUNOLElBQUksQ0FBQytGLGNBQWMsQ0FBQ25CO0lBQ3hCO0lBQ0E7Ozs7O0tBS0MsR0FDRG1CLGVBQWVuQixPQUFPLEVBQUU7UUFDcEI1RSxNQUFNLHVDQUF1QyxDQUFDLENBQUM0RTtRQUMvQyxJQUFJQSxTQUNBLElBQUksQ0FBQ25FLFNBQVMsQ0FBQ21FLE9BQU87UUFDMUIsSUFBSSxDQUFDbkUsU0FBUyxDQUFDNEQsS0FBSyxDQUFDLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ0ksSUFBSSxDQUFDLElBQUksRUFBRTtJQUNqRDtBQUNKO0FBQ0E1RCxjQUFjLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmF2b2NoYXQtYXBwLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9zb2NrZXQuanM/YzQ2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IHRpbWVyc18xID0gcmVxdWlyZShcInRpbWVyc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6c29ja2V0XCIpO1xuY2xhc3MgU29ja2V0IGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gICAgfVxuICAgIHNldCByZWFkeVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGRlYnVnKFwicmVhZHlTdGF0ZSB1cGRhdGVkIGZyb20gJXMgdG8gJXNcIiwgdGhpcy5fcmVhZHlTdGF0ZSwgc3RhdGUpO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlkLCBzZXJ2ZXIsIHRyYW5zcG9ydCwgcmVxLCBwcm90b2NvbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNvY2tldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcIm9wZW5pbmdcIjtcbiAgICAgICAgLyogcHJpdmF0ZSAqLyB0aGlzLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAvKiBwcml2YXRlICovIHRoaXMudXBncmFkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnBhY2tldHNGbiA9IFtdO1xuICAgICAgICB0aGlzLnNlbnRDYWxsYmFja0ZuID0gW107XG4gICAgICAgIHRoaXMuY2xlYW51cEZuID0gW107XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcTtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgICAvLyBDYWNoZSBJUCBzaW5jZSBpdCBtaWdodCBub3QgYmUgaW4gdGhlIHJlcSBsYXRlclxuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICBpZiAocmVxLndlYnNvY2tldCAmJiByZXEud2Vic29ja2V0Ll9zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZXEud2Vic29ja2V0Ll9zb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHJlcS5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPIHRoZXJlIGlzIGN1cnJlbnRseSBubyB3YXkgdG8gZ2V0IHRoZSBJUCBhZGRyZXNzIG9mIHRoZSBjbGllbnQgd2hlbiBpdCBjb25uZWN0cyB3aXRoIFdlYlRyYW5zcG9ydFxuICAgICAgICAgICAgLy8gIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFpbHMtY29tcG9uZW50cy93ZWJ0cmFuc3BvcnQvaXNzdWVzLzExNFxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY29uc2lkZXJlZCBvcGVuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICAvLyBzZW5kcyBhbiBgb3BlbmAgcGFja2V0XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnNpZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm9wZW5cIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc2lkOiB0aGlzLmlkLFxuICAgICAgICAgICAgdXBncmFkZXM6IHRoaXMuZ2V0QXZhaWxhYmxlVXBncmFkZXMoKSxcbiAgICAgICAgICAgIHBpbmdJbnRlcnZhbDogdGhpcy5zZXJ2ZXIub3B0cy5waW5nSW50ZXJ2YWwsXG4gICAgICAgICAgICBwaW5nVGltZW91dDogdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dCxcbiAgICAgICAgICAgIG1heFBheWxvYWQ6IHRoaXMuc2VydmVyLm9wdHMubWF4SHR0cEJ1ZmZlclNpemUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLm9wdHMuaW5pdGlhbFBhY2tldCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwibWVzc2FnZVwiLCB0aGlzLnNlcnZlci5vcHRzLmluaXRpYWxQYWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcIm9wZW5cIik7XG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAvLyBpbiBwcm90b2NvbCB2MywgdGhlIGNsaWVudCBzZW5kcyBhIHBpbmcsIGFuZCB0aGUgc2VydmVyIGFuc3dlcnMgd2l0aCBhIHBvbmdcbiAgICAgICAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gcHJvdG9jb2wgdjQsIHRoZSBzZXJ2ZXIgc2VuZHMgYSBwaW5nLCBhbmQgdGhlIGNsaWVudCBhbnN3ZXJzIHdpdGggYSBwb25nXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvblBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgaWYgKFwib3BlblwiICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWJ1ZyhcInBhY2tldCByZWNlaXZlZCB3aXRoIGNsb3NlZCBzb2NrZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwb3J0IHBhY2tldCBldmVudFxuICAgICAgICBkZWJ1ZyhgcmVjZWl2ZWQgcGFja2V0ICR7cGFja2V0LnR5cGV9YCk7XG4gICAgICAgIHRoaXMuZW1pdChcInBhY2tldFwiLCBwYWNrZXQpO1xuICAgICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwicGluZ1wiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydC5wcm90b2NvbCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKFwiaW52YWxpZCBoZWFydGJlYXQgZGlyZWN0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCBwaW5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGluZ1RpbWVvdXRUaW1lci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwicG9uZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJoZWFydGJlYXRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicG9uZ1wiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydC5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKFwiaW52YWxpZCBoZWFydGJlYXQgZGlyZWN0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCBwb25nXCIpO1xuICAgICAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaGVhcnRiZWF0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKFwicGFyc2UgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIGVycm9yIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25FcnJvcihlcnIpIHtcbiAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgZXJyb3JcIik7XG4gICAgICAgIHRoaXMub25DbG9zZShcInRyYW5zcG9ydCBlcnJvclwiLCBlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaW5ncyBjbGllbnQgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICAgICAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNjaGVkdWxlUGluZygpIHtcbiAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lciA9ICgwLCB0aW1lcnNfMS5zZXRUaW1lb3V0KSgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcIndyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtc1wiLCB0aGlzLnNlcnZlci5vcHRzLnBpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuc2VuZFBhY2tldChcInBpbmdcIik7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICAgICAgfSwgdGhpcy5zZXJ2ZXIub3B0cy5waW5nSW50ZXJ2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZXNldFBpbmdUaW1lb3V0KCkge1xuICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSAoMCwgdGltZXJzXzEuc2V0VGltZW91dCkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJjbG9zZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoXCJwaW5nIHRpbWVvdXRcIik7XG4gICAgICAgIH0sIHRoaXMucHJvdG9jb2wgPT09IDNcbiAgICAgICAgICAgID8gdGhpcy5zZXJ2ZXIub3B0cy5waW5nSW50ZXJ2YWwgKyB0aGlzLnNlcnZlci5vcHRzLnBpbmdUaW1lb3V0XG4gICAgICAgICAgICA6IHRoaXMuc2VydmVyLm9wdHMucGluZ1RpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBoYW5kbGVycyBmb3IgdGhlIGdpdmVuIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldFRyYW5zcG9ydCh0cmFuc3BvcnQpIHtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IHRoaXMub25FcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBvblJlYWR5ID0gKCkgPT4gdGhpcy5mbHVzaCgpO1xuICAgICAgICBjb25zdCBvblBhY2tldCA9IHRoaXMub25QYWNrZXQuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgb25EcmFpbiA9IHRoaXMub25EcmFpbi5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcywgXCJ0cmFuc3BvcnQgY2xvc2VcIik7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbmNlKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwicmVhZHlcIiwgb25SZWFkeSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwicGFja2V0XCIsIG9uUGFja2V0KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub24oXCJkcmFpblwiLCBvbkRyYWluKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub25jZShcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICB0aGlzLmNsZWFudXBGbi5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwicmVhZHlcIiwgb25SZWFkeSk7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJwYWNrZXRcIiwgb25QYWNrZXQpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiZHJhaW5cIiwgb25EcmFpbik7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwb24gdHJhbnNwb3J0IFwiZHJhaW5cIiBldmVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5zZW50Q2FsbGJhY2tGbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImV4ZWN1dGluZyBiYXRjaCBzZW5kIGNhbGxiYWNrXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2VxRm4gPSB0aGlzLnNlbnRDYWxsYmFja0ZuLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoc2VxRm4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcUZuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcUZuW2ldKHRoaXMudHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBncmFkZXMgc29ja2V0IHRvIHRoZSBnaXZlbiB0cmFuc3BvcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8qIHByaXZhdGUgKi8gX21heWJlVXBncmFkZSh0cmFuc3BvcnQpIHtcbiAgICAgICAgZGVidWcoJ21pZ2h0IHVwZ3JhZGUgc29ja2V0IHRyYW5zcG9ydCBmcm9tIFwiJXNcIiB0byBcIiVzXCInLCB0aGlzLnRyYW5zcG9ydC5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHRoaXMudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gc2V0IHRyYW5zcG9ydCB1cGdyYWRlIHRpbWVyXG4gICAgICAgIGNvbnN0IHVwZ3JhZGVUaW1lb3V0VGltZXIgPSAoMCwgdGltZXJzXzEuc2V0VGltZW91dCkoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJjbGllbnQgZGlkIG5vdCBjb21wbGV0ZSB1cGdyYWRlIC0gY2xvc2luZyB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBpZiAoXCJvcGVuXCIgPT09IHRyYW5zcG9ydC5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuc2VydmVyLm9wdHMudXBncmFkZVRpbWVvdXQpO1xuICAgICAgICBsZXQgY2hlY2tJbnRlcnZhbFRpbWVyO1xuICAgICAgICBjb25zdCBvblBhY2tldCA9IChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGlmIChcInBpbmdcIiA9PT0gcGFja2V0LnR5cGUgJiYgXCJwcm9iZVwiID09PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHByb2JlIHBpbmcgcGFja2V0LCBzZW5kaW5nIHBvbmdcIik7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogXCJwb25nXCIsIGRhdGE6IFwicHJvYmVcIiB9XSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBncmFkaW5nXCIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjaGVja0ludGVydmFsVGltZXIpO1xuICAgICAgICAgICAgICAgIGNoZWNrSW50ZXJ2YWxUaW1lciA9IHNldEludGVydmFsKGNoZWNrLCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJ1cGdyYWRlXCIgPT09IHBhY2tldC50eXBlICYmIHRoaXMucmVhZHlTdGF0ZSAhPT0gXCJjbG9zZWRcIikge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHVwZ3JhZGUgcGFja2V0IC0gdXBncmFkaW5nXCIpO1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjYXJkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGdyYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBncmFkZVwiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBcImNsb3NpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKFwiZm9yY2VkIGNsb3NlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdlIGZvcmNlIGEgcG9sbGluZyBjeWNsZSB0byBlbnN1cmUgYSBmYXN0IHVwZ3JhZGVcbiAgICAgICAgY29uc3QgY2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJwb2xsaW5nXCIgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIndyaXRpbmcgYSBub29wIHBhY2tldCB0byBwb2xsaW5nIGZvciBmYXN0IHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjaGVja0ludGVydmFsVGltZXIpO1xuICAgICAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodXBncmFkZVRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJwYWNrZXRcIiwgb25QYWNrZXQpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2xpZW50IGRpZCBub3QgY29tcGxldGUgdXBncmFkZSAtICVzXCIsIGVycik7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uVHJhbnNwb3J0Q2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBvbkVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIG9uRXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc3BvcnQub24oXCJwYWNrZXRcIiwgb25QYWNrZXQpO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGxpc3RlbmVycyBhbmQgdGltZXJzIGFzc29jaWF0ZWQgd2l0aCBjdXJyZW50IHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYXJUcmFuc3BvcnQoKSB7XG4gICAgICAgIGxldCBjbGVhbnVwO1xuICAgICAgICBjb25zdCB0b0NsZWFuVXAgPSB0aGlzLmNsZWFudXBGbi5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9DbGVhblVwOyBpKyspIHtcbiAgICAgICAgICAgIGNsZWFudXAgPSB0aGlzLmNsZWFudXBGbi5zaGlmdCgpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNpbGVuY2UgZnVydGhlciB0cmFuc3BvcnQgZXJyb3JzIGFuZCBwcmV2ZW50IHVuY2F1Z2h0IGV4Y2VwdGlvbnNcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHRyaWdnZXJlZCBieSBkaXNjYXJkZWQgdHJhbnNwb3J0XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNvbnNpZGVyZWQgY2xvc2VkLlxuICAgICAqIFBvc3NpYmxlIHJlYXNvbnM6IGBwaW5nIHRpbWVvdXRgLCBgY2xpZW50IGVycm9yYCwgYHBhcnNlIGVycm9yYCxcbiAgICAgKiBgdHJhbnNwb3J0IGVycm9yYCwgYHNlcnZlciBjbG9zZWAsIGB0cmFuc3BvcnQgY2xvc2VgXG4gICAgICovXG4gICAgb25DbG9zZShyZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChcImNsb3NlZFwiICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgICAgICAvLyBjbGVhciB0aW1lcnNcbiAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgICAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIC8vIGNsZWFuIHdyaXRlQnVmZmVyIGluIG5leHQgdGljaywgc28gZGV2ZWxvcGVycyBjYW4gc3RpbGxcbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIHdyaXRlQnVmZmVyIG9uICdjbG9zZScgZXZlbnRcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYWNrZXRzRm4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VudENhbGxiYWNrRm4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHNlbmQoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwibWVzc2FnZVwiLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiB7QGxpbmsgc2VuZH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgd3JpdGUoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwibWVzc2FnZVwiLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gcGFja2V0IHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2VuZFBhY2tldCh0eXBlLCBkYXRhLCBvcHRpb25zID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY2xvc2luZ1wiICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYgXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBkZWJ1Zygnc2VuZGluZyBwYWNrZXQgXCIlc1wiICglcyknLCB0eXBlLCBkYXRhKTtcbiAgICAgICAgICAgIC8vIGNvbXByZXNzaW9uIGlzIGVuYWJsZWQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgb3B0aW9ucy5jb21wcmVzcyA9IG9wdGlvbnMuY29tcHJlc3MgIT09IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgICAgICBwYWNrZXQuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAvLyBleHBvcnRzIHBhY2tldENyZWF0ZSBldmVudFxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicGFja2V0Q3JlYXRlXCIsIHBhY2tldCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgICAgICAgICAgIC8vIGFkZCBzZW5kIGNhbGxiYWNrIHRvIG9iamVjdCwgaWYgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIHRoaXMucGFja2V0c0ZuLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGZsdXNoIHRoZSBwYWNrZXRzIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmIChcImNsb3NlZFwiICE9PSB0aGlzLnJlYWR5U3RhdGUgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVidWcoXCJmbHVzaGluZyBidWZmZXIgdG8gdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZmx1c2hcIiwgdGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci5lbWl0KFwiZmx1c2hcIiwgdGhpcywgdGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgICAgICAgICBjb25zdCB3YnVmID0gdGhpcy53cml0ZUJ1ZmZlcjtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhY2tldHNGbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbnRDYWxsYmFja0ZuLnB1c2godGhpcy5wYWNrZXRzRm4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFja2V0c0ZuID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbnRDYWxsYmFja0ZuLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHdidWYpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci5lbWl0KFwiZHJhaW5cIiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGF2YWlsYWJsZSB1cGdyYWRlcyBmb3IgdGhpcyBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldEF2YWlsYWJsZVVwZ3JhZGVzKCkge1xuICAgICAgICBjb25zdCBhdmFpbGFibGVVcGdyYWRlcyA9IFtdO1xuICAgICAgICBjb25zdCBhbGxVcGdyYWRlcyA9IHRoaXMuc2VydmVyLnVwZ3JhZGVzKHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbFVwZ3JhZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB1cGcgPSBhbGxVcGdyYWRlc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcnZlci5vcHRzLnRyYW5zcG9ydHMuaW5kZXhPZih1cGcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVVwZ3JhZGVzLnB1c2godXBnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXZhaWxhYmxlVXBncmFkZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgc29ja2V0IGFuZCB1bmRlcmx5aW5nIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzY2FyZCAtIG9wdGlvbmFsLCBkaXNjYXJkIHRoZSB0cmFuc3BvcnRcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGNsb3NlKGRpc2NhcmQpIHtcbiAgICAgICAgaWYgKGRpc2NhcmQgJiZcbiAgICAgICAgICAgICh0aGlzLnJlYWR5U3RhdGUgPT09IFwib3BlblwiIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJjbG9zaW5nXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZVRyYW5zcG9ydChkaXNjYXJkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJvcGVuXCIgIT09IHRoaXMucmVhZHlTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zaW5nXCI7XG4gICAgICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVidWcoXCJ0aGVyZSBhcmUgJWQgcmVtYWluaW5nIHBhY2tldHMgaW4gdGhlIGJ1ZmZlciwgd2FpdGluZyBmb3IgdGhlICdkcmFpbicgZXZlbnRcIiwgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5vbmNlKFwiZHJhaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiYWxsIHBhY2tldHMgaGF2ZSBiZWVuIHNlbnQsIGNsb3NpbmcgdGhlIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlVHJhbnNwb3J0KGRpc2NhcmQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJ0aGUgYnVmZmVyIGlzIGVtcHR5LCBjbG9zaW5nIHRoZSB0cmFuc3BvcnQgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgdGhpcy5jbG9zZVRyYW5zcG9ydChkaXNjYXJkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzY2FyZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xvc2VUcmFuc3BvcnQoZGlzY2FyZCkge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmcgdGhlIHRyYW5zcG9ydCAoZGlzY2FyZD8gJXMpXCIsICEhZGlzY2FyZCk7XG4gICAgICAgIGlmIChkaXNjYXJkKVxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuZGlzY2FyZCgpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSh0aGlzLm9uQ2xvc2UuYmluZCh0aGlzLCBcImZvcmNlZCBjbG9zZVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXQgPSBTb2NrZXQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTb2NrZXQiLCJldmVudHNfMSIsInJlcXVpcmUiLCJkZWJ1Z18xIiwidGltZXJzXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJFdmVudEVtaXR0ZXIiLCJyZWFkeVN0YXRlIiwiX3JlYWR5U3RhdGUiLCJzdGF0ZSIsImNvbnN0cnVjdG9yIiwiaWQiLCJzZXJ2ZXIiLCJ0cmFuc3BvcnQiLCJyZXEiLCJwcm90b2NvbCIsInVwZ3JhZGluZyIsInVwZ3JhZGVkIiwid3JpdGVCdWZmZXIiLCJwYWNrZXRzRm4iLCJzZW50Q2FsbGJhY2tGbiIsImNsZWFudXBGbiIsInJlcXVlc3QiLCJ3ZWJzb2NrZXQiLCJfc29ja2V0IiwicmVtb3RlQWRkcmVzcyIsImNvbm5lY3Rpb24iLCJwaW5nVGltZW91dFRpbWVyIiwicGluZ0ludGVydmFsVGltZXIiLCJzZXRUcmFuc3BvcnQiLCJvbk9wZW4iLCJzaWQiLCJzZW5kUGFja2V0IiwiSlNPTiIsInN0cmluZ2lmeSIsInVwZ3JhZGVzIiwiZ2V0QXZhaWxhYmxlVXBncmFkZXMiLCJwaW5nSW50ZXJ2YWwiLCJvcHRzIiwicGluZ1RpbWVvdXQiLCJtYXhQYXlsb2FkIiwibWF4SHR0cEJ1ZmZlclNpemUiLCJpbml0aWFsUGFja2V0IiwiZW1pdCIsInJlc2V0UGluZ1RpbWVvdXQiLCJzY2hlZHVsZVBpbmciLCJvblBhY2tldCIsInBhY2tldCIsInR5cGUiLCJvbkVycm9yIiwiRXJyb3IiLCJyZWZyZXNoIiwiY2xlYXJUaW1lb3V0Iiwib25DbG9zZSIsImRhdGEiLCJlcnIiLCJzZXRUaW1lb3V0IiwiYmluZCIsIm9uUmVhZHkiLCJmbHVzaCIsIm9uRHJhaW4iLCJvbmNlIiwib24iLCJwdXNoIiwicmVtb3ZlTGlzdGVuZXIiLCJsZW5ndGgiLCJzZXFGbiIsInNoaWZ0IiwiaSIsIl9tYXliZVVwZ3JhZGUiLCJuYW1lIiwidXBncmFkZVRpbWVvdXRUaW1lciIsImNsZWFudXAiLCJjbG9zZSIsInVwZ3JhZGVUaW1lb3V0IiwiY2hlY2tJbnRlcnZhbFRpbWVyIiwic2VuZCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNoZWNrIiwiZGlzY2FyZCIsImNsZWFyVHJhbnNwb3J0Iiwid3JpdGFibGUiLCJvblRyYW5zcG9ydENsb3NlIiwidG9DbGVhblVwIiwicmVhc29uIiwiZGVzY3JpcHRpb24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJvcHRpb25zIiwiY2FsbGJhY2siLCJ3cml0ZSIsImNvbXByZXNzIiwid2J1ZiIsImF2YWlsYWJsZVVwZ3JhZGVzIiwiYWxsVXBncmFkZXMiLCJ1cGciLCJ0cmFuc3BvcnRzIiwiaW5kZXhPZiIsImNsb3NlVHJhbnNwb3J0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/socket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transport.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/transport.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Transport = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst parser_v4 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nconst parser_v3 = __webpack_require__(/*! ./parser-v3/index */ \"(rsc)/./node_modules/engine.io/build/parser-v3/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:transport\");\nfunction noop() {}\nclass Transport extends events_1.EventEmitter {\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s (%s)\", this._readyState, state, this.name);\n        this._readyState = state;\n    }\n    /**\n     * Transport constructor.\n     *\n     * @param {EngineRequest} req\n     */ constructor(req){\n        super();\n        /**\n         * Whether the transport is currently ready to send packets.\n         */ this.writable = false;\n        /**\n         * The current state of the transport.\n         * @protected\n         */ this._readyState = \"open\";\n        /**\n         * Whether the transport is discarded and can be safely closed (used during upgrade).\n         * @protected\n         */ this.discarded = false;\n        this.protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        this.parser = this.protocol === 4 ? parser_v4 : parser_v3;\n        this.supportsBinary = !(req._query && req._query.b64);\n    }\n    /**\n     * Flags the transport as discarded.\n     *\n     * @package\n     */ discard() {\n        this.discarded = true;\n    }\n    /**\n     * Called with an incoming HTTP request.\n     *\n     * @param req\n     * @package\n     */ onRequest(req) {}\n    /**\n     * Closes the transport.\n     *\n     * @package\n     */ close(fn) {\n        if (\"closed\" === this.readyState || \"closing\" === this.readyState) return;\n        this.readyState = \"closing\";\n        this.doClose(fn || noop);\n    }\n    /**\n     * Called with a transport error.\n     *\n     * @param {String} msg - message error\n     * @param {Object} desc - error description\n     * @protected\n     */ onError(msg, desc) {\n        if (this.listeners(\"error\").length) {\n            const err = new Error(msg);\n            // @ts-ignore\n            err.type = \"TransportError\";\n            // @ts-ignore\n            err.description = desc;\n            this.emit(\"error\", err);\n        } else {\n            debug(\"ignored transport error %s (%s)\", msg, desc);\n        }\n    }\n    /**\n     * Called with parsed out a packets from the data stream.\n     *\n     * @param {Object} packet\n     * @protected\n     */ onPacket(packet) {\n        this.emit(\"packet\", packet);\n    }\n    /**\n     * Called with the encoded packet data.\n     *\n     * @param {String} data\n     * @protected\n     */ onData(data) {\n        this.onPacket(this.parser.decodePacket(data));\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @protected\n     */ onClose() {\n        this.readyState = \"closed\";\n        this.emit(\"close\");\n    }\n}\nexports.Transport = Transport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyxrRkFBa0I7QUFDNUMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzdDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1JLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkMsU0FBU0MsUUFBUztBQUNsQixNQUFNUixrQkFBa0JDLFNBQVNRLFlBQVk7SUFDekMsSUFBSUMsYUFBYTtRQUNiLE9BQU8sSUFBSSxDQUFDQyxXQUFXO0lBQzNCO0lBQ0EsSUFBSUQsV0FBV0UsS0FBSyxFQUFFO1FBQ2xCTixNQUFNLHlDQUF5QyxJQUFJLENBQUNLLFdBQVcsRUFBRUMsT0FBTyxJQUFJLENBQUNDLElBQUk7UUFDakYsSUFBSSxDQUFDRixXQUFXLEdBQUdDO0lBQ3ZCO0lBQ0E7Ozs7S0FJQyxHQUNERSxZQUFZQyxHQUFHLENBQUU7UUFDYixLQUFLO1FBQ0w7O1NBRUMsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNMLFdBQVcsR0FBRztRQUNuQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNNLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFFBQVEsR0FBR0gsSUFBSUksTUFBTSxDQUFDQyxHQUFHLEtBQUssTUFBTSxJQUFJLEdBQUcsMEJBQTBCO1FBQzFFLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ0gsUUFBUSxLQUFLLElBQUlmLFlBQVlDO1FBQ2hELElBQUksQ0FBQ2tCLGNBQWMsR0FBRyxDQUFFUCxDQUFBQSxJQUFJSSxNQUFNLElBQUlKLElBQUlJLE1BQU0sQ0FBQ0ksR0FBRztJQUN4RDtJQUNBOzs7O0tBSUMsR0FDREMsVUFBVTtRQUNOLElBQUksQ0FBQ1AsU0FBUyxHQUFHO0lBQ3JCO0lBQ0E7Ozs7O0tBS0MsR0FDRFEsVUFBVVYsR0FBRyxFQUFFLENBQUU7SUFDakI7Ozs7S0FJQyxHQUNEVyxNQUFNQyxFQUFFLEVBQUU7UUFDTixJQUFJLGFBQWEsSUFBSSxDQUFDakIsVUFBVSxJQUFJLGNBQWMsSUFBSSxDQUFDQSxVQUFVLEVBQzdEO1FBQ0osSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDa0IsT0FBTyxDQUFDRCxNQUFNbkI7SUFDdkI7SUFDQTs7Ozs7O0tBTUMsR0FDRHFCLFFBQVFDLEdBQUcsRUFBRUMsSUFBSSxFQUFFO1FBQ2YsSUFBSSxJQUFJLENBQUNDLFNBQVMsQ0FBQyxTQUFTQyxNQUFNLEVBQUU7WUFDaEMsTUFBTUMsTUFBTSxJQUFJQyxNQUFNTDtZQUN0QixhQUFhO1lBQ2JJLElBQUlFLElBQUksR0FBRztZQUNYLGFBQWE7WUFDYkYsSUFBSUcsV0FBVyxHQUFHTjtZQUNsQixJQUFJLENBQUNPLElBQUksQ0FBQyxTQUFTSjtRQUN2QixPQUNLO1lBQ0Q1QixNQUFNLG1DQUFtQ3dCLEtBQUtDO1FBQ2xEO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEUSxTQUFTQyxNQUFNLEVBQUU7UUFDYixJQUFJLENBQUNGLElBQUksQ0FBQyxVQUFVRTtJQUN4QjtJQUNBOzs7OztLQUtDLEdBQ0RDLE9BQU9DLElBQUksRUFBRTtRQUNULElBQUksQ0FBQ0gsUUFBUSxDQUFDLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ3NCLFlBQVksQ0FBQ0Q7SUFDM0M7SUFDQTs7OztLQUlDLEdBQ0RFLFVBQVU7UUFDTixJQUFJLENBQUNsQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDNEIsSUFBSSxDQUFDO0lBQ2Q7QUFDSjtBQUNBeEMsaUJBQWlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmF2b2NoYXQtYXBwLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnQuanM/Mzc5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNwb3J0ID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgcGFyc2VyX3Y0ID0gcmVxdWlyZShcImVuZ2luZS5pby1wYXJzZXJcIik7XG5jb25zdCBwYXJzZXJfdjMgPSByZXF1aXJlKFwiLi9wYXJzZXItdjMvaW5kZXhcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp0cmFuc3BvcnRcIik7XG5mdW5jdGlvbiBub29wKCkgeyB9XG5jbGFzcyBUcmFuc3BvcnQgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgICB9XG4gICAgc2V0IHJlYWR5U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgZGVidWcoXCJyZWFkeVN0YXRlIHVwZGF0ZWQgZnJvbSAlcyB0byAlcyAoJXMpXCIsIHRoaXMuX3JlYWR5U3RhdGUsIHN0YXRlLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5naW5lUmVxdWVzdH0gcmVxXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB0cmFuc3BvcnQgaXMgY3VycmVudGx5IHJlYWR5IHRvIHNlbmQgcGFja2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0cmFuc3BvcnQuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcIm9wZW5cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRyYW5zcG9ydCBpcyBkaXNjYXJkZWQgYW5kIGNhbiBiZSBzYWZlbHkgY2xvc2VkICh1c2VkIGR1cmluZyB1cGdyYWRlKS5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNjYXJkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHJlcS5fcXVlcnkuRUlPID09PSBcIjRcIiA/IDQgOiAzOyAvLyAzcmQgcmV2aXNpb24gYnkgZGVmYXVsdFxuICAgICAgICB0aGlzLnBhcnNlciA9IHRoaXMucHJvdG9jb2wgPT09IDQgPyBwYXJzZXJfdjQgOiBwYXJzZXJfdjM7XG4gICAgICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSAhKHJlcS5fcXVlcnkgJiYgcmVxLl9xdWVyeS5iNjQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGFncyB0aGUgdHJhbnNwb3J0IGFzIGRpc2NhcmRlZC5cbiAgICAgKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgZGlzY2FyZCgpIHtcbiAgICAgICAgdGhpcy5kaXNjYXJkZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBhbiBpbmNvbWluZyBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBvblJlcXVlc3QocmVxKSB7IH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY2xvc2UoZm4pIHtcbiAgICAgICAgaWYgKFwiY2xvc2VkXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcImNsb3NpbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcbiAgICAgICAgdGhpcy5kb0Nsb3NlKGZuIHx8IG5vb3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBhIHRyYW5zcG9ydCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSBtZXNzYWdlIGVycm9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlc2MgLSBlcnJvciBkZXNjcmlwdGlvblxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkVycm9yKG1zZywgZGVzYykge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMoXCJlcnJvclwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZXJyLnR5cGUgPSBcIlRyYW5zcG9ydEVycm9yXCI7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaWdub3JlZCB0cmFuc3BvcnQgZXJyb3IgJXMgKCVzKVwiLCBtc2csIGRlc2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIHBhcnNlZCBvdXQgYSBwYWNrZXRzIGZyb20gdGhlIGRhdGEgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIHRoZSBlbmNvZGVkIHBhY2tldCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vblBhY2tldCh0aGlzLnBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc3BvcnQgPSBUcmFuc3BvcnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJUcmFuc3BvcnQiLCJldmVudHNfMSIsInJlcXVpcmUiLCJwYXJzZXJfdjQiLCJwYXJzZXJfdjMiLCJkZWJ1Z18xIiwiZGVidWciLCJkZWZhdWx0Iiwibm9vcCIsIkV2ZW50RW1pdHRlciIsInJlYWR5U3RhdGUiLCJfcmVhZHlTdGF0ZSIsInN0YXRlIiwibmFtZSIsImNvbnN0cnVjdG9yIiwicmVxIiwid3JpdGFibGUiLCJkaXNjYXJkZWQiLCJwcm90b2NvbCIsIl9xdWVyeSIsIkVJTyIsInBhcnNlciIsInN1cHBvcnRzQmluYXJ5IiwiYjY0IiwiZGlzY2FyZCIsIm9uUmVxdWVzdCIsImNsb3NlIiwiZm4iLCJkb0Nsb3NlIiwib25FcnJvciIsIm1zZyIsImRlc2MiLCJsaXN0ZW5lcnMiLCJsZW5ndGgiLCJlcnIiLCJFcnJvciIsInR5cGUiLCJkZXNjcmlwdGlvbiIsImVtaXQiLCJvblBhY2tldCIsInBhY2tldCIsIm9uRGF0YSIsImRhdGEiLCJkZWNvZGVQYWNrZXQiLCJvbkNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports-uws/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/./node_modules/engine.io/build/transports-uws/polling.js\");\nconst websocket_1 = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/engine.io/build/transports-uws/websocket.js\");\nexports[\"default\"] = {\n    polling: polling_1.Polling,\n    websocket: websocket_1.WebSocket\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFlBQVlDLG1CQUFPQSxDQUFDLGlGQUFXO0FBQ3JDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLHFGQUFhO0FBQ3pDSCxrQkFBZSxHQUFHO0lBQ2RNLFNBQVNKLFVBQVVLLE9BQU87SUFDMUJDLFdBQVdKLFlBQVlLLFNBQVM7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL2luZGV4LmpzPzE2YTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwb2xsaW5nXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nXCIpO1xuY29uc3Qgd2Vic29ja2V0XzEgPSByZXF1aXJlKFwiLi93ZWJzb2NrZXRcIik7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgcG9sbGluZzogcG9sbGluZ18xLlBvbGxpbmcsXG4gICAgd2Vic29ja2V0OiB3ZWJzb2NrZXRfMS5XZWJTb2NrZXQsXG59O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicG9sbGluZ18xIiwicmVxdWlyZSIsIndlYnNvY2tldF8xIiwiZGVmYXVsdCIsInBvbGxpbmciLCJQb2xsaW5nIiwid2Vic29ja2V0IiwiV2ViU29ja2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports-uws/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports-uws/polling.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/polling.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Polling = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     */ constructor(req){\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"polling\";\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param req\n     *\n     * @private\n     */ onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (req.getMethod() === \"get\") {\n            this.onPollRequest(req, res);\n        } else if (req.getMethod() === \"post\") {\n            this.onDataRequest(req, res);\n        } else {\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @private\n     */ onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = ()=>{\n            this.writable = false;\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = ()=>{\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        res.onAborted(onClose);\n        this.writable = true;\n        this.emit(\"ready\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @private\n     */ onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        const expectedContentLength = Number(req.headers[\"content-length\"]);\n        if (!expectedContentLength) {\n            this.onError(\"content-length header required\");\n            res.writeStatus(\"411 Length Required\").end();\n            return;\n        }\n        if (expectedContentLength > this.maxHttpBufferSize) {\n            this.onError(\"payload too large\");\n            res.writeStatus(\"413 Payload Too Large\").end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let buffer;\n        let offset = 0;\n        const headers = {\n            // text/html is required instead of text/plain to avoid an\n            // unwanted download dialog on certain user-agents (GH-43)\n            \"Content-Type\": \"text/html\"\n        };\n        this.headers(req, headers);\n        for(let key in headers){\n            res.writeHeader(key, String(headers[key]));\n        }\n        const onEnd = (buffer)=>{\n            this.onData(buffer.toString());\n            this.onDataRequestCleanup();\n            res.cork(()=>{\n                res.end(\"ok\");\n            });\n        };\n        res.onAborted(()=>{\n            this.onDataRequestCleanup();\n            this.onError(\"data request connection closed prematurely\");\n        });\n        res.onData((arrayBuffer, isLast)=>{\n            const totalLength = offset + arrayBuffer.byteLength;\n            if (totalLength > expectedContentLength) {\n                this.onError(\"content-length mismatch\");\n                res.close(); // calls onAborted\n                return;\n            }\n            if (!buffer) {\n                if (isLast) {\n                    onEnd(Buffer.from(arrayBuffer));\n                    return;\n                }\n                buffer = Buffer.allocUnsafe(expectedContentLength);\n            }\n            Buffer.from(arrayBuffer).copy(buffer, offset);\n            if (isLast) {\n                if (totalLength != expectedContentLength) {\n                    this.onError(\"content-length mismatch\");\n                    res.writeStatus(\"400 Content-Length Mismatch\").end();\n                    this.onDataRequestCleanup();\n                    return;\n                }\n                onEnd(buffer);\n                return;\n            }\n            offset = totalLength;\n        });\n    }\n    /**\n     * Cleanup request.\n     *\n     * @private\n     */ onDataRequestCleanup() {\n        this.dataReq = this.dataRes = null;\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param {String} encoded payload\n     * @private\n     */ onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet)=>{\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        } else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @private\n     */ onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n        super.onClose();\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Object} packet\n     * @private\n     */ send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({\n                type: \"close\"\n            });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data)=>{\n            const compress = packets.some((packet)=>{\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, {\n                compress\n            });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        } else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @private\n     */ write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, ()=>{\n            this.req.cleanup();\n            this.emit(\"drain\");\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @private\n     */ doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType\n        };\n        const respond = (data)=>{\n            this.headers(this.req, headers);\n            this.res.cork(()=>{\n                Object.keys(headers).forEach((key)=>{\n                    this.res.writeHeader(key, String(headers[key]));\n                });\n                this.res.end(data);\n            });\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\n            \"gzip\",\n            \"deflate\"\n        ]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data)=>{\n            if (err) {\n                this.res.writeStatus(\"500 Internal Server Error\");\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @private\n     */ compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function(chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        }).on(\"end\", function() {\n            callback(null, Buffer.concat(buffers, nread));\n        }).end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */ doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        const onClose = ()=>{\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([\n                {\n                    type: \"close\"\n                }\n            ]);\n            onClose();\n        } else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        } else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param req - request\n     * @param {Object} extra headers\n     * @private\n     */ headers(req, headers) {\n        headers = headers || {};\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3BvbGxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzFDLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLGtCQUFNO0FBQzdCLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHNEQUFTO0FBQ2pDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1JLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkMsTUFBTUMscUJBQXFCO0lBQ3ZCQyxNQUFNTixPQUFPTyxVQUFVO0lBQ3ZCQyxTQUFTUixPQUFPUyxhQUFhO0FBQ2pDO0FBQ0EsTUFBTVosZ0JBQWdCQyxZQUFZWSxTQUFTO0lBQ3ZDOztLQUVDLEdBQ0RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLFlBQVksR0FBRyxLQUFLO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0E7Ozs7OztLQU1DLEdBQ0RDLFVBQVVILEdBQUcsRUFBRTtRQUNYLE1BQU1JLE1BQU1KLElBQUlJLEdBQUc7UUFDbkIsdUhBQXVIO1FBQ3ZISixJQUFJSSxHQUFHLEdBQUc7UUFDVixJQUFJSixJQUFJSyxTQUFTLE9BQU8sT0FBTztZQUMzQixJQUFJLENBQUNDLGFBQWEsQ0FBQ04sS0FBS0k7UUFDNUIsT0FDSyxJQUFJSixJQUFJSyxTQUFTLE9BQU8sUUFBUTtZQUNqQyxJQUFJLENBQUNFLGFBQWEsQ0FBQ1AsS0FBS0k7UUFDNUIsT0FDSztZQUNEQSxJQUFJSSxXQUFXLENBQUM7WUFDaEJKLElBQUlLLEdBQUc7UUFDWDtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNE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S3BGLElBQUlzQixPQUFPLENBQUMsYUFBYTtRQUNwQyxJQUFJOEQsTUFBTyxFQUFDQSxHQUFHQyxPQUFPLENBQUMsWUFBWSxDQUFDRCxHQUFHQyxPQUFPLENBQUMsV0FBVSxHQUFJO1lBQ3pEL0QsT0FBTyxDQUFDLG1CQUFtQixHQUFHO1FBQ2xDO1FBQ0FBLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRztRQUMzQixJQUFJLENBQUNQLElBQUksQ0FBQyxXQUFXTyxTQUFTdEI7UUFDOUIsT0FBT3NCO0lBQ1g7QUFDSjtBQUNBdkMsZUFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Jhdm9jaGF0LWFwcC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy11d3MvcG9sbGluZy5qcz83MmE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBhY2NlcHRzID0gcmVxdWlyZShcImFjY2VwdHNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTpwb2xsaW5nXCIpO1xuY29uc3QgY29tcHJlc3Npb25NZXRob2RzID0ge1xuICAgIGd6aXA6IHpsaWJfMS5jcmVhdGVHemlwLFxuICAgIGRlZmxhdGU6IHpsaWJfMS5jcmVhdGVEZWZsYXRlLFxufTtcbmNsYXNzIFBvbGxpbmcgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIEhUVFAgcG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIocmVxKTtcbiAgICAgICAgdGhpcy5jbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcInBvbGxpbmdcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIG9uUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25SZXF1ZXN0KHJlcSkge1xuICAgICAgICBjb25zdCByZXMgPSByZXEucmVzO1xuICAgICAgICAvLyByZW1vdmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgU2VydmVyUmVzcG9uc2Ugb2JqZWN0IChhcyB0aGUgZmlyc3QgcmVxdWVzdCBvZiB0aGUgc2Vzc2lvbiBpcyBrZXB0IGluIG1lbW9yeSBieSBkZWZhdWx0KVxuICAgICAgICByZXEucmVzID0gbnVsbDtcbiAgICAgICAgaWYgKHJlcS5nZXRNZXRob2QoKSA9PT0gXCJnZXRcIikge1xuICAgICAgICAgICAgdGhpcy5vblBvbGxSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXEuZ2V0TWV0aG9kKCkgPT09IFwicG9zdFwiKSB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNTAwIEludGVybmFsIFNlcnZlciBFcnJvclwiKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHNlbmRzIGEgcmVxdWVzdCBhd2FpdGluZyBmb3IgdXMgdG8gc2VuZCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvblBvbGxSZXF1ZXN0KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcSkge1xuICAgICAgICAgICAgZGVidWcoXCJyZXF1ZXN0IG92ZXJsYXBcIik7XG4gICAgICAgICAgICAvLyBhc3NlcnQ6IHRoaXMucmVzLCAnLnJlcSBhbmQgLnJlcyBzaG91bGQgYmUgKHVuKXNldCB0b2dldGhlcidcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcIm92ZXJsYXAgZnJvbSBjbGllbnRcIik7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI1MDAgSW50ZXJuYWwgU2VydmVyIEVycm9yXCIpO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwic2V0dGluZyByZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJwb2xsIGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5XCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXEgPSB0aGlzLnJlcyA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJlcS5jbGVhbnVwID0gY2xlYW51cDtcbiAgICAgICAgcmVzLm9uQWJvcnRlZChvbkNsb3NlKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcInJlYWR5XCIpO1xuICAgICAgICAvLyBpZiB3ZSdyZSBzdGlsbCB3cml0YWJsZSBidXQgaGFkIGEgcGVuZGluZyBjbG9zZSwgdHJpZ2dlciBhbiBlbXB0eSBzZW5kXG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlICYmIHRoaXMuc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJpZ2dlcmluZyBlbXB0eSBzZW5kIHRvIGFwcGVuZCBjbG9zZSBwYWNrZXRcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYSByZXF1ZXN0IHdpdGggZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25EYXRhUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBpZiAodGhpcy5kYXRhUmVxKSB7XG4gICAgICAgICAgICAvLyBhc3NlcnQ6IHRoaXMuZGF0YVJlcywgJy5kYXRhUmVxIGFuZCAuZGF0YVJlcyBzaG91bGQgYmUgKHVuKXNldCB0b2dldGhlcidcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImRhdGEgcmVxdWVzdCBvdmVybGFwIGZyb20gY2xpZW50XCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNTAwIEludGVybmFsIFNlcnZlciBFcnJvclwiKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBlY3RlZENvbnRlbnRMZW5ndGggPSBOdW1iZXIocmVxLmhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSk7XG4gICAgICAgIGlmICghZXhwZWN0ZWRDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJjb250ZW50LWxlbmd0aCBoZWFkZXIgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI0MTEgTGVuZ3RoIFJlcXVpcmVkXCIpLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZENvbnRlbnRMZW5ndGggPiB0aGlzLm1heEh0dHBCdWZmZXJTaXplKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJwYXlsb2FkIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjQxMyBQYXlsb2FkIFRvbyBMYXJnZVwiKS5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0JpbmFyeSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgPT09IHJlcS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdO1xuICAgICAgICBpZiAoaXNCaW5hcnkgJiYgdGhpcy5wcm90b2NvbCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FcnJvcihcImludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFSZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZGF0YVJlcyA9IHJlcztcbiAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAvLyB0ZXh0L2h0bWwgaXMgcmVxdWlyZWQgaW5zdGVhZCBvZiB0ZXh0L3BsYWluIHRvIGF2b2lkIGFuXG4gICAgICAgICAgICAvLyB1bndhbnRlZCBkb3dubG9hZCBkaWFsb2cgb24gY2VydGFpbiB1c2VyLWFnZW50cyAoR0gtNDMpXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvaHRtbFwiLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhlYWRlcnMocmVxLCBoZWFkZXJzKTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWRlcihrZXksIFN0cmluZyhoZWFkZXJzW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkVuZCA9IChidWZmZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKGJ1ZmZlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHRoaXMub25EYXRhUmVxdWVzdENsZWFudXAoKTtcbiAgICAgICAgICAgIHJlcy5jb3JrKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXMuZW5kKFwib2tcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLm9uQWJvcnRlZCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3RDbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3QgY29ubmVjdGlvbiBjbG9zZWQgcHJlbWF0dXJlbHlcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXMub25EYXRhKChhcnJheUJ1ZmZlciwgaXNMYXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IG9mZnNldCArIGFycmF5QnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAodG90YWxMZW5ndGggPiBleHBlY3RlZENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJjb250ZW50LWxlbmd0aCBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgICAgICByZXMuY2xvc2UoKTsgLy8gY2FsbHMgb25BYm9ydGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRW5kKEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGV4cGVjdGVkQ29udGVudExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikuY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsTGVuZ3RoICE9IGV4cGVjdGVkQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJjb250ZW50LWxlbmd0aCBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNDAwIENvbnRlbnQtTGVuZ3RoIE1pc21hdGNoXCIpLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3RDbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25FbmQoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSB0b3RhbExlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFudXAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25EYXRhUmVxdWVzdENsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuZGF0YVJlcSA9IHRoaXMuZGF0YVJlcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgaW5jb21pbmcgZGF0YSBwYXlsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kZWQgcGF5bG9hZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3JlY2VpdmVkIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGlmIChcImNsb3NlXCIgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgeGhyIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSkuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIG9uQ2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAvLyBjbG9zZSBwZW5kaW5nIHBvbGwgcmVxdWVzdFxuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5vbkNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldCBwYXlsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYXBwZW5kaW5nIGNsb3NlIHBhY2tldCB0byBwYXlsb2FkXCIpO1xuICAgICAgICAgICAgcGFja2V0cy5wdXNoKHsgdHlwZTogXCJjbG9zZVwiIH0pO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9Xcml0ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21wcmVzcyA9IHBhY2tldHMuc29tZSgocGFja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldC5vcHRpb25zICYmIHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlKGRhdGEsIHsgY29tcHJlc3MgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGRvV3JpdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCBkb1dyaXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgZGF0YSBhcyByZXNwb25zZSB0byBwb2xsIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB3cml0ZShkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGRlYnVnKCd3cml0aW5nIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICB0aGlzLmRvV3JpdGUoZGF0YSwgb3B0aW9ucywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXEuY2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgd3JpdGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvV3JpdGUoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gZXhwbGljaXQgVVRGLTggaXMgcmVxdWlyZWQgZm9yIHBhZ2VzIG5vdCBzZXJ2ZWQgdW5kZXIgdXRmXG4gICAgICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaXNTdHJpbmdcbiAgICAgICAgICAgID8gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PVVURi04XCJcbiAgICAgICAgICAgIDogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGNvbnRlbnRUeXBlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25kID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyh0aGlzLnJlcSwgaGVhZGVycyk7XG4gICAgICAgICAgICB0aGlzLnJlcy5jb3JrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVIZWFkZXIoa2V5LCBTdHJpbmcoaGVhZGVyc1trZXldKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXMuZW5kKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuaHR0cENvbXByZXNzaW9uIHx8ICFvcHRpb25zLmNvbXByZXNzKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGlzU3RyaW5nID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IHRoaXMuaHR0cENvbXByZXNzaW9uLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGluZyA9IGFjY2VwdHModGhpcy5yZXEpLmVuY29kaW5ncyhbXCJnemlwXCIsIFwiZGVmbGF0ZVwiXSk7XG4gICAgICAgIGlmICghZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wcmVzcyhkYXRhLCBlbmNvZGluZywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLndyaXRlU3RhdHVzKFwiNTAwIEludGVybmFsIFNlcnZlciBFcnJvclwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LUVuY29kaW5nXCJdID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHJlc3NlcyBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb21wcmVzcyhkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgZGVidWcoXCJjb21wcmVzc2luZ1wiKTtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgICBsZXQgbnJlYWQgPSAwO1xuICAgICAgICBjb21wcmVzc2lvbk1ldGhvZHNbZW5jb2RpbmddKHRoaXMuaHR0cENvbXByZXNzaW9uKVxuICAgICAgICAgICAgLm9uKFwiZXJyb3JcIiwgY2FsbGJhY2spXG4gICAgICAgICAgICAub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZW5kKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmdcIik7XG4gICAgICAgIGxldCBjbG9zZVRpbWVvdXRUaW1lcjtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCB3cml0YWJsZSAtIGNsb3NpbmcgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcImNsb3NlXCIgfV0pO1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzY2FyZGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBkaXNjYXJkZWQgLSBjbG9zaW5nIHJpZ2h0IGF3YXlcIik7XG4gICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBub3Qgd3JpdGFibGUgLSBidWZmZXJpbmcgb3JkZXJseSBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UgPSBvbkNsb3NlO1xuICAgICAgICAgICAgY2xvc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KG9uQ2xvc2UsIHRoaXMuY2xvc2VUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhlYWRlcnMgZm9yIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxIC0gcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSBoZWFkZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBoZWFkZXJzKHJlcSwgaGVhZGVycykge1xuICAgICAgICBoZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgLy8gcHJldmVudCBYU1Mgd2FybmluZ3Mgb24gSUVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYXJuQm9vc3Qvc29ja2V0LmlvL3B1bGwvMTMzM1xuICAgICAgICBjb25zdCB1YSA9IHJlcS5oZWFkZXJzW1widXNlci1hZ2VudFwiXTtcbiAgICAgICAgaWYgKHVhICYmICh+dWEuaW5kZXhPZihcIjtNU0lFXCIpIHx8IH51YS5pbmRleE9mKFwiVHJpZGVudC9cIikpKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1YU1MtUHJvdGVjdGlvblwiXSA9IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnNbXCJjYWNoZS1jb250cm9sXCJdID0gXCJuby1zdG9yZVwiO1xuICAgICAgICB0aGlzLmVtaXQoXCJoZWFkZXJzXCIsIGhlYWRlcnMsIHJlcSk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9sbGluZyA9IFBvbGxpbmc7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb2xsaW5nIiwidHJhbnNwb3J0XzEiLCJyZXF1aXJlIiwiemxpYl8xIiwiYWNjZXB0cyIsImRlYnVnXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJjb21wcmVzc2lvbk1ldGhvZHMiLCJnemlwIiwiY3JlYXRlR3ppcCIsImRlZmxhdGUiLCJjcmVhdGVEZWZsYXRlIiwiVHJhbnNwb3J0IiwiY29uc3RydWN0b3IiLCJyZXEiLCJjbG9zZVRpbWVvdXQiLCJuYW1lIiwib25SZXF1ZXN0IiwicmVzIiwiZ2V0TWV0aG9kIiwib25Qb2xsUmVxdWVzdCIsIm9uRGF0YVJlcXVlc3QiLCJ3cml0ZVN0YXR1cyIsImVuZCIsIm9uRXJyb3IiLCJvbkNsb3NlIiwid3JpdGFibGUiLCJjbGVhbnVwIiwib25BYm9ydGVkIiwiZW1pdCIsInNob3VsZENsb3NlIiwic2VuZCIsInR5cGUiLCJkYXRhUmVxIiwiZXhwZWN0ZWRDb250ZW50TGVuZ3RoIiwiTnVtYmVyIiwiaGVhZGVycyIsIm1heEh0dHBCdWZmZXJTaXplIiwiaXNCaW5hcnkiLCJwcm90b2NvbCIsImRhdGFSZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJrZXkiLCJ3cml0ZUhlYWRlciIsIlN0cmluZyIsIm9uRW5kIiwib25EYXRhIiwidG9TdHJpbmciLCJvbkRhdGFSZXF1ZXN0Q2xlYW51cCIsImNvcmsiLCJhcnJheUJ1ZmZlciIsImlzTGFzdCIsInRvdGFsTGVuZ3RoIiwiYnl0ZUxlbmd0aCIsImNsb3NlIiwiQnVmZmVyIiwiZnJvbSIsImFsbG9jVW5zYWZlIiwiY29weSIsImRhdGEiLCJjYWxsYmFjayIsInBhY2tldCIsIm9uUGFja2V0IiwicGFyc2VyIiwiZGVjb2RlUGF5bG9hZCIsImZvckVhY2giLCJwYWNrZXRzIiwicHVzaCIsImRvV3JpdGUiLCJjb21wcmVzcyIsInNvbWUiLCJvcHRpb25zIiwid3JpdGUiLCJlbmNvZGVQYXlsb2FkIiwic3VwcG9ydHNCaW5hcnkiLCJpc1N0cmluZyIsImNvbnRlbnRUeXBlIiwicmVzcG9uZCIsImtleXMiLCJodHRwQ29tcHJlc3Npb24iLCJsZW4iLCJsZW5ndGgiLCJ0aHJlc2hvbGQiLCJlbmNvZGluZyIsImVuY29kaW5ncyIsImVyciIsImJ1ZmZlcnMiLCJucmVhZCIsIm9uIiwiY2h1bmsiLCJjb25jYXQiLCJkb0Nsb3NlIiwiZm4iLCJjbG9zZVRpbWVvdXRUaW1lciIsImNsZWFyVGltZW91dCIsImRpc2NhcmRlZCIsInNldFRpbWVvdXQiLCJ1YSIsImluZGV4T2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports-uws/polling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports-uws/websocket.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/websocket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocket = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:ws\");\nclass WebSocket extends transport_1.Transport {\n    /**\n     * WebSocket transport\n     *\n     * @param req\n     */ constructor(req){\n        super(req);\n        this.writable = false;\n        this.perMessageDeflate = null;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"websocket\";\n    }\n    /**\n     * Advertise upgrade support.\n     */ get handlesUpgrades() {\n        return true;\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Array} packets\n     * @private\n     */ send(packets) {\n        this.writable = false;\n        for(let i = 0; i < packets.length; i++){\n            const packet = packets[i];\n            const isLast = i + 1 === packets.length;\n            const send = (data)=>{\n                const isBinary = typeof data !== \"string\";\n                const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;\n                debug('writing \"%s\"', data);\n                this.socket.send(data, isBinary, compress);\n                if (isLast) {\n                    this.emit(\"drain\");\n                    this.writable = true;\n                    this.emit(\"ready\");\n                }\n            };\n            if (packet.options && typeof packet.options.wsPreEncoded === \"string\") {\n                send(packet.options.wsPreEncoded);\n            } else {\n                this.parser.encodePacket(packet, this.supportsBinary, send);\n            }\n        }\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */ doClose(fn) {\n        debug(\"closing\");\n        fn && fn();\n        // call fn first since socket.end() immediately emits a \"close\" event\n        this.socket.end();\n    }\n}\nexports.WebSocket = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQyx1RUFBYztBQUMxQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyw2RUFBTztBQUMvQixNQUFNRSxRQUFRLENBQUMsR0FBR0QsUUFBUUUsT0FBTyxFQUFFO0FBQ25DLE1BQU1MLGtCQUFrQkMsWUFBWUssU0FBUztJQUN6Qzs7OztLQUlDLEdBQ0RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxrQkFBa0I7UUFDbEIsT0FBTztJQUNYO0lBQ0E7Ozs7O0tBS0MsR0FDREMsS0FBS0MsT0FBTyxFQUFFO1FBQ1YsSUFBSSxDQUFDTCxRQUFRLEdBQUc7UUFDaEIsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlELFFBQVFFLE1BQU0sRUFBRUQsSUFBSztZQUNyQyxNQUFNRSxTQUFTSCxPQUFPLENBQUNDLEVBQUU7WUFDekIsTUFBTUcsU0FBU0gsSUFBSSxNQUFNRCxRQUFRRSxNQUFNO1lBQ3ZDLE1BQU1ILE9BQU8sQ0FBQ007Z0JBQ1YsTUFBTUMsV0FBVyxPQUFPRCxTQUFTO2dCQUNqQyxNQUFNRSxXQUFXLElBQUksQ0FBQ1gsaUJBQWlCLElBQ25DWSxPQUFPQyxVQUFVLENBQUNKLFFBQVEsSUFBSSxDQUFDVCxpQkFBaUIsQ0FBQ2MsU0FBUztnQkFDOURwQixNQUFNLGdCQUFnQmU7Z0JBQ3RCLElBQUksQ0FBQ00sTUFBTSxDQUFDWixJQUFJLENBQUNNLE1BQU1DLFVBQVVDO2dCQUNqQyxJQUFJSCxRQUFRO29CQUNSLElBQUksQ0FBQ1EsSUFBSSxDQUFDO29CQUNWLElBQUksQ0FBQ2pCLFFBQVEsR0FBRztvQkFDaEIsSUFBSSxDQUFDaUIsSUFBSSxDQUFDO2dCQUNkO1lBQ0o7WUFDQSxJQUFJVCxPQUFPVSxPQUFPLElBQUksT0FBT1YsT0FBT1UsT0FBTyxDQUFDQyxZQUFZLEtBQUssVUFBVTtnQkFDbkVmLEtBQUtJLE9BQU9VLE9BQU8sQ0FBQ0MsWUFBWTtZQUNwQyxPQUNLO2dCQUNELElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxZQUFZLENBQUNiLFFBQVEsSUFBSSxDQUFDYyxjQUFjLEVBQUVsQjtZQUMxRDtRQUNKO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RtQixRQUFRQyxFQUFFLEVBQUU7UUFDUjdCLE1BQU07UUFDTjZCLE1BQU1BO1FBQ04scUVBQXFFO1FBQ3JFLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxHQUFHO0lBQ25CO0FBQ0o7QUFDQXBDLGlCQUFpQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Jhdm9jaGF0LWFwcC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy11d3Mvd2Vic29ja2V0LmpzP2EzODUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydFwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOndzXCIpO1xuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgdHJhbnNwb3J0XzEuVHJhbnNwb3J0IHtcbiAgICAvKipcbiAgICAgKiBXZWJTb2NrZXQgdHJhbnNwb3J0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIndlYnNvY2tldFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZHZlcnRpc2UgdXBncmFkZSBzdXBwb3J0LlxuICAgICAqL1xuICAgIGdldCBoYW5kbGVzVXBncmFkZXMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNlbmQocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gcGFja2V0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IGkgKyAxID09PSBwYWNrZXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHNlbmQgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3MgPSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpID4gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3dyaXRpbmcgXCIlc1wiJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhLCBpc0JpbmFyeSwgY29tcHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWFkeVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zICYmIHR5cGVvZiBwYWNrZXQub3B0aW9ucy53c1ByZUVuY29kZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBzZW5kKHBhY2tldC5vcHRpb25zLndzUHJlRW5jb2RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBzZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmdcIik7XG4gICAgICAgIGZuICYmIGZuKCk7XG4gICAgICAgIC8vIGNhbGwgZm4gZmlyc3Qgc2luY2Ugc29ja2V0LmVuZCgpIGltbWVkaWF0ZWx5IGVtaXRzIGEgXCJjbG9zZVwiIGV2ZW50XG4gICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViU29ja2V0ID0gV2ViU29ja2V0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiV2ViU29ja2V0IiwidHJhbnNwb3J0XzEiLCJyZXF1aXJlIiwiZGVidWdfMSIsImRlYnVnIiwiZGVmYXVsdCIsIlRyYW5zcG9ydCIsImNvbnN0cnVjdG9yIiwicmVxIiwid3JpdGFibGUiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsIm5hbWUiLCJoYW5kbGVzVXBncmFkZXMiLCJzZW5kIiwicGFja2V0cyIsImkiLCJsZW5ndGgiLCJwYWNrZXQiLCJpc0xhc3QiLCJkYXRhIiwiaXNCaW5hcnkiLCJjb21wcmVzcyIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJ0aHJlc2hvbGQiLCJzb2NrZXQiLCJlbWl0Iiwib3B0aW9ucyIsIndzUHJlRW5jb2RlZCIsInBhcnNlciIsImVuY29kZVBhY2tldCIsInN1cHBvcnRzQmluYXJ5IiwiZG9DbG9zZSIsImZuIiwiZW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports-uws/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io/build/transports/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/./node_modules/engine.io/build/transports/polling.js\");\nconst polling_jsonp_1 = __webpack_require__(/*! ./polling-jsonp */ \"(rsc)/./node_modules/engine.io/build/transports/polling-jsonp.js\");\nconst websocket_1 = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/engine.io/build/transports/websocket.js\");\nconst webtransport_1 = __webpack_require__(/*! ./webtransport */ \"(rsc)/./node_modules/engine.io/build/transports/webtransport.js\");\nexports[\"default\"] = {\n    polling: polling,\n    websocket: websocket_1.WebSocket,\n    webtransport: webtransport_1.WebTransport\n};\n/**\n * Polling polymorphic constructor.\n */ function polling(req) {\n    if (\"string\" === typeof req._query.j) {\n        return new polling_jsonp_1.JSONP(req);\n    } else {\n        return new polling_1.Polling(req);\n    }\n}\npolling.upgradesTo = [\n    \"websocket\",\n    \"webtransport\"\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsWUFBWUMsbUJBQU9BLENBQUMsNkVBQVc7QUFDckMsTUFBTUMsa0JBQWtCRCxtQkFBT0EsQ0FBQyx5RkFBaUI7QUFDakQsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsaUZBQWE7QUFDekMsTUFBTUcsaUJBQWlCSCxtQkFBT0EsQ0FBQyx1RkFBZ0I7QUFDL0NILGtCQUFlLEdBQUc7SUFDZFEsU0FBU0E7SUFDVEMsV0FBV0osWUFBWUssU0FBUztJQUNoQ0MsY0FBY0wsZUFBZU0sWUFBWTtBQUM3QztBQUNBOztDQUVDLEdBQ0QsU0FBU0osUUFBUUssR0FBRztJQUNoQixJQUFJLGFBQWEsT0FBT0EsSUFBSUMsTUFBTSxDQUFDQyxDQUFDLEVBQUU7UUFDbEMsT0FBTyxJQUFJWCxnQkFBZ0JZLEtBQUssQ0FBQ0g7SUFDckMsT0FDSztRQUNELE9BQU8sSUFBSVgsVUFBVWUsT0FBTyxDQUFDSjtJQUNqQztBQUNKO0FBQ0FMLFFBQVFVLFVBQVUsR0FBRztJQUFDO0lBQWE7Q0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3Jhdm9jaGF0LWFwcC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy9pbmRleC5qcz8wNzVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcG9sbGluZ18xID0gcmVxdWlyZShcIi4vcG9sbGluZ1wiKTtcbmNvbnN0IHBvbGxpbmdfanNvbnBfMSA9IHJlcXVpcmUoXCIuL3BvbGxpbmctanNvbnBcIik7XG5jb25zdCB3ZWJzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3dlYnNvY2tldFwiKTtcbmNvbnN0IHdlYnRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vd2VidHJhbnNwb3J0XCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIHBvbGxpbmc6IHBvbGxpbmcsXG4gICAgd2Vic29ja2V0OiB3ZWJzb2NrZXRfMS5XZWJTb2NrZXQsXG4gICAgd2VidHJhbnNwb3J0OiB3ZWJ0cmFuc3BvcnRfMS5XZWJUcmFuc3BvcnQsXG59O1xuLyoqXG4gKiBQb2xsaW5nIHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICovXG5mdW5jdGlvbiBwb2xsaW5nKHJlcSkge1xuICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgcmVxLl9xdWVyeS5qKSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9sbGluZ19qc29ucF8xLkpTT05QKHJlcSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IHBvbGxpbmdfMS5Qb2xsaW5nKHJlcSk7XG4gICAgfVxufVxucG9sbGluZy51cGdyYWRlc1RvID0gW1wid2Vic29ja2V0XCIsIFwid2VidHJhbnNwb3J0XCJdO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicG9sbGluZ18xIiwicmVxdWlyZSIsInBvbGxpbmdfanNvbnBfMSIsIndlYnNvY2tldF8xIiwid2VidHJhbnNwb3J0XzEiLCJkZWZhdWx0IiwicG9sbGluZyIsIndlYnNvY2tldCIsIldlYlNvY2tldCIsIndlYnRyYW5zcG9ydCIsIldlYlRyYW5zcG9ydCIsInJlcSIsIl9xdWVyeSIsImoiLCJKU09OUCIsIlBvbGxpbmciLCJ1cGdyYWRlc1RvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/polling-jsonp.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling-jsonp.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JSONP = void 0;\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/./node_modules/engine.io/build/transports/polling.js\");\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst rDoubleSlashes = /\\\\\\\\n/g;\nconst rSlashes = /(\\\\)?\\\\n/g;\nclass JSONP extends polling_1.Polling {\n    /**\n     * JSON-P polling transport.\n     */ constructor(req){\n        super(req);\n        this.head = \"___eio[\" + (req._query.j || \"\").replace(/[^0-9]/g, \"\") + \"](\";\n        this.foot = \");\";\n    }\n    onData(data) {\n        // we leverage the qs module so that we get built-in DoS protection\n        // and the fast alternative to decodeURIComponent\n        data = qs.parse(data).d;\n        if (\"string\" === typeof data) {\n            // client will send already escaped newlines as \\\\\\\\n and newlines as \\\\n\n            // \\\\n must be replaced with \\n and \\\\\\\\n with \\\\n\n            data = data.replace(rSlashes, function(match, slashes) {\n                return slashes ? match : \"\\n\";\n            });\n            super.onData(data.replace(rDoubleSlashes, \"\\\\n\"));\n        }\n    }\n    doWrite(data, options, callback) {\n        // we must output valid javascript, not valid json\n        // see: http://timelessrepo.com/json-isnt-a-javascript-subset\n        const js = JSON.stringify(data).replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n        // prepare response\n        data = this.head + js + this.foot;\n        super.doWrite(data, options, callback);\n    }\n}\nexports.JSONP = JSONP;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHLEtBQUs7QUFDckIsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMsNkVBQVc7QUFDckMsTUFBTUMsS0FBS0QsbUJBQU9BLENBQUMsZ0NBQWE7QUFDaEMsTUFBTUUsaUJBQWlCO0FBQ3ZCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUwsY0FBY0MsVUFBVUssT0FBTztJQUNqQzs7S0FFQyxHQUNEQyxZQUFZQyxHQUFHLENBQUU7UUFDYixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUcsWUFBWSxDQUFDRCxJQUFJRSxNQUFNLENBQUNDLENBQUMsSUFBSSxFQUFDLEVBQUdDLE9BQU8sQ0FBQyxXQUFXLE1BQU07UUFDdEUsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7SUFDQUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1QsbUVBQW1FO1FBQ25FLGlEQUFpRDtRQUNqREEsT0FBT1osR0FBR2EsS0FBSyxDQUFDRCxNQUFNRSxDQUFDO1FBQ3ZCLElBQUksYUFBYSxPQUFPRixNQUFNO1lBQzFCLHlFQUF5RTtZQUN6RSxrREFBa0Q7WUFDbERBLE9BQU9BLEtBQUtILE9BQU8sQ0FBQ1AsVUFBVSxTQUFVYSxLQUFLLEVBQUVDLE9BQU87Z0JBQ2xELE9BQU9BLFVBQVVELFFBQVE7WUFDN0I7WUFDQSxLQUFLLENBQUNKLE9BQU9DLEtBQUtILE9BQU8sQ0FBQ1IsZ0JBQWdCO1FBQzlDO0lBQ0o7SUFDQWdCLFFBQVFMLElBQUksRUFBRU0sT0FBTyxFQUFFQyxRQUFRLEVBQUU7UUFDN0Isa0RBQWtEO1FBQ2xELDZEQUE2RDtRQUM3RCxNQUFNQyxLQUFLQyxLQUFLQyxTQUFTLENBQUNWLE1BQ3JCSCxPQUFPLENBQUMsV0FBVyxXQUNuQkEsT0FBTyxDQUFDLFdBQVc7UUFDeEIsbUJBQW1CO1FBQ25CRyxPQUFPLElBQUksQ0FBQ04sSUFBSSxHQUFHYyxLQUFLLElBQUksQ0FBQ1YsSUFBSTtRQUNqQyxLQUFLLENBQUNPLFFBQVFMLE1BQU1NLFNBQVNDO0lBQ2pDO0FBQ0o7QUFDQXhCLGFBQWEsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcz9kNTRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KU09OUCA9IHZvaWQgMDtcbmNvbnN0IHBvbGxpbmdfMSA9IHJlcXVpcmUoXCIuL3BvbGxpbmdcIik7XG5jb25zdCBxcyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IHJEb3VibGVTbGFzaGVzID0gL1xcXFxcXFxcbi9nO1xuY29uc3QgclNsYXNoZXMgPSAvKFxcXFwpP1xcXFxuL2c7XG5jbGFzcyBKU09OUCBleHRlbmRzIHBvbGxpbmdfMS5Qb2xsaW5nIHtcbiAgICAvKipcbiAgICAgKiBKU09OLVAgcG9sbGluZyB0cmFuc3BvcnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuaGVhZCA9IFwiX19fZWlvW1wiICsgKHJlcS5fcXVlcnkuaiB8fCBcIlwiKS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikgKyBcIl0oXCI7XG4gICAgICAgIHRoaXMuZm9vdCA9IFwiKTtcIjtcbiAgICB9XG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgLy8gd2UgbGV2ZXJhZ2UgdGhlIHFzIG1vZHVsZSBzbyB0aGF0IHdlIGdldCBidWlsdC1pbiBEb1MgcHJvdGVjdGlvblxuICAgICAgICAvLyBhbmQgdGhlIGZhc3QgYWx0ZXJuYXRpdmUgdG8gZGVjb2RlVVJJQ29tcG9uZW50XG4gICAgICAgIGRhdGEgPSBxcy5wYXJzZShkYXRhKS5kO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIGNsaWVudCB3aWxsIHNlbmQgYWxyZWFkeSBlc2NhcGVkIG5ld2xpbmVzIGFzIFxcXFxcXFxcbiBhbmQgbmV3bGluZXMgYXMgXFxcXG5cbiAgICAgICAgICAgIC8vIFxcXFxuIG11c3QgYmUgcmVwbGFjZWQgd2l0aCBcXG4gYW5kIFxcXFxcXFxcbiB3aXRoIFxcXFxuXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKHJTbGFzaGVzLCBmdW5jdGlvbiAobWF0Y2gsIHNsYXNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcyA/IG1hdGNoIDogXCJcXG5cIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3VwZXIub25EYXRhKGRhdGEucmVwbGFjZShyRG91YmxlU2xhc2hlcywgXCJcXFxcblwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9Xcml0ZShkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyB3ZSBtdXN0IG91dHB1dCB2YWxpZCBqYXZhc2NyaXB0LCBub3QgdmFsaWQganNvblxuICAgICAgICAvLyBzZWU6IGh0dHA6Ly90aW1lbGVzc3JlcG8uY29tL2pzb24taXNudC1hLWphdmFzY3JpcHQtc3Vic2V0XG4gICAgICAgIGNvbnN0IGpzID0gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbiAgICAgICAgLy8gcHJlcGFyZSByZXNwb25zZVxuICAgICAgICBkYXRhID0gdGhpcy5oZWFkICsganMgKyB0aGlzLmZvb3Q7XG4gICAgICAgIHN1cGVyLmRvV3JpdGUoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbn1cbmV4cG9ydHMuSlNPTlAgPSBKU09OUDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkpTT05QIiwicG9sbGluZ18xIiwicmVxdWlyZSIsInFzIiwickRvdWJsZVNsYXNoZXMiLCJyU2xhc2hlcyIsIlBvbGxpbmciLCJjb25zdHJ1Y3RvciIsInJlcSIsImhlYWQiLCJfcXVlcnkiLCJqIiwicmVwbGFjZSIsImZvb3QiLCJvbkRhdGEiLCJkYXRhIiwicGFyc2UiLCJkIiwibWF0Y2giLCJzbGFzaGVzIiwiZG9Xcml0ZSIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImpzIiwiSlNPTiIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/polling-jsonp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/polling.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Polling = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     */ constructor(req){\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"polling\";\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param {EngineRequest} req\n     * @package\n     */ onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (\"GET\" === req.method) {\n            this.onPollRequest(req, res);\n        } else if (\"POST\" === req.method) {\n            this.onDataRequest(req, res);\n        } else {\n            res.writeHead(500);\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @private\n     */ onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = ()=>{\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = ()=>{\n            req.removeListener(\"close\", onClose);\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        req.on(\"close\", onClose);\n        this.writable = true;\n        this.emit(\"ready\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @private\n     */ onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let chunks = isBinary ? Buffer.concat([]) : \"\";\n        const cleanup = ()=>{\n            req.removeListener(\"data\", onData);\n            req.removeListener(\"end\", onEnd);\n            req.removeListener(\"close\", onClose);\n            this.dataReq = this.dataRes = chunks = null;\n        };\n        const onClose = ()=>{\n            cleanup();\n            this.onError(\"data request connection closed prematurely\");\n        };\n        const onData = (data)=>{\n            let contentLength;\n            if (isBinary) {\n                chunks = Buffer.concat([\n                    chunks,\n                    data\n                ]);\n                contentLength = chunks.length;\n            } else {\n                chunks += data;\n                contentLength = Buffer.byteLength(chunks);\n            }\n            if (contentLength > this.maxHttpBufferSize) {\n                res.writeHead(413).end();\n                cleanup();\n            }\n        };\n        const onEnd = ()=>{\n            this.onData(chunks);\n            const headers = {\n                // text/html is required instead of text/plain to avoid an\n                // unwanted download dialog on certain user-agents (GH-43)\n                \"Content-Type\": \"text/html\",\n                \"Content-Length\": \"2\"\n            };\n            res.writeHead(200, this.headers(req, headers));\n            res.end(\"ok\");\n            cleanup();\n        };\n        req.on(\"close\", onClose);\n        if (!isBinary) req.setEncoding(\"utf8\");\n        req.on(\"data\", onData);\n        req.on(\"end\", onEnd);\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param data - encoded payload\n     * @protected\n     */ onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet)=>{\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        } else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @private\n     */ onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n        super.onClose();\n    }\n    send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({\n                type: \"close\"\n            });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data)=>{\n            const compress = packets.some((packet)=>{\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, {\n                compress\n            });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        } else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @private\n     */ write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, ()=>{\n            this.req.cleanup();\n            this.emit(\"drain\");\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @protected\n     */ doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType\n        };\n        const respond = (data)=>{\n            headers[\"Content-Length\"] = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n            this.res.writeHead(200, this.headers(this.req, headers));\n            this.res.end(data);\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\n            \"gzip\",\n            \"deflate\"\n        ]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data)=>{\n            if (err) {\n                this.res.writeHead(500);\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @private\n     */ compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function(chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        }).on(\"end\", function() {\n            callback(null, Buffer.concat(buffers, nread));\n        }).end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */ doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        if (this.dataReq) {\n            debug(\"aborting ongoing data request\");\n            this.dataReq.destroy();\n        }\n        const onClose = ()=>{\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([\n                {\n                    type: \"close\"\n                }\n            ]);\n            onClose();\n        } else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        } else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param {http.IncomingMessage} req\n     * @param {Object} headers - extra headers\n     * @private\n     */ headers(req, headers = {}) {\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsTUFBTUcsY0FBY0MsbUJBQU9BLENBQUMsdUVBQWM7QUFDMUMsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsc0RBQVM7QUFDakMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsNkVBQU87QUFDL0IsTUFBTUksUUFBUSxDQUFDLEdBQUdELFFBQVFFLE9BQU8sRUFBRTtBQUNuQyxNQUFNQyxxQkFBcUI7SUFDdkJDLE1BQU1OLE9BQU9PLFVBQVU7SUFDdkJDLFNBQVNSLE9BQU9TLGFBQWE7QUFDakM7QUFDQSxNQUFNWixnQkFBZ0JDLFlBQVlZLFNBQVM7SUFDdkM7O0tBRUMsR0FDREMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEtBQUs7SUFDN0I7SUFDQTs7S0FFQyxHQUNELElBQUlDLE9BQU87UUFDUCxPQUFPO0lBQ1g7SUFDQTs7Ozs7S0FLQyxHQUNEQyxVQUFVSCxHQUFHLEVBQUU7UUFDWCxNQUFNSSxNQUFNSixJQUFJSSxHQUFHO1FBQ25CLHVIQUF1SDtRQUN2SEosSUFBSUksR0FBRyxHQUFHO1FBQ1YsSUFBSSxVQUFVSixJQUFJSyxNQUFNLEVBQUU7WUFDdEIsSUFBSSxDQUFDQyxhQUFhLENBQUNOLEtBQUtJO1FBQzVCLE9BQ0ssSUFBSSxXQUFXSixJQUFJSyxNQUFNLEVBQUU7WUFDNUIsSUFBSSxDQUFDRSxhQUFhLENBQUNQLEtBQUtJO1FBQzVCLE9BQ0s7WUFDREEsSUFBSUksU0FBUyxDQUFDO1lBQ2RKLElBQUlLLEdBQUc7UUFDWDtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNESCxjQUFj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LElBQUksQ0FBQzdDLE9BQU8sRUFBRTtZQUNkN0IsTUFBTTtZQUNOLElBQUksQ0FBQzZCLE9BQU8sQ0FBQzhDLE9BQU87UUFDeEI7UUFDQSxNQUFNdkQsVUFBVTtZQUNad0QsYUFBYUY7WUFDYkQ7WUFDQSxJQUFJLENBQUNyRCxPQUFPO1FBQ2hCO1FBQ0EsSUFBSSxJQUFJLENBQUNJLFFBQVEsRUFBRTtZQUNmeEIsTUFBTTtZQUNOLElBQUksQ0FBQzJCLElBQUksQ0FBQztnQkFBQztvQkFBRUMsTUFBTTtnQkFBUTthQUFFO1lBQzdCUjtRQUNKLE9BQ0ssSUFBSSxJQUFJLENBQUN5RCxTQUFTLEVBQUU7WUFDckI3RSxNQUFNO1lBQ05vQjtRQUNKLE9BQ0s7WUFDRHBCLE1BQU07WUFDTixJQUFJLENBQUMwQixXQUFXLEdBQUdOO1lBQ25Cc0Qsb0JBQW9CSSxXQUFXMUQsU0FBUyxJQUFJLENBQUNWLFlBQVk7UUFDN0Q7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNEcUIsUUFBUXRCLEdBQUcsRUFBRXNCLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDdkIsNkJBQTZCO1FBQzdCLG9EQUFvRDtRQUNwRCxNQUFNZ0QsS0FBS3RFLElBQUlzQixPQUFPLENBQUMsYUFBYTtRQUNwQyxJQUFJZ0QsTUFBTyxFQUFDQSxHQUFHQyxPQUFPLENBQUMsWUFBWSxDQUFDRCxHQUFHQyxPQUFPLENBQUMsV0FBVSxHQUFJO1lBQ3pEakQsT0FBTyxDQUFDLG1CQUFtQixHQUFHO1FBQ2xDO1FBQ0FBLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRztRQUMzQixJQUFJLENBQUNOLElBQUksQ0FBQyxXQUFXTSxTQUFTdEI7UUFDOUIsT0FBT3NCO0lBQ1g7QUFDSjtBQUNBdkMsZUFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Jhdm9jaGF0LWFwcC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy9wb2xsaW5nLmpzP2Q0N2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbGxpbmcgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRcIik7XG5jb25zdCB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGFjY2VwdHMgPSByZXF1aXJlKFwiYWNjZXB0c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnBvbGxpbmdcIik7XG5jb25zdCBjb21wcmVzc2lvbk1ldGhvZHMgPSB7XG4gICAgZ3ppcDogemxpYl8xLmNyZWF0ZUd6aXAsXG4gICAgZGVmbGF0ZTogemxpYl8xLmNyZWF0ZURlZmxhdGUsXG59O1xuY2xhc3MgUG9sbGluZyBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgLyoqXG4gICAgICogSFRUUCBwb2xsaW5nIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLmNsb3NlVGltZW91dCA9IDMwICogMTAwMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwicG9sbGluZ1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgb25SZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmdpbmVSZXF1ZXN0fSByZXFcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIG9uUmVxdWVzdChyZXEpIHtcbiAgICAgICAgY29uc3QgcmVzID0gcmVxLnJlcztcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIFNlcnZlclJlc3BvbnNlIG9iamVjdCAoYXMgdGhlIGZpcnN0IHJlcXVlc3Qgb2YgdGhlIHNlc3Npb24gaXMga2VwdCBpbiBtZW1vcnkgYnkgZGVmYXVsdClcbiAgICAgICAgcmVxLnJlcyA9IG51bGw7XG4gICAgICAgIGlmIChcIkdFVFwiID09PSByZXEubWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLm9uUG9sbFJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiUE9TVFwiID09PSByZXEubWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg1MDApO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYSByZXF1ZXN0IGF3YWl0aW5nIGZvciB1cyB0byBzZW5kIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUG9sbFJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJlcXVlc3Qgb3ZlcmxhcFwiKTtcbiAgICAgICAgICAgIC8vIGFzc2VydDogdGhpcy5yZXMsICcucmVxIGFuZCAucmVzIHNob3VsZCBiZSAodW4pc2V0IHRvZ2V0aGVyJ1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwib3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNDAwKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNldHRpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwicG9sbCBjb25uZWN0aW9uIGNsb3NlZCBwcmVtYXR1cmVseVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5yZXEgPSB0aGlzLnJlcyA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJlcS5jbGVhbnVwID0gY2xlYW51cDtcbiAgICAgICAgcmVxLm9uKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWFkeVwiKTtcbiAgICAgICAgLy8gaWYgd2UncmUgc3RpbGwgd3JpdGFibGUgYnV0IGhhZCBhIHBlbmRpbmcgY2xvc2UsIHRyaWdnZXIgYW4gZW1wdHkgc2VuZFxuICAgICAgICBpZiAodGhpcy53cml0YWJsZSAmJiB0aGlzLnNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyaWdnZXJpbmcgZW1wdHkgc2VuZCB0byBhcHBlbmQgY2xvc2UgcGFja2V0XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHNlbmRzIGEgcmVxdWVzdCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YVJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVJlcSkge1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLmRhdGFSZXMsICcuZGF0YVJlcSBhbmQgLmRhdGFSZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3Qgb3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNDAwKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0JpbmFyeSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgPT09IHJlcS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdO1xuICAgICAgICBpZiAoaXNCaW5hcnkgJiYgdGhpcy5wcm90b2NvbCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FcnJvcihcImludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFSZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZGF0YVJlcyA9IHJlcztcbiAgICAgICAgbGV0IGNodW5rcyA9IGlzQmluYXJ5ID8gQnVmZmVyLmNvbmNhdChbXSkgOiBcIlwiO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBvbkRhdGEpO1xuICAgICAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIG9uRW5kKTtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVxID0gdGhpcy5kYXRhUmVzID0gY2h1bmtzID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImRhdGEgcmVxdWVzdCBjb25uZWN0aW9uIGNsb3NlZCBwcmVtYXR1cmVseVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25EYXRhID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGxldCBjb250ZW50TGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzID0gQnVmZmVyLmNvbmNhdChbY2h1bmtzLCBkYXRhXSk7XG4gICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IGNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHVua3MgKz0gZGF0YTtcbiAgICAgICAgICAgICAgICBjb250ZW50TGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoID4gdGhpcy5tYXhIdHRwQnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNDEzKS5lbmQoKTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoY2h1bmtzKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgLy8gdGV4dC9odG1sIGlzIHJlcXVpcmVkIGluc3RlYWQgb2YgdGV4dC9wbGFpbiB0byBhdm9pZCBhblxuICAgICAgICAgICAgICAgIC8vIHVud2FudGVkIGRvd25sb2FkIGRpYWxvZyBvbiBjZXJ0YWluIHVzZXItYWdlbnRzIChHSC00MylcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGhcIjogXCIyXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHRoaXMuaGVhZGVycyhyZXEsIGhlYWRlcnMpKTtcbiAgICAgICAgICAgIHJlcy5lbmQoXCJva1wiKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxLm9uKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIGlmICghaXNCaW5hcnkpXG4gICAgICAgICAgICByZXEuc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuICAgICAgICByZXEub24oXCJkYXRhXCIsIG9uRGF0YSk7XG4gICAgICAgIHJlcS5vbihcImVuZFwiLCBvbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgaW5jb21pbmcgZGF0YSBwYXlsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSBlbmNvZGVkIHBheWxvYWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3JlY2VpdmVkIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGlmIChcImNsb3NlXCIgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgeGhyIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSkuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIG9uQ2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAvLyBjbG9zZSBwZW5kaW5nIHBvbGwgcmVxdWVzdFxuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5vbkNsb3NlKCk7XG4gICAgfVxuICAgIHNlbmQocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFwcGVuZGluZyBjbG9zZSBwYWNrZXQgdG8gcGF5bG9hZFwiKTtcbiAgICAgICAgICAgIHBhY2tldHMucHVzaCh7IHR5cGU6IFwiY2xvc2VcIiB9KTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvV3JpdGUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tcHJlc3MgPSBwYWNrZXRzLnNvbWUoKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQub3B0aW9ucyAmJiBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLCB7IGNvbXByZXNzIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBkb1dyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGRhdGEgYXMgcmVzcG9uc2UgdG8gcG9sbCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgd3JpdGUoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBkZWJ1Zygnd3JpdGluZyBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgdGhpcy5kb1dyaXRlKGRhdGEsIG9wdGlvbnMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHdyaXRlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRvV3JpdGUoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gZXhwbGljaXQgVVRGLTggaXMgcmVxdWlyZWQgZm9yIHBhZ2VzIG5vdCBzZXJ2ZWQgdW5kZXIgdXRmXG4gICAgICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaXNTdHJpbmdcbiAgICAgICAgICAgID8gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PVVURi04XCJcbiAgICAgICAgICAgIDogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGNvbnRlbnRUeXBlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25kID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRhdGEgPyBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVIZWFkKDIwMCwgdGhpcy5oZWFkZXJzKHRoaXMucmVxLCBoZWFkZXJzKSk7XG4gICAgICAgICAgICB0aGlzLnJlcy5lbmQoZGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuaHR0cENvbXByZXNzaW9uIHx8ICFvcHRpb25zLmNvbXByZXNzKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGlzU3RyaW5nID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IHRoaXMuaHR0cENvbXByZXNzaW9uLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGluZyA9IGFjY2VwdHModGhpcy5yZXEpLmVuY29kaW5ncyhbXCJnemlwXCIsIFwiZGVmbGF0ZVwiXSk7XG4gICAgICAgIGlmICghZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wcmVzcyhkYXRhLCBlbmNvZGluZywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZCg1MDApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtRW5jb2RpbmdcIl0gPSBlbmNvZGluZztcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wcmVzc2VzIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXByZXNzKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBkZWJ1ZyhcImNvbXByZXNzaW5nXCIpO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgIGxldCBucmVhZCA9IDA7XG4gICAgICAgIGNvbXByZXNzaW9uTWV0aG9kc1tlbmNvZGluZ10odGhpcy5odHRwQ29tcHJlc3Npb24pXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCBjYWxsYmFjaylcbiAgICAgICAgICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgbnJlYWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5lbmQoZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgbGV0IGNsb3NlVGltZW91dFRpbWVyO1xuICAgICAgICBpZiAodGhpcy5kYXRhUmVxKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFib3J0aW5nIG9uZ29pbmcgZGF0YSByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVxLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IHdyaXRhYmxlIC0gY2xvc2luZyByaWdodCBhd2F5XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwiY2xvc2VcIiB9XSk7XG4gICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXNjYXJkZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGRpc2NhcmRlZCAtIGNsb3NpbmcgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IG5vdCB3cml0YWJsZSAtIGJ1ZmZlcmluZyBvcmRlcmx5IGNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSA9IG9uQ2xvc2U7XG4gICAgICAgICAgICBjbG9zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQob25DbG9zZSwgdGhpcy5jbG9zZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVhZGVycyBmb3IgYSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIC0gZXh0cmEgaGVhZGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaGVhZGVycyhyZXEsIGhlYWRlcnMgPSB7fSkge1xuICAgICAgICAvLyBwcmV2ZW50IFhTUyB3YXJuaW5ncyBvbiBJRVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhcm5Cb29zdC9zb2NrZXQuaW8vcHVsbC8xMzMzXG4gICAgICAgIGNvbnN0IHVhID0gcmVxLmhlYWRlcnNbXCJ1c2VyLWFnZW50XCJdO1xuICAgICAgICBpZiAodWEgJiYgKH51YS5pbmRleE9mKFwiO01TSUVcIikgfHwgfnVhLmluZGV4T2YoXCJUcmlkZW50L1wiKSkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLVhTUy1Qcm90ZWN0aW9uXCJdID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBcIm5vLXN0b3JlXCI7XG4gICAgICAgIHRoaXMuZW1pdChcImhlYWRlcnNcIiwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nID0gUG9sbGluZztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBvbGxpbmciLCJ0cmFuc3BvcnRfMSIsInJlcXVpcmUiLCJ6bGliXzEiLCJhY2NlcHRzIiwiZGVidWdfMSIsImRlYnVnIiwiZGVmYXVsdCIsImNvbXByZXNzaW9uTWV0aG9kcyIsImd6aXAiLCJjcmVhdGVHemlwIiwiZGVmbGF0ZSIsImNyZWF0ZURlZmxhdGUiLCJUcmFuc3BvcnQiLCJjb25zdHJ1Y3RvciIsInJlcSIsImNsb3NlVGltZW91dCIsIm5hbWUiLCJvblJlcXVlc3QiLCJyZXMiLCJtZXRob2QiLCJvblBvbGxSZXF1ZXN0Iiwib25EYXRhUmVxdWVzdCIsIndyaXRlSGVhZCIsImVuZCIsIm9uRXJyb3IiLCJvbkNsb3NlIiwiY2xlYW51cCIsInJlbW92ZUxpc3RlbmVyIiwib24iLCJ3cml0YWJsZSIsImVtaXQiLCJzaG91bGRDbG9zZSIsInNlbmQiLCJ0eXBlIiwiZGF0YVJlcSIsImlzQmluYXJ5IiwiaGVhZGVycyIsInByb3RvY29sIiwiZGF0YVJlcyIsImNodW5rcyIsIkJ1ZmZlciIsImNvbmNhdCIsIm9uRGF0YSIsIm9uRW5kIiwiZGF0YSIsImNvbnRlbnRMZW5ndGgiLCJsZW5ndGgiLCJieXRlTGVuZ3RoIiwibWF4SHR0cEJ1ZmZlclNpemUiLCJzZXRFbmNvZGluZyIsImNhbGxiYWNrIiwicGFja2V0Iiwib25QYWNrZXQiLCJwYXJzZXIiLCJkZWNvZGVQYXlsb2FkIiwiZm9yRWFjaCIsInBhY2tldHMiLCJwdXNoIiwiZG9Xcml0ZSIsImNvbXByZXNzIiwic29tZSIsIm9wdGlvbnMiLCJ3cml0ZSIsImVuY29kZVBheWxvYWQiLCJzdXBwb3J0c0JpbmFyeSIsImlzU3RyaW5nIiwiY29udGVudFR5cGUiLCJyZXNwb25kIiwiaHR0cENvbXByZXNzaW9uIiwibGVuIiwidGhyZXNob2xkIiwiZW5jb2RpbmciLCJlbmNvZGluZ3MiLCJlcnIiLCJidWZmZXJzIiwibnJlYWQiLCJjaHVuayIsImRvQ2xvc2UiLCJmbiIsImNsb3NlVGltZW91dFRpbWVyIiwiZGVzdHJveSIsImNsZWFyVGltZW91dCIsImRpc2NhcmRlZCIsInNldFRpbWVvdXQiLCJ1YSIsImluZGV4T2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/polling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/websocket.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/websocket.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocket = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:ws\");\nclass WebSocket extends transport_1.Transport {\n    /**\n     * WebSocket transport\n     *\n     * @param {EngineRequest} req\n     */ constructor(req){\n        super(req);\n        this._doSend = (data)=>{\n            this.socket.send(data, this._onSent);\n        };\n        this._doSendLast = (data)=>{\n            this.socket.send(data, this._onSentLast);\n        };\n        this._onSent = (err)=>{\n            if (err) {\n                this.onError(\"write error\", err.stack);\n            }\n        };\n        this._onSentLast = (err)=>{\n            if (err) {\n                this.onError(\"write error\", err.stack);\n            } else {\n                this.emit(\"drain\");\n                this.writable = true;\n                this.emit(\"ready\");\n            }\n        };\n        this.socket = req.websocket;\n        this.socket.on(\"message\", (data, isBinary)=>{\n            const message = isBinary ? data : data.toString();\n            debug('received \"%s\"', message);\n            super.onData(message);\n        });\n        this.socket.once(\"close\", this.onClose.bind(this));\n        this.socket.on(\"error\", this.onError.bind(this));\n        this.writable = true;\n        this.perMessageDeflate = null;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"websocket\";\n    }\n    /**\n     * Advertise upgrade support.\n     */ get handlesUpgrades() {\n        return true;\n    }\n    send(packets) {\n        this.writable = false;\n        for(let i = 0; i < packets.length; i++){\n            const packet = packets[i];\n            const isLast = i + 1 === packets.length;\n            if (this._canSendPreEncodedFrame(packet)) {\n                // the WebSocket frame was computed with WebSocket.Sender.frame()\n                // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n                this.socket._sender.sendFrame(// @ts-ignore\n                packet.options.wsPreEncodedFrame, isLast ? this._onSentLast : this._onSent);\n            } else {\n                this.parser.encodePacket(packet, this.supportsBinary, isLast ? this._doSendLast : this._doSend);\n            }\n        }\n    }\n    /**\n     * Whether the encoding of the WebSocket frame can be skipped.\n     * @param packet\n     * @private\n     */ _canSendPreEncodedFrame(packet) {\n        var _a, _b, _c;\n        return !this.perMessageDeflate && typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === \"function\" && // @ts-ignore\n        ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== undefined;\n    }\n    doClose(fn) {\n        debug(\"closing\");\n        this.socket.close();\n        fn && fn();\n    }\n}\nexports.WebSocket = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzFDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1FLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkMsTUFBTUwsa0JBQWtCQyxZQUFZSyxTQUFTO0lBQ3pDOzs7O0tBSUMsR0FDREMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUNDO1lBQ1osSUFBSSxDQUFDQyxNQUFNLENBQUNDLElBQUksQ0FBQ0YsTUFBTSxJQUFJLENBQUNHLE9BQU87UUFDdkM7UUFDQSxJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDSjtZQUNoQixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDRixNQUFNLElBQUksQ0FBQ0ssV0FBVztRQUMzQztRQUNBLElBQUksQ0FBQ0YsT0FBTyxHQUFHLENBQUNHO1lBQ1osSUFBSUEsS0FBSztnQkFDTCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxlQUFlRCxJQUFJRSxLQUFLO1lBQ3pDO1FBQ0o7UUFDQSxJQUFJLENBQUNILFdBQVcsR0FBRyxDQUFDQztZQUNoQixJQUFJQSxLQUFLO2dCQUNMLElBQUksQ0FBQ0MsT0FBTyxDQUFDLGVBQWVELElBQUlFLEtBQUs7WUFDekMsT0FDSztnQkFDRCxJQUFJLENBQUNDLElBQUksQ0FBQztnQkFDVixJQUFJLENBQUNDLFFBQVEsR0FBRztnQkFDaEIsSUFBSSxDQUFDRCxJQUFJLENBQUM7WUFDZDtRQUNKO1FBQ0EsSUFBSSxDQUFDUixNQUFNLEdBQUdILElBQUlhLFNBQVM7UUFDM0IsSUFBSSxDQUFDVixNQUFNLENBQUNXLEVBQUUsQ0FBQyxXQUFXLENBQUNaLE1BQU1hO1lBQzdCLE1BQU1DLFVBQVVELFdBQVdiLE9BQU9BLEtBQUtlLFFBQVE7WUFDL0NyQixNQUFNLGlCQUFpQm9CO1lBQ3ZCLEtBQUssQ0FBQ0UsT0FBT0Y7UUFDakI7UUFDQSxJQUFJLENBQUNiLE1BQU0sQ0FBQ2dCLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNoRCxJQUFJLENBQUNsQixNQUFNLENBQUNXLEVBQUUsQ0FBQyxTQUFTLElBQUksQ0FBQ0wsT0FBTyxDQUFDWSxJQUFJLENBQUMsSUFBSTtRQUM5QyxJQUFJLENBQUNULFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNVLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxrQkFBa0I7UUFDbEIsT0FBTztJQUNYO0lBQ0FwQixLQUFLcUIsT0FBTyxFQUFFO1FBQ1YsSUFBSSxDQUFDYixRQUFRLEdBQUc7UUFDaEIsSUFBSyxJQUFJYyxJQUFJLEdBQUdBLElBQUlELFFBQVFFLE1BQU0sRUFBRUQsSUFBSztZQUNyQyxNQUFNRSxTQUFTSCxPQUFPLENBQUNDLEVBQUU7WUFDekIsTUFBTUcsU0FBU0gsSUFBSSxNQUFNRCxRQUFRRSxNQUFNO1lBQ3ZDLElBQUksSUFBSSxDQUFDRyx1QkFBdUIsQ0FBQ0YsU0FBUztnQkFDdEMsaUVBQWlFO2dCQUNqRSx5RUFBeUU7Z0JBQ3pFLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQzRCLE9BQU8sQ0FBQ0MsU0FBUyxDQUM3QixhQUFhO2dCQUNiSixPQUFPSyxPQUFPLENBQUNDLGlCQUFpQixFQUFFTCxTQUFTLElBQUksQ0FBQ3RCLFdBQVcsR0FBRyxJQUFJLENBQUNGLE9BQU87WUFDOUUsT0FDSztnQkFDRCxJQUFJLENBQUM4QixNQUFNLENBQUNDLFlBQVksQ0FBQ1IsUUFBUSxJQUFJLENBQUNTLGNBQWMsRUFBRVIsU0FBUyxJQUFJLENBQUN2QixXQUFXLEdBQUcsSUFBSSxDQUFDTCxPQUFPO1lBQ2xHO1FBQ0o7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRDZCLHdCQUF3QkYsTUFBTSxFQUFFO1FBQzVCLElBQUlVLElBQUlDLElBQUlDO1FBQ1osT0FBUSxDQUFDLElBQUksQ0FBQ2xCLGlCQUFpQixJQUMzQixPQUFRLEVBQUNpQixLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDbkMsTUFBTSxNQUFNLFFBQVFtQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdQLE9BQU8sTUFBTSxRQUFRUSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdQLFNBQVMsTUFBTSxjQUV6SSxhQURhO1FBQ1osRUFBQ1EsS0FBS1osT0FBT0ssT0FBTyxNQUFNLFFBQVFPLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR04saUJBQWlCLE1BQU1PO0lBQzlGO0lBQ0FDLFFBQVFDLEVBQUUsRUFBRTtRQUNSL0MsTUFBTTtRQUNOLElBQUksQ0FBQ08sTUFBTSxDQUFDeUMsS0FBSztRQUNqQkQsTUFBTUE7SUFDVjtBQUNKO0FBQ0FyRCxpQkFBaUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzPzQ3MWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydFwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOndzXCIpO1xuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgdHJhbnNwb3J0XzEuVHJhbnNwb3J0IHtcbiAgICAvKipcbiAgICAgKiBXZWJTb2NrZXQgdHJhbnNwb3J0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuZ2luZVJlcXVlc3R9IHJlcVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLl9kb1NlbmQgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhLCB0aGlzLl9vblNlbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kb1NlbmRMYXN0ID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSwgdGhpcy5fb25TZW50TGFzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX29uU2VudCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ3cml0ZSBlcnJvclwiLCBlcnIuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9vblNlbnRMYXN0ID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihcIndyaXRlIGVycm9yXCIsIGVyci5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWFkeVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSByZXEud2Vic29ja2V0O1xuICAgICAgICB0aGlzLnNvY2tldC5vbihcIm1lc3NhZ2VcIiwgKGRhdGEsIGlzQmluYXJ5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gaXNCaW5hcnkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpO1xuICAgICAgICAgICAgZGVidWcoJ3JlY2VpdmVkIFwiJXNcIicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgc3VwZXIub25EYXRhKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25jZShcImNsb3NlXCIsIHRoaXMub25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJlcnJvclwiLCB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwid2Vic29ja2V0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmVydGlzZSB1cGdyYWRlIHN1cHBvcnQuXG4gICAgICovXG4gICAgZ2V0IGhhbmRsZXNVcGdyYWRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNlbmQocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gcGFja2V0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IGkgKyAxID09PSBwYWNrZXRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW5TZW5kUHJlRW5jb2RlZEZyYW1lKHBhY2tldCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgV2ViU29ja2V0IGZyYW1lIHdhcyBjb21wdXRlZCB3aXRoIFdlYlNvY2tldC5TZW5kZXIuZnJhbWUoKVxuICAgICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvNjE3I2lzc3VlY29tbWVudC0yODMwMDI0NjlcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5fc2VuZGVyLnNlbmRGcmFtZShcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcGFja2V0Lm9wdGlvbnMud3NQcmVFbmNvZGVkRnJhbWUsIGlzTGFzdCA/IHRoaXMuX29uU2VudExhc3QgOiB0aGlzLl9vblNlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgdGhpcy5zdXBwb3J0c0JpbmFyeSwgaXNMYXN0ID8gdGhpcy5fZG9TZW5kTGFzdCA6IHRoaXMuX2RvU2VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZW5jb2Rpbmcgb2YgdGhlIFdlYlNvY2tldCBmcmFtZSBjYW4gYmUgc2tpcHBlZC5cbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FuU2VuZFByZUVuY29kZWRGcmFtZShwYWNrZXQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoIXRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgICAgIHR5cGVvZiAoKF9iID0gKF9hID0gdGhpcy5zb2NrZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fc2VuZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2VuZEZyYW1lKSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAoKF9jID0gcGFja2V0Lm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy53c1ByZUVuY29kZWRGcmFtZSkgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGRvQ2xvc2UoZm4pIHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nXCIpO1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICBmbiAmJiBmbigpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViU29ja2V0ID0gV2ViU29ja2V0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiV2ViU29ja2V0IiwidHJhbnNwb3J0XzEiLCJyZXF1aXJlIiwiZGVidWdfMSIsImRlYnVnIiwiZGVmYXVsdCIsIlRyYW5zcG9ydCIsImNvbnN0cnVjdG9yIiwicmVxIiwiX2RvU2VuZCIsImRhdGEiLCJzb2NrZXQiLCJzZW5kIiwiX29uU2VudCIsIl9kb1NlbmRMYXN0IiwiX29uU2VudExhc3QiLCJlcnIiLCJvbkVycm9yIiwic3RhY2siLCJlbWl0Iiwid3JpdGFibGUiLCJ3ZWJzb2NrZXQiLCJvbiIsImlzQmluYXJ5IiwibWVzc2FnZSIsInRvU3RyaW5nIiwib25EYXRhIiwib25jZSIsIm9uQ2xvc2UiLCJiaW5kIiwicGVyTWVzc2FnZURlZmxhdGUiLCJuYW1lIiwiaGFuZGxlc1VwZ3JhZGVzIiwicGFja2V0cyIsImkiLCJsZW5ndGgiLCJwYWNrZXQiLCJpc0xhc3QiLCJfY2FuU2VuZFByZUVuY29kZWRGcmFtZSIsIl9zZW5kZXIiLCJzZW5kRnJhbWUiLCJvcHRpb25zIiwid3NQcmVFbmNvZGVkRnJhbWUiLCJwYXJzZXIiLCJlbmNvZGVQYWNrZXQiLCJzdXBwb3J0c0JpbmFyeSIsIl9hIiwiX2IiLCJfYyIsInVuZGVmaW5lZCIsImRvQ2xvc2UiLCJmbiIsImNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/webtransport.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/webtransport.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebTransport = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nconst debug = (0, debug_1.default)(\"engine:webtransport\");\n/**\n * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API\n */ class WebTransport extends transport_1.Transport {\n    constructor(session, stream, reader){\n        super({\n            _query: {\n                EIO: \"4\"\n            }\n        });\n        this.session = session;\n        const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();\n        transformStream.readable.pipeTo(stream.writable).catch(()=>{\n            debug(\"the stream was closed\");\n        });\n        this.writer = transformStream.writable.getWriter();\n        (async ()=>{\n            try {\n                while(true){\n                    const { value, done } = await reader.read();\n                    if (done) {\n                        debug(\"session is closed\");\n                        break;\n                    }\n                    debug(\"received chunk: %o\", value);\n                    this.onPacket(value);\n                }\n            } catch (e) {\n                debug(\"error while reading: %s\", e.message);\n            }\n        })();\n        session.closed.then(()=>this.onClose());\n        this.writable = true;\n    }\n    get name() {\n        return \"webtransport\";\n    }\n    async send(packets) {\n        this.writable = false;\n        try {\n            for(let i = 0; i < packets.length; i++){\n                const packet = packets[i];\n                await this.writer.write(packet);\n            }\n        } catch (e) {\n            debug(\"error while writing: %s\", e.message);\n        }\n        this.emit(\"drain\");\n        this.writable = true;\n        this.emit(\"ready\");\n    }\n    doClose(fn) {\n        debug(\"closing WebTransport session\");\n        this.session.close();\n        fn && fn();\n    }\n}\nexports.WebTransport = WebTransport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2VidHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBRyxLQUFLO0FBQzVCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzFDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1FLHFCQUFxQkYsbUJBQU9BLENBQUMsa0ZBQWtCO0FBQ3JELE1BQU1HLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxPQUFPLEVBQUU7QUFDbkM7O0NBRUMsR0FDRCxNQUFNTixxQkFBcUJDLFlBQVlNLFNBQVM7SUFDNUNDLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLENBQUU7UUFDakMsS0FBSyxDQUFDO1lBQUVDLFFBQVE7Z0JBQUVDLEtBQUs7WUFBSTtRQUFFO1FBQzdCLElBQUksQ0FBQ0osT0FBTyxHQUFHQTtRQUNmLE1BQU1LLGtCQUFrQixDQUFDLEdBQUdWLG1CQUFtQlcseUJBQXlCO1FBQ3hFRCxnQkFBZ0JFLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDUCxPQUFPUSxRQUFRLEVBQUVDLEtBQUssQ0FBQztZQUNuRGQsTUFBTTtRQUNWO1FBQ0EsSUFBSSxDQUFDZSxNQUFNLEdBQUdOLGdCQUFnQkksUUFBUSxDQUFDRyxTQUFTO1FBQy9DO1lBQ0csSUFBSTtnQkFDQSxNQUFPLEtBQU07b0JBQ1QsTUFBTSxFQUFFdEIsS0FBSyxFQUFFdUIsSUFBSSxFQUFFLEdBQUcsTUFBTVgsT0FBT1ksSUFBSTtvQkFDekMsSUFBSUQsTUFBTTt3QkFDTmpCLE1BQU07d0JBQ047b0JBQ0o7b0JBQ0FBLE1BQU0sc0JBQXNCTjtvQkFDNUIsSUFBSSxDQUFDeUIsUUFBUSxDQUFDekI7Z0JBQ2xCO1lBQ0osRUFDQSxPQUFPMEIsR0FBRztnQkFDTnBCLE1BQU0sMkJBQTJCb0IsRUFBRUMsT0FBTztZQUM5QztRQUNKO1FBQ0FqQixRQUFRa0IsTUFBTSxDQUFDQyxJQUFJLENBQUMsSUFBTSxJQUFJLENBQUNDLE9BQU87UUFDdEMsSUFBSSxDQUFDWCxRQUFRLEdBQUc7SUFDcEI7SUFDQSxJQUFJWSxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0EsTUFBTUMsS0FBS0MsT0FBTyxFQUFFO1FBQ2hCLElBQUksQ0FBQ2QsUUFBUSxHQUFHO1FBQ2hCLElBQUk7WUFDQSxJQUFLLElBQUllLElBQUksR0FBR0EsSUFBSUQsUUFBUUUsTUFBTSxFQUFFRCxJQUFLO2dCQUNyQyxNQUFNRSxTQUFTSCxPQUFPLENBQUNDLEVBQUU7Z0JBQ3pCLE1BQU0sSUFBSSxDQUFDYixNQUFNLENBQUNnQixLQUFLLENBQUNEO1lBQzVCO1FBQ0osRUFDQSxPQUFPVixHQUFHO1lBQ05wQixNQUFNLDJCQUEyQm9CLEVBQUVDLE9BQU87UUFDOUM7UUFDQSxJQUFJLENBQUNXLElBQUksQ0FBQztRQUNWLElBQUksQ0FBQ25CLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNtQixJQUFJLENBQUM7SUFDZDtJQUNBQyxRQUFRQyxFQUFFLEVBQUU7UUFDUmxDLE1BQU07UUFDTixJQUFJLENBQUNJLE9BQU8sQ0FBQytCLEtBQUs7UUFDbEJELE1BQU1BO0lBQ1Y7QUFDSjtBQUNBekMsb0JBQW9CLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmF2b2NoYXQtYXBwLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3dlYnRyYW5zcG9ydC5qcz83NDE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJUcmFuc3BvcnQgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZW5naW5lX2lvX3BhcnNlcl8xID0gcmVxdWlyZShcImVuZ2luZS5pby1wYXJzZXJcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOndlYnRyYW5zcG9ydFwiKTtcbi8qKlxuICogUmVmZXJlbmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViVHJhbnNwb3J0X0FQSVxuICovXG5jbGFzcyBXZWJUcmFuc3BvcnQgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb24sIHN0cmVhbSwgcmVhZGVyKSB7XG4gICAgICAgIHN1cGVyKHsgX3F1ZXJ5OiB7IEVJTzogXCI0XCIgfSB9KTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3RyZWFtID0gKDAsIGVuZ2luZV9pb19wYXJzZXJfMS5jcmVhdGVQYWNrZXRFbmNvZGVyU3RyZWFtKSgpO1xuICAgICAgICB0cmFuc2Zvcm1TdHJlYW0ucmVhZGFibGUucGlwZVRvKHN0cmVhbS53cml0YWJsZSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ0aGUgc3RyZWFtIHdhcyBjbG9zZWRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRyYW5zZm9ybVN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic2Vzc2lvbiBpcyBjbG9zZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlY2VpdmVkIGNodW5rOiAlb1wiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25QYWNrZXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJlcnJvciB3aGlsZSByZWFkaW5nOiAlc1wiLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICBzZXNzaW9uLmNsb3NlZC50aGVuKCgpID0+IHRoaXMub25DbG9zZSgpKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJ0cmFuc3BvcnRcIjtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHBhY2tldHNbaV07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGFja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVidWcoXCJlcnJvciB3aGlsZSB3cml0aW5nOiAlc1wiLCBlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVhZHlcIik7XG4gICAgfVxuICAgIGRvQ2xvc2UoZm4pIHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nIFdlYlRyYW5zcG9ydCBzZXNzaW9uXCIpO1xuICAgICAgICB0aGlzLnNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgZm4gJiYgZm4oKTtcbiAgICB9XG59XG5leHBvcnRzLldlYlRyYW5zcG9ydCA9IFdlYlRyYW5zcG9ydDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIldlYlRyYW5zcG9ydCIsInRyYW5zcG9ydF8xIiwicmVxdWlyZSIsImRlYnVnXzEiLCJlbmdpbmVfaW9fcGFyc2VyXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJUcmFuc3BvcnQiLCJjb25zdHJ1Y3RvciIsInNlc3Npb24iLCJzdHJlYW0iLCJyZWFkZXIiLCJfcXVlcnkiLCJFSU8iLCJ0cmFuc2Zvcm1TdHJlYW0iLCJjcmVhdGVQYWNrZXRFbmNvZGVyU3RyZWFtIiwicmVhZGFibGUiLCJwaXBlVG8iLCJ3cml0YWJsZSIsImNhdGNoIiwid3JpdGVyIiwiZ2V0V3JpdGVyIiwiZG9uZSIsInJlYWQiLCJvblBhY2tldCIsImUiLCJtZXNzYWdlIiwiY2xvc2VkIiwidGhlbiIsIm9uQ2xvc2UiLCJuYW1lIiwic2VuZCIsInBhY2tldHMiLCJpIiwibGVuZ3RoIiwicGFja2V0Iiwid3JpdGUiLCJlbWl0IiwiZG9DbG9zZSIsImZuIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/webtransport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/userver.js":
/*!*************************************************!*\
  !*** ./node_modules/engine.io/build/userver.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.uServer = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/engine.io/build/server.js\");\nconst transports_uws_1 = __webpack_require__(/*! ./transports-uws */ \"(rsc)/./node_modules/engine.io/build/transports-uws/index.js\");\nconst debug = (0, debug_1.default)(\"engine:uws\");\n/**\n * An Engine.IO server based on the `uWebSockets.js` package.\n */ // TODO export it into its own package\nclass uServer extends server_1.BaseServer {\n    init() {}\n    cleanup() {}\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @private\n     */ prepare(req, res) {\n        req.method = req.getMethod().toUpperCase();\n        req.url = req.getUrl();\n        const params = new URLSearchParams(req.getQuery());\n        req._query = Object.fromEntries(params.entries());\n        req.headers = {};\n        req.forEach((key, value)=>{\n            req.headers[key] = value;\n        });\n        req.connection = {\n            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n        };\n        res.onAborted(()=>{\n            debug(\"response has been aborted\");\n        });\n    }\n    createTransport(transportName, req) {\n        return new transports_uws_1.default[transportName](req);\n    }\n    /**\n     * Attach the engine to a WebSockets.js server\n     * @param app\n     * @param options\n     */ attach(app /* : TemplatedApp */ , options = {}) {\n        const path = this._computePath(options);\n        app.any(path, this.handleRequest.bind(this))//\n        .ws(path, {\n            compression: options.compression,\n            idleTimeout: options.idleTimeout,\n            maxBackpressure: options.maxBackpressure,\n            maxPayloadLength: this.opts.maxHttpBufferSize,\n            upgrade: this.handleUpgrade.bind(this),\n            open: (ws)=>{\n                const transport = ws.getUserData().transport;\n                transport.socket = ws;\n                transport.writable = true;\n                transport.emit(\"ready\");\n            },\n            message: (ws, message, isBinary)=>{\n                ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());\n            },\n            close: (ws, code, message)=>{\n                ws.getUserData().transport.onClose(code, message);\n            }\n        });\n    }\n    _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            return callback();\n        }\n        // needed to buffer headers until the status is computed\n        req.res = new ResponseWrapper(res);\n        super._applyMiddlewares(req, req.res, (err)=>{\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            req.res.writeHead();\n            callback(err);\n        });\n    }\n    handleRequest(res, req) {\n        debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n        this.prepare(req, res);\n        req.res = res;\n        const callback = (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(req.res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                // @ts-ignore\n                this.clients[req._query.sid].transport.onRequest(req);\n            } else {\n                const closeConnection = (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    handleUpgrade(res, req, context) {\n        debug(\"on upgrade\");\n        this.prepare(req, res);\n        req.res = res;\n        const callback = async (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            const id = req._query.sid;\n            let transport;\n            if (id) {\n                const client = this.clients[id];\n                if (!client) {\n                    debug(\"upgrade attempt for closed client\");\n                    return res.close();\n                } else if (client.upgrading) {\n                    debug(\"transport has already been trying to upgrade\");\n                    return res.close();\n                } else if (client.upgraded) {\n                    debug(\"transport had already been upgraded\");\n                    return res.close();\n                } else {\n                    debug(\"upgrading existing transport\");\n                    transport = this.createTransport(req._query.transport, req);\n                    client._maybeUpgrade(transport);\n                }\n            } else {\n                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext));\n                if (!transport) {\n                    return;\n                }\n            }\n            // calling writeStatus() triggers the flushing of any header added in a middleware\n            req.res.writeStatus(\"101 Switching Protocols\");\n            res.upgrade({\n                transport\n            }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    abortRequest(res, errorCode, errorContext) {\n        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? \"403 Forbidden\" : \"400 Bad Request\";\n        const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];\n        res.writeStatus(statusCode);\n        res.writeHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify({\n            code: errorCode,\n            message\n        }));\n    }\n}\nexports.uServer = uServer;\nclass ResponseWrapper {\n    constructor(res){\n        this.res = res;\n        this.statusWritten = false;\n        this.headers = [];\n        this.isAborted = false;\n    }\n    set statusCode(status) {\n        if (!status) {\n            return;\n        }\n        // FIXME: handle all status codes?\n        this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n    }\n    writeHead(status) {\n        this.statusCode = status;\n    }\n    setHeader(key, value) {\n        if (Array.isArray(value)) {\n            value.forEach((val)=>{\n                this.writeHeader(key, val);\n            });\n        } else {\n            this.writeHeader(key, value);\n        }\n    }\n    removeHeader() {\n    // FIXME: not implemented\n    }\n    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n    getHeader() {}\n    writeStatus(status) {\n        if (this.isAborted) return;\n        this.res.writeStatus(status);\n        this.statusWritten = true;\n        this.writeBufferedHeaders();\n        return this;\n    }\n    writeHeader(key, value) {\n        if (this.isAborted) return;\n        if (key === \"Content-Length\") {\n            // the content length is automatically added by uWebSockets.js\n            return;\n        }\n        if (this.statusWritten) {\n            this.res.writeHeader(key, value);\n        } else {\n            this.headers.push([\n                key,\n                value\n            ]);\n        }\n    }\n    writeBufferedHeaders() {\n        this.headers.forEach(([key, value])=>{\n            this.res.writeHeader(key, value);\n        });\n    }\n    end(data) {\n        if (this.isAborted) return;\n        this.res.cork(()=>{\n            if (!this.statusWritten) {\n                // status will be inferred as \"200 OK\"\n                this.writeBufferedHeaders();\n            }\n            this.res.end(data);\n        });\n    }\n    onData(fn) {\n        if (this.isAborted) return;\n        this.res.onData(fn);\n    }\n    onAborted(fn) {\n        if (this.isAborted) return;\n        this.res.onAborted(()=>{\n            // Any attempt to use the UWS response object after abort will throw!\n            this.isAborted = true;\n            fn();\n        });\n    }\n    cork(fn) {\n        if (this.isAborted) return;\n        this.res.cork(fn);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3VzZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLE1BQU1HLFVBQVVDLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLGdFQUFVO0FBQ25DLE1BQU1FLG1CQUFtQkYsbUJBQU9BLENBQUMsc0ZBQWtCO0FBQ25ELE1BQU1HLFFBQVEsQ0FBQyxHQUFHSixRQUFRSyxPQUFPLEVBQUU7QUFDbkM7O0NBRUMsR0FDRCxzQ0FBc0M7QUFDdEMsTUFBTU4sZ0JBQWdCRyxTQUFTSSxVQUFVO0lBQ3JDQyxPQUFPLENBQUU7SUFDVEMsVUFBVSxDQUFFO0lBQ1o7Ozs7S0FJQyxHQUNEQyxRQUFRQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUNkRCxJQUFJRSxNQUFNLEdBQUdGLElBQUlHLFNBQVMsR0FBR0MsV0FBVztRQUN4Q0osSUFBSUssR0FBRyxHQUFHTCxJQUFJTSxNQUFNO1FBQ3BCLE1BQU1DLFNBQVMsSUFBSUMsZ0JBQWdCUixJQUFJUyxRQUFRO1FBQy9DVCxJQUFJVSxNQUFNLEdBQUd6QixPQUFPMEIsV0FBVyxDQUFDSixPQUFPSyxPQUFPO1FBQzlDWixJQUFJYSxPQUFPLEdBQUcsQ0FBQztRQUNmYixJQUFJYyxPQUFPLENBQUMsQ0FBQ0MsS0FBSzNCO1lBQ2RZLElBQUlhLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHM0I7UUFDdkI7UUFDQVksSUFBSWdCLFVBQVUsR0FBRztZQUNiQyxlQUFlQyxPQUFPQyxJQUFJLENBQUNsQixJQUFJbUIsc0JBQXNCLElBQUlDLFFBQVE7UUFDckU7UUFDQXBCLElBQUlxQixTQUFTLENBQUM7WUFDVjVCLE1BQU07UUFDVjtJQUNKO0lBQ0E2QixnQkFBZ0JDLGFBQWEsRUFBRXhCLEdBQUcsRUFBRTtRQUNoQyxPQUFPLElBQUlQ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SSxDQUFDWCxTQUFTLEVBQ2Q7UUFDSixJQUFJLENBQUMzRixHQUFHLENBQUNxRyxJQUFJLENBQUNDO0lBQ2xCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYXZvY2hhdC1hcHAvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3VzZXJ2ZXIuanM/ZWI5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudVNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbmNvbnN0IHRyYW5zcG9ydHNfdXdzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzLXV3c1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6dXdzXCIpO1xuLyoqXG4gKiBBbiBFbmdpbmUuSU8gc2VydmVyIGJhc2VkIG9uIHRoZSBgdVdlYlNvY2tldHMuanNgIHBhY2thZ2UuXG4gKi9cbi8vIFRPRE8gZXhwb3J0IGl0IGludG8gaXRzIG93biBwYWNrYWdlXG5jbGFzcyB1U2VydmVyIGV4dGVuZHMgc2VydmVyXzEuQmFzZVNlcnZlciB7XG4gICAgaW5pdCgpIHsgfVxuICAgIGNsZWFudXAoKSB7IH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBhIHJlcXVlc3QgYnkgcHJvY2Vzc2luZyB0aGUgcXVlcnkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcmVwYXJlKHJlcSwgcmVzKSB7XG4gICAgICAgIHJlcS5tZXRob2QgPSByZXEuZ2V0TWV0aG9kKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgcmVxLnVybCA9IHJlcS5nZXRVcmwoKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhyZXEuZ2V0UXVlcnkoKSk7XG4gICAgICAgIHJlcS5fcXVlcnkgPSBPYmplY3QuZnJvbUVudHJpZXMocGFyYW1zLmVudHJpZXMoKSk7XG4gICAgICAgIHJlcS5oZWFkZXJzID0ge307XG4gICAgICAgIHJlcS5mb3JFYWNoKChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXEuaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXEuY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IEJ1ZmZlci5mcm9tKHJlcy5nZXRSZW1vdGVBZGRyZXNzQXNUZXh0KCkpLnRvU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgICAgIHJlcy5vbkFib3J0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJyZXNwb25zZSBoYXMgYmVlbiBhYm9ydGVkXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydE5hbWUsIHJlcSkge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zcG9ydHNfdXdzXzEuZGVmYXVsdFt0cmFuc3BvcnROYW1lXShyZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIGVuZ2luZSB0byBhIMK1V2ViU29ja2V0cy5qcyBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0gYXBwXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhdHRhY2goYXBwIC8qIDogVGVtcGxhdGVkQXBwICovLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuX2NvbXB1dGVQYXRoKG9wdGlvbnMpO1xuICAgICAgICBhcHBcbiAgICAgICAgICAgIC5hbnkocGF0aCwgdGhpcy5oYW5kbGVSZXF1ZXN0LmJpbmQodGhpcykpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLndzKHBhdGgsIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICAgICAgaWRsZVRpbWVvdXQ6IG9wdGlvbnMuaWRsZVRpbWVvdXQsXG4gICAgICAgICAgICBtYXhCYWNrcHJlc3N1cmU6IG9wdGlvbnMubWF4QmFja3ByZXNzdXJlLFxuICAgICAgICAgICAgbWF4UGF5bG9hZExlbmd0aDogdGhpcy5vcHRzLm1heEh0dHBCdWZmZXJTaXplLFxuICAgICAgICAgICAgdXBncmFkZTogdGhpcy5oYW5kbGVVcGdyYWRlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvcGVuOiAod3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSB3cy5nZXRVc2VyRGF0YSgpLnRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc29ja2V0ID0gd3M7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZW1pdChcInJlYWR5XCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICh3cywgbWVzc2FnZSwgaXNCaW5hcnkpID0+IHtcbiAgICAgICAgICAgICAgICB3cy5nZXRVc2VyRGF0YSgpLnRyYW5zcG9ydC5vbkRhdGEoaXNCaW5hcnkgPyBtZXNzYWdlIDogQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6ICh3cywgY29kZSwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHdzLmdldFVzZXJEYXRhKCkudHJhbnNwb3J0Lm9uQ2xvc2UoY29kZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FwcGx5TWlkZGxld2FyZXMocmVxLCByZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1pZGRsZXdhcmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVlZGVkIHRvIGJ1ZmZlciBoZWFkZXJzIHVudGlsIHRoZSBzdGF0dXMgaXMgY29tcHV0ZWRcbiAgICAgICAgcmVxLnJlcyA9IG5ldyBSZXNwb25zZVdyYXBwZXIocmVzKTtcbiAgICAgICAgc3VwZXIuX2FwcGx5TWlkZGxld2FyZXMocmVxLCByZXEucmVzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAvLyBzb21lIG1pZGRsZXdhcmVzIChsaWtlIGV4cHJlc3Mtc2Vzc2lvbikgd2FpdCBmb3IgdGhlIHdyaXRlSGVhZCgpIGNhbGwgdG8gZmx1c2ggdGhlaXIgaGVhZGVyc1xuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9leHByZXNzanMvc2Vzc2lvbi9ibG9iLzEwMTBmYWRjMmYwNzFkZGYyYWRkOTQyMzVkNzIyMjRjZjY1MTU5YzYvaW5kZXguanMjTDIyMC1MMjQ0XG4gICAgICAgICAgICByZXEucmVzLndyaXRlSGVhZCgpO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVJlcXVlc3QocmVzLCByZXEpIHtcbiAgICAgICAgZGVidWcoJ2hhbmRsaW5nIFwiJXNcIiBodHRwIHJlcXVlc3QgXCIlc1wiJywgcmVxLmdldE1ldGhvZCgpLCByZXEuZ2V0VXJsKCkpO1xuICAgICAgICB0aGlzLnByZXBhcmUocmVxLCByZXMpO1xuICAgICAgICByZXEucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBlcnJvckNvbnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydFJlcXVlc3QocmVxLnJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXEuX3F1ZXJ5LnNpZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic2V0dGluZyBuZXcgcmVxdWVzdCBmb3IgZXhpc3RpbmcgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudHNbcmVxLl9xdWVyeS5zaWRdLnRyYW5zcG9ydC5vblJlcXVlc3QocmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlQ29ubmVjdGlvbiA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4gdGhpcy5hYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSwgY2xvc2VDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcywgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNlcnZlcl8xLlNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHsgbmFtZTogXCJNSURETEVXQVJFX0ZBSUxVUkVcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVVwZ3JhZGUocmVzLCByZXEsIGNvbnRleHQpIHtcbiAgICAgICAgZGVidWcoXCJvbiB1cGdyYWRlXCIpO1xuICAgICAgICB0aGlzLnByZXBhcmUocmVxLCByZXMpO1xuICAgICAgICByZXEucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGFzeW5jIChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBlcnJvckNvbnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSByZXEuX3F1ZXJ5LnNpZDtcbiAgICAgICAgICAgIGxldCB0cmFuc3BvcnQ7XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHNbaWRdO1xuICAgICAgICAgICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwidXBncmFkZSBhdHRlbXB0IGZvciBjbG9zZWQgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiB0cnlpbmcgdG8gdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFkIGFscmVhZHkgYmVlbiB1cGdyYWRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJ1cGdyYWRpbmcgZXhpc3RpbmcgdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Ll9tYXliZVVwZ3JhZGUodHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQgPSBhd2FpdCB0aGlzLmhhbmRzaGFrZShyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxLCAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHRoaXMuYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FsbGluZyB3cml0ZVN0YXR1cygpIHRyaWdnZXJzIHRoZSBmbHVzaGluZyBvZiBhbnkgaGVhZGVyIGFkZGVkIGluIGEgbWlkZGxld2FyZVxuICAgICAgICAgICAgcmVxLnJlcy53cml0ZVN0YXR1cyhcIjEwMSBTd2l0Y2hpbmcgUHJvdG9jb2xzXCIpO1xuICAgICAgICAgICAgcmVzLnVwZ3JhZGUoe1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydCxcbiAgICAgICAgICAgIH0sIHJlcS5nZXRIZWFkZXIoXCJzZWMtd2Vic29ja2V0LWtleVwiKSwgcmVxLmdldEhlYWRlcihcInNlYy13ZWJzb2NrZXQtcHJvdG9jb2xcIiksIHJlcS5nZXRIZWFkZXIoXCJzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnNcIiksIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc2VydmVyXzEuU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwgeyBuYW1lOiBcIk1JRERMRVdBUkVfRkFJTFVSRVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnkocmVxLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCkge1xuICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gZXJyb3JDb2RlID09PSBzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JzLkZPUkJJRERFTlxuICAgICAgICAgICAgPyBcIjQwMyBGb3JiaWRkZW5cIlxuICAgICAgICAgICAgOiBcIjQwMCBCYWQgUmVxdWVzdFwiO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JDb250ZXh0ICYmIGVycm9yQ29udGV4dC5tZXNzYWdlXG4gICAgICAgICAgICA/IGVycm9yQ29udGV4dC5tZXNzYWdlXG4gICAgICAgICAgICA6IHNlcnZlcl8xLlNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gICAgICAgIHJlcy53cml0ZVN0YXR1cyhzdGF0dXNDb2RlKTtcbiAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgcmVzLmVuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KSk7XG4gICAgfVxufVxuZXhwb3J0cy51U2VydmVyID0gdVNlcnZlcjtcbmNsYXNzIFJlc3BvbnNlV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IocmVzKSB7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICB0aGlzLnN0YXR1c1dyaXR0ZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gW107XG4gICAgICAgIHRoaXMuaXNBYm9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHNldCBzdGF0dXNDb2RlKHN0YXR1cykge1xuICAgICAgICBpZiAoIXN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZJWE1FOiBoYW5kbGUgYWxsIHN0YXR1cyBjb2Rlcz9cbiAgICAgICAgdGhpcy53cml0ZVN0YXR1cyhzdGF0dXMgPT09IDIwMCA/IFwiMjAwIE9LXCIgOiBcIjIwNCBObyBDb250ZW50XCIpO1xuICAgIH1cbiAgICB3cml0ZUhlYWQoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgICB9XG4gICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53cml0ZUhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVIZWFkZXIoKSB7XG4gICAgICAgIC8vIEZJWE1FOiBub3QgaW1wbGVtZW50ZWRcbiAgICB9XG4gICAgLy8gbmVlZGVkIGJ5IHZhcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvdmFyeS9ibG9iLzVkNzI1ZDA1OWIzODcxMDI1Y2Y3NTNlOWRmYTA4OTI0ZDBiY2ZhOGYvaW5kZXguanMjTDEzNFxuICAgIGdldEhlYWRlcigpIHsgfVxuICAgIHdyaXRlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICBpZiAodGhpcy5pc0Fib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzLndyaXRlU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIHRoaXMuc3RhdHVzV3JpdHRlbiA9IHRydWU7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJlZEhlYWRlcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdyaXRlSGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoa2V5ID09PSBcIkNvbnRlbnQtTGVuZ3RoXCIpIHtcbiAgICAgICAgICAgIC8vIHRoZSBjb250ZW50IGxlbmd0aCBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIGJ5IHVXZWJTb2NrZXRzLmpzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzV3JpdHRlbikge1xuICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyZWRIZWFkZXJzKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcy53cml0ZUhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXMuY29yaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdHVzV3JpdHRlbikge1xuICAgICAgICAgICAgICAgIC8vIHN0YXR1cyB3aWxsIGJlIGluZmVycmVkIGFzIFwiMjAwIE9LXCJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyZWRIZWFkZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcy5lbmQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbkRhdGEoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlcy5vbkRhdGEoZm4pO1xuICAgIH1cbiAgICBvbkFib3J0ZWQoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlcy5vbkFib3J0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gQW55IGF0dGVtcHQgdG8gdXNlIHRoZSBVV1MgcmVzcG9uc2Ugb2JqZWN0IGFmdGVyIGFib3J0IHdpbGwgdGhyb3chXG4gICAgICAgICAgICB0aGlzLmlzQWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29yayhmbikge1xuICAgICAgICBpZiAodGhpcy5pc0Fib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzLmNvcmsoZm4pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVTZXJ2ZXIiLCJkZWJ1Z18xIiwicmVxdWlyZSIsInNlcnZlcl8xIiwidHJhbnNwb3J0c191d3NfMSIsImRlYnVnIiwiZGVmYXVsdCIsIkJhc2VTZXJ2ZXIiLCJpbml0IiwiY2xlYW51cCIsInByZXBhcmUiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJnZXRNZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInVybCIsImdldFVybCIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImdldFF1ZXJ5IiwiX3F1ZXJ5IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiaGVhZGVycyIsImZvckVhY2giLCJrZXkiLCJjb25uZWN0aW9uIiwicmVtb3RlQWRkcmVzcyIsIkJ1ZmZlciIsImZyb20iLCJnZXRSZW1vdGVBZGRyZXNzQXNUZXh0IiwidG9TdHJpbmciLCJvbkFib3J0ZWQiLCJjcmVhdGVUcmFuc3BvcnQiLCJ0cmFuc3BvcnROYW1lIiwiYXR0YWNoIiwiYXBwIiwib3B0aW9ucyIsInBhdGgiLCJfY29tcHV0ZVBhdGgiLCJhbnkiLCJoYW5kbGVSZXF1ZXN0IiwiYmluZCIsIndzIiwiY29tcHJlc3Npb24iLCJpZGxlVGltZW91dCIsIm1heEJhY2twcmVzc3VyZSIsIm1heFBheWxvYWRMZW5ndGgiLCJvcHRzIiwibWF4SHR0cEJ1ZmZlclNpemUiLCJ1cGdyYWRlIiwiaGFuZGxlVXBncmFkZSIsIm9wZW4iLCJ0cmFuc3BvcnQiLCJnZXRVc2VyRGF0YSIsInNvY2tldCIsIndyaXRhYmxlIiwiZW1pdCIsIm1lc3NhZ2UiLCJpc0JpbmFyeSIsIm9uRGF0YSIsImNsb3NlIiwiY29kZSIsIm9uQ2xvc2UiLCJfYXBwbHlNaWRkbGV3YXJlcyIsImNhbGxiYWNrIiwibWlkZGxld2FyZXMiLCJsZW5ndGgiLCJSZXNwb25zZVdyYXBwZXIiLCJlcnIiLCJ3cml0ZUhlYWQiLCJlcnJvckNvZGUiLCJlcnJvckNvbnRleHQiLCJ1bmRlZmluZWQiLCJTZXJ2ZXIiLCJlcnJvck1lc3NhZ2VzIiwiY29udGV4dCIsImFib3J0UmVxdWVzdCIsInNpZCIsImNsaWVudHMiLCJvblJlcXVlc3QiLCJjbG9zZUNvbm5lY3Rpb24iLCJoYW5kc2hha2UiLCJlcnJvcnMiLCJCQURfUkVRVUVTVCIsIm5hbWUiLCJ2ZXJpZnkiLCJpZCIsImNsaWVudCIsInVwZ3JhZGluZyIsInVwZ3JhZGVkIiwiX21heWJlVXBncmFkZSIsIndyaXRlU3RhdHVzIiwiZ2V0SGVhZGVyIiwic3RhdHVzQ29kZSIsIkZPUkJJRERFTiIsIndyaXRlSGVhZGVyIiwiZW5kIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnN0cnVjdG9yIiwic3RhdHVzV3JpdHRlbiIsImlzQWJvcnRlZCIsInN0YXR1cyIsInNldEhlYWRlciIsIkFycmF5IiwiaXNBcnJheSIsInZhbCIsInJlbW92ZUhlYWRlciIsIndyaXRlQnVmZmVyZWRIZWFkZXJzIiwicHVzaCIsImRhdGEiLCJjb3JrIiwiZm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/userver.js\n");

/***/ })

};
;